###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       21/Sep/2016  16:57:23
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\01work\proj\地磁\Code\Drivers\Core\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_flash.c
#    Command line =  
#        D:\01work\proj\地磁\Code\Drivers\Core\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_flash.c
#        -D USE_HAL_DRIVER -D STM32L151xD -lC
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5\Debug\List -lA
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5\Debug\List -o
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5\Debug\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Apps/Config\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers\Inc\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers\Core\CMSIS\RTOS\Template\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/STM32L1xx_HAL_Driver/Config\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Middlewares/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Middlewares/FreeRTOS/Source/include\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/CMSIS/Include\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/RTT\
#        -I D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers\
#        -I D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../BSP/Inc/\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/CMSIS/Device/ST/STM32L1xx/Include\
#        -Ol
#    List file    =  
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5\Debug\List\stm32l1xx_hal_flash.lst
#    Object file  =  
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5\Debug\Obj\stm32l1xx_hal_flash.o
#
###############################################################################

D:\01work\proj\地磁\Code\Drivers\Core\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_flash.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_hal_flash.c
      4            * @author  MCD Application Team
      5            * @version V1.2.0
      6            * @date    01-July-2016
      7            * @brief   FLASH HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the internal FLASH memory:
     10            *           + Program operations functions
     11            *           + Memory Control functions 
     12            *           + Peripheral State functions
     13            *         
     14            @verbatim
     15            ==============================================================================
     16                                  ##### FLASH peripheral features #####
     17            ==============================================================================
     18            [..] The Flash memory interface manages CPU AHB I-Code and D-Code accesses 
     19                 to the Flash memory. It implements the erase and program Flash memory operations 
     20                 and the read and write protection mechanisms.
     21          
     22            [..] The Flash memory interface accelerates code execution with a system of instruction
     23                prefetch. 
     24          
     25            [..] The FLASH main features are:
     26                (+) Flash memory read operations
     27                (+) Flash memory program/erase operations
     28                (+) Read / write protections
     29                (+) Prefetch on I-Code
     30                (+) Option Bytes programming
     31          
     32          
     33                               ##### How to use this driver #####
     34            ==============================================================================
     35            [..]                             
     36                This driver provides functions and macros to configure and program the FLASH 
     37                memory of all STM32L1xx devices.
     38              
     39                (#) FLASH Memory I/O Programming functions: this group includes all needed
     40                    functions to erase and program the main memory:
     41                  (++) Lock and Unlock the FLASH interface
     42                  (++) Erase function: Erase page
     43                  (++) Program functions: Fast Word and Half Page(should be 
     44                  executed from internal SRAM).
     45            
     46                (#) DATA EEPROM Programming functions: this group includes all 
     47                    needed functions to erase and program the DATA EEPROM memory:
     48                  (++) Lock and Unlock the DATA EEPROM interface.
     49                  (++) Erase function: Erase Byte, erase HalfWord, erase Word, erase 
     50                       Double Word (should be executed from internal SRAM).
     51                  (++) Program functions: Fast Program Byte, Fast Program Half-Word, 
     52                       FastProgramWord, Program Byte, Program Half-Word, 
     53                       Program Word and Program Double-Word (should be executed 
     54                       from internal SRAM).
     55          
     56                (#) FLASH Option Bytes Programming functions: this group includes all needed
     57                    functions to manage the Option Bytes:
     58                  (++) Lock and Unlock the Option Bytes
     59                  (++) Set/Reset the write protection
     60                  (++) Set the Read protection Level
     61                  (++) Program the user Option Bytes
     62                  (++) Launch the Option Bytes loader
     63                  (++) Set/Get the Read protection Level.
     64                  (++) Set/Get the BOR level.
     65                  (++) Get the Write protection.
     66                  (++) Get the user option bytes.
     67              
     68                (#) Interrupts and flags management functions : this group 
     69                    includes all needed functions to:
     70                  (++) Handle FLASH interrupts
     71                  (++) Wait for last FLASH operation according to its status
     72                  (++) Get error flag status
     73          
     74              (#) FLASH Interface configuration functions: this group includes 
     75                the management of following features:
     76                (++) Enable/Disable the RUN PowerDown mode.
     77                (++) Enable/Disable the SLEEP PowerDown mode.  
     78            
     79              (#) FLASH Peripheral State methods: this group includes 
     80                the management of following features:
     81                (++) Wait for the FLASH operation
     82                (++)  Get the specific FLASH error flag
     83              
     84            [..] In addition to these function, this driver includes a set of macros allowing
     85                 to handle the following operations:
     86                
     87                (+) Set/Get the latency
     88                (+) Enable/Disable the prefetch buffer
     89                (+) Enable/Disable the 64 bit Read Access.
     90                (+) Enable/Disable the Flash power-down
     91                (+) Enable/Disable the FLASH interrupts
     92                (+) Monitor the FLASH flags status
     93                    
     94                           ##### Programming operation functions #####
     95            ===============================================================================  
     96               [..]
     97               This subsection provides a set of functions allowing to manage the FLASH 
     98               program operations.
     99            
    100              [..] The FLASH Memory Programming functions, includes the following functions:
    101               (+) HAL_FLASH_Unlock(void);
    102               (+) HAL_FLASH_Lock(void);
    103               (+) HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint32_t Data)
    104               (+) HAL_FLASH_Program_IT(uint32_t TypeProgram, uint32_t Address, uint32_t Data)
    105              
    106               [..] Any operation of erase or program should follow these steps:
    107               (#) Call the HAL_FLASH_Unlock() function to enable the flash control register and 
    108                   program memory access.
    109               (#) Call the desired function to erase page or program data.
    110               (#) Call the HAL_FLASH_Lock() to disable the flash program memory access 
    111                  (recommended to protect the FLASH memory against possible unwanted operation).
    112            
    113                         ##### Option Bytes Programming functions ##### 
    114             ==============================================================================  
    115            
    116               [..] The FLASH_Option Bytes Programming_functions, includes the following functions:
    117               (+) HAL_FLASH_OB_Unlock(void);
    118               (+) HAL_FLASH_OB_Lock(void);
    119               (+) HAL_FLASH_OB_Launch(void);
    120               (+) HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit);
    121               (+) HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit);
    122              
    123               [..] Any operation of erase or program should follow these steps:
    124               (#) Call the HAL_FLASH_OB_Unlock() function to enable the Flash option control 
    125                   register access.
    126               (#) Call the following functions to program the desired option bytes.
    127                   (++) HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit);      
    128               (#) Once all needed option bytes to be programmed are correctly written, call the
    129                   HAL_FLASH_OB_Launch(void) function to launch the Option Bytes programming process.
    130               (#) Call the HAL_FLASH_OB_Lock() to disable the Flash option control register access (recommended
    131                   to protect the option Bytes against possible unwanted operations).
    132            
    133              [..] Proprietary code Read Out Protection (PcROP):    
    134              (#) The PcROP sector is selected by using the same option bytes as the Write
    135                  protection. As a result, these 2 options are exclusive each other.
    136              (#) To activate PCROP mode for Flash sectors(s), you need to follow the sequence below:
    137                  (++) Use this function HAL_FLASHEx_AdvOBProgram with PCROPState = OB_PCROP_STATE_ENABLE.
    138          
    139            @endverbatim
    140            ******************************************************************************
    141            * @attention
    142            *
    143            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
    144            *
    145            * Redistribution and use in source and binary forms, with or without modification,
    146            * are permitted provided that the following conditions are met:
    147            *   1. Redistributions of source code must retain the above copyright notice,
    148            *      this list of conditions and the following disclaimer.
    149            *   2. Redistributions in binary form must reproduce the above copyright notice,
    150            *      this list of conditions and the following disclaimer in the documentation
    151            *      and/or other materials provided with the distribution.
    152            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    153            *      may be used to endorse or promote products derived from this software
    154            *      without specific prior written permission.
    155            *
    156            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    157            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    158            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    159            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    160            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    161            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    162            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    163            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    164            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    165            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    166            *
    167            ******************************************************************************  
    168            */
    169          
    170          /* Includes ------------------------------------------------------------------*/
    171          #include "stm32l1xx_hal.h"
    172          
    173          /** @addtogroup STM32L1xx_HAL_Driver
    174            * @{
    175            */
    176          
    177          #ifdef HAL_FLASH_MODULE_ENABLED
    178          
    179          /** @defgroup FLASH FLASH
    180            * @brief FLASH HAL module driver
    181            * @{
    182            */
    183          
    184          /* Private typedef -----------------------------------------------------------*/
    185          /* Private define ------------------------------------------------------------*/
    186          /** @defgroup FLASH_Private_Constants FLASH Private Constants
    187            * @{
    188            */
    189          /**
    190            * @}
    191            */
    192          
    193          /* Private macro ---------------------------- ---------------------------------*/
    194          /** @defgroup FLASH_Private_Macros FLASH Private Macros
    195            * @{
    196            */
    197           
    198          /**
    199            * @}
    200            */
    201          
    202          /* Private variables ---------------------------------------------------------*/
    203          /** @defgroup FLASH_Private_Variables FLASH Private Variables
    204            * @{
    205            */
    206          /* Variables used for Erase pages under interruption*/

   \                                 In section .bss, align 4
    207          FLASH_ProcessTypeDef pFlash;
   \                     pFlash:
   \   00000000                      DS8 24
    208          /**
    209            * @}
    210            */
    211          
    212          /* Private function prototypes -----------------------------------------------*/
    213          /** @defgroup FLASH_Private_Functions FLASH Private Functions
    214            * @{
    215            */
    216          static  void   FLASH_SetErrorCode(void);
    217          extern void    FLASH_PageErase(uint32_t PageAddress);
    218          /**
    219            * @}
    220            */
    221          
    222          /* Exported functions ---------------------------------------------------------*/
    223          /** @defgroup FLASH_Exported_Functions FLASH Exported Functions
    224            * @{
    225            */
    226            
    227          /** @defgroup FLASH_Exported_Functions_Group1 Programming operation functions 
    228            *  @brief   Programming operation functions 
    229            *
    230          @verbatim   
    231          @endverbatim
    232            * @{
    233            */
    234          
    235          /**
    236            * @brief  Program word at a specified address
    237            * @note   To correctly run this function, the HAL_FLASH_Unlock() function
    238            *         must be called before.
    239            *         Call the HAL_FLASH_Lock() to disable the flash memory access
    240            *         (recommended to protect the FLASH memory against possible unwanted operation).
    241            *
    242            * @param  TypeProgram:  Indicate the way to program at a specified address.
    243            *                       This parameter can be a value of @ref FLASH_Type_Program
    244            * @param  Address:      Specifies the address to be programmed.
    245            * @param  Data:         Specifies the data to be programmed
    246            * 
    247            * @retval HAL_StatusTypeDef HAL Status
    248            */

   \                                 In section .text, align 2, keep-with-next
    249          HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint32_t Data)
    250          {
   \                     HAL_FLASH_Program: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x000C             MOVS     R4,R1
   \   00000004   0x0015             MOVS     R5,R2
    251            HAL_StatusTypeDef status = HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
    252            
    253            /* Process Locked */
    254            __HAL_LOCK(&pFlash);
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable10
   \   0000000C   0x7C00             LDRB     R0,[R0, #+16]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD101             BNE.N    ??HAL_FLASH_Program_0
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xE016             B.N      ??HAL_FLASH_Program_1
   \                     ??HAL_FLASH_Program_0: (+1)
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable10
   \   0000001C   0x7408             STRB     R0,[R1, #+16]
    255          
    256            /* Check the parameters */
    257            assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
    258            assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));
    259          
    260            /* Wait for last operation to be completed */
    261            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   0000001E   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000022   0x.... 0x....      BL       FLASH_WaitForLastOperation
    262            
    263            if(status == HAL_OK)
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD107             BNE.N    ??HAL_FLASH_Program_2
    264            {
    265              /* Clean the error context */
    266              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x....             LDR.N    R1,??DataTable10
   \   00000030   0x6148             STR      R0,[R1, #+20]
    267          
    268              /*Program word (32-bit) at a specified address.*/
    269              *(__IO uint32_t *)Address = Data;
   \   00000032   0x6025             STR      R5,[R4, #+0]
    270          
    271              /* Wait for last operation to be completed */
    272              status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   00000034   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000038   0x.... 0x....      BL       FLASH_WaitForLastOperation
    273            }
    274          
    275            /* Process Unlocked */
    276            __HAL_UNLOCK(&pFlash);
   \                     ??HAL_FLASH_Program_2: (+1)
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x....             LDR.N    R2,??DataTable10
   \   00000040   0x7411             STRB     R1,[R2, #+16]
    277          
    278            return status;
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_FLASH_Program_1: (+1)
   \   00000044   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    279          }
    280          
    281          /**
    282            * @brief   Program word at a specified address  with interrupt enabled.
    283            *
    284            * @param  TypeProgram: Indicate the way to program at a specified address.
    285            *                      This parameter can be a value of @ref FLASH_Type_Program
    286            * @param  Address:     Specifies the address to be programmed.
    287            * @param  Data:        Specifies the data to be programmed
    288            * 
    289            * @retval HAL_StatusTypeDef HAL Status
    290            */

   \                                 In section .text, align 2, keep-with-next
    291          HAL_StatusTypeDef HAL_FLASH_Program_IT(uint32_t TypeProgram, uint32_t Address, uint32_t Data)
    292          {
   \                     HAL_FLASH_Program_IT: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    293            HAL_StatusTypeDef status = HAL_OK;
   \   00000002   0x2300             MOVS     R3,#+0
    294            
    295            /* Process Locked */
    296            __HAL_LOCK(&pFlash);
   \   00000004   0x....             LDR.N    R4,??DataTable10
   \   00000006   0x7C24             LDRB     R4,[R4, #+16]
   \   00000008   0x2C01             CMP      R4,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_FLASH_Program_IT_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE015             B.N      ??HAL_FLASH_Program_IT_1
   \                     ??HAL_FLASH_Program_IT_0: (+1)
   \   00000010   0x2401             MOVS     R4,#+1
   \   00000012   0x....             LDR.N    R5,??DataTable10
   \   00000014   0x742C             STRB     R4,[R5, #+16]
    297          
    298            /* Check the parameters */
    299            assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
    300            assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));
    301          
    302            /* Enable End of FLASH Operation and Error source interrupts */
    303            __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP | FLASH_IT_ERR);
   \   00000016   0x....             LDR.N    R4,??DataTable10_1  ;; 0x40023c04
   \   00000018   0x6824             LDR      R4,[R4, #+0]
   \   0000001A   0xF454 0x3440      ORRS     R4,R4,#0x30000
   \   0000001E   0x....             LDR.N    R5,??DataTable10_1  ;; 0x40023c04
   \   00000020   0x602C             STR      R4,[R5, #+0]
    304            
    305            pFlash.Address = Address;
   \   00000022   0x....             LDR.N    R4,??DataTable10
   \   00000024   0x60A1             STR      R1,[R4, #+8]
    306            pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAM;
   \   00000026   0x2402             MOVS     R4,#+2
   \   00000028   0x....             LDR.N    R5,??DataTable10
   \   0000002A   0x702C             STRB     R4,[R5, #+0]
    307            /* Clean the error context */
    308            pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \   0000002C   0x2400             MOVS     R4,#+0
   \   0000002E   0x....             LDR.N    R5,??DataTable10
   \   00000030   0x616C             STR      R4,[R5, #+20]
    309          
    310            if(TypeProgram == FLASH_TYPEPROGRAM_WORD)
   \   00000032   0x2802             CMP      R0,#+2
   \   00000034   0xD100             BNE.N    ??HAL_FLASH_Program_IT_2
    311            {
    312              /* Program word (32-bit) at a specified address. */
    313              *(__IO uint32_t *)Address = Data;
   \   00000036   0x600A             STR      R2,[R1, #+0]
    314            }
    315            return status;
   \                     ??HAL_FLASH_Program_IT_2: (+1)
   \   00000038   0x0018             MOVS     R0,R3
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_FLASH_Program_IT_1: (+1)
   \   0000003C   0xBC30             POP      {R4,R5}
   \   0000003E   0x4770             BX       LR               ;; return
    316          }
    317          
    318          /**
    319            * @brief This function handles FLASH interrupt request.
    320            * @retval None
    321            */

   \                                 In section .text, align 2, keep-with-next
    322          void HAL_FLASH_IRQHandler(void)
    323          {
   \                     HAL_FLASH_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    324            uint32_t addresstmp = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    325            
    326            /* Check FLASH operation error flags */
    327            if( __HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)     || 
    328                __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR)     || 
    329                __HAL_FLASH_GET_FLAG(FLASH_FLAG_SIZERR)     || 
    330          #if defined(FLASH_SR_RDERR)
    331                __HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR)      || 
    332          #endif /* FLASH_SR_RDERR */
    333          #if defined(FLASH_SR_OPTVERRUSR)
    334                __HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERRUSR) || 
    335          #endif /* FLASH_SR_OPTVERRUSR */
    336                __HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR) )
   \   00000004   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40023c18
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x05C0             LSLS     R0,R0,#+23
   \   0000000A   0xD40F             BMI.N    ??HAL_FLASH_IRQHandler_0
   \   0000000C   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40023c18
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x0580             LSLS     R0,R0,#+22
   \   00000012   0xD40B             BMI.N    ??HAL_FLASH_IRQHandler_0
   \   00000014   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40023c18
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x0540             LSLS     R0,R0,#+21
   \   0000001A   0xD407             BMI.N    ??HAL_FLASH_IRQHandler_0
   \   0000001C   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40023c18
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x04C0             LSLS     R0,R0,#+19
   \   00000022   0xD403             BMI.N    ??HAL_FLASH_IRQHandler_0
   \   00000024   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40023c18
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x0500             LSLS     R0,R0,#+20
   \   0000002A   0xD514             BPL.N    ??HAL_FLASH_IRQHandler_1
    337            {
    338              if(pFlash.ProcedureOnGoing == FLASH_PROC_PAGEERASE)
   \                     ??HAL_FLASH_IRQHandler_0: (+1)
   \   0000002C   0x....             LDR.N    R0,??DataTable10
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xD106             BNE.N    ??HAL_FLASH_IRQHandler_2
    339              {
    340                /* Return the faulty sector */
    341                addresstmp = pFlash.Page;
   \   00000034   0x....             LDR.N    R0,??DataTable10
   \   00000036   0x68C4             LDR      R4,[R0, #+12]
    342                pFlash.Page = 0xFFFFFFFFU;
   \   00000038   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000003C   0x....             LDR.N    R1,??DataTable10
   \   0000003E   0x60C8             STR      R0,[R1, #+12]
   \   00000040   0xE001             B.N      ??HAL_FLASH_IRQHandler_3
    343              }
    344              else
    345              {
    346                /* Return the faulty address */
    347                addresstmp = pFlash.Address;
   \                     ??HAL_FLASH_IRQHandler_2: (+1)
   \   00000042   0x....             LDR.N    R0,??DataTable10
   \   00000044   0x6884             LDR      R4,[R0, #+8]
    348              }
    349              /* Save the Error code */
    350              FLASH_SetErrorCode();
   \                     ??HAL_FLASH_IRQHandler_3: (+1)
   \   00000046   0x.... 0x....      BL       FLASH_SetErrorCode
    351              
    352              /* FLASH error interrupt user callback */
    353              HAL_FLASH_OperationErrorCallback(addresstmp);
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0x.... 0x....      BL       HAL_FLASH_OperationErrorCallback
    354          
    355              /* Stop the procedure ongoing */
    356              pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x....             LDR.N    R1,??DataTable10
   \   00000054   0x7008             STRB     R0,[R1, #+0]
    357            }
    358          
    359            /* Check FLASH End of Operation flag  */
    360            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
   \                     ??HAL_FLASH_IRQHandler_1: (+1)
   \   00000056   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40023c18
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0x0780             LSLS     R0,R0,#+30
   \   0000005C   0xD544             BPL.N    ??HAL_FLASH_IRQHandler_4
    361            {
    362              /* Clear FLASH End of Operation pending bit */
    363              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
   \   0000005E   0x2002             MOVS     R0,#+2
   \   00000060   0x....             LDR.N    R1,??DataTable10_2  ;; 0x40023c18
   \   00000062   0x6008             STR      R0,[R1, #+0]
    364              
    365              /* Process can continue only if no error detected */
    366              if(pFlash.ProcedureOnGoing != FLASH_PROC_NONE)
   \   00000064   0x....             LDR.N    R0,??DataTable10
   \   00000066   0x7800             LDRB     R0,[R0, #+0]
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD03D             BEQ.N    ??HAL_FLASH_IRQHandler_4
    367              {
    368                if(pFlash.ProcedureOnGoing == FLASH_PROC_PAGEERASE)
   \   0000006C   0x....             LDR.N    R0,??DataTable10
   \   0000006E   0x7800             LDRB     R0,[R0, #+0]
   \   00000070   0x2801             CMP      R0,#+1
   \   00000072   0xD128             BNE.N    ??HAL_FLASH_IRQHandler_5
    369                {
    370                  /* Nb of pages to erased can be decreased */
    371                  pFlash.NbPagesToErase--;
   \   00000074   0x....             LDR.N    R0,??DataTable10
   \   00000076   0x6840             LDR      R0,[R0, #+4]
   \   00000078   0x1E40             SUBS     R0,R0,#+1
   \   0000007A   0x....             LDR.N    R1,??DataTable10
   \   0000007C   0x6048             STR      R0,[R1, #+4]
    372          
    373                  /* Check if there are still pages to erase */
    374                  if(pFlash.NbPagesToErase != 0)
   \   0000007E   0x....             LDR.N    R0,??DataTable10
   \   00000080   0x6840             LDR      R0,[R0, #+4]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD014             BEQ.N    ??HAL_FLASH_IRQHandler_6
    375                  {
    376                    addresstmp = pFlash.Page;
   \   00000086   0x....             LDR.N    R0,??DataTable10
   \   00000088   0x68C4             LDR      R4,[R0, #+12]
    377                    /*Indicate user which sector has been erased */
    378                    HAL_FLASH_EndOfOperationCallback(addresstmp);
   \   0000008A   0x0020             MOVS     R0,R4
   \   0000008C   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
    379          
    380                    /*Increment sector number*/
    381                    addresstmp = pFlash.Page + FLASH_PAGE_SIZE;
   \   00000090   0x....             LDR.N    R0,??DataTable10
   \   00000092   0x68C0             LDR      R0,[R0, #+12]
   \   00000094   0xF510 0x7480      ADDS     R4,R0,#+256
    382                    pFlash.Page = addresstmp;
   \   00000098   0x....             LDR.N    R0,??DataTable10
   \   0000009A   0x60C4             STR      R4,[R0, #+12]
    383          
    384                    /* If the erase operation is completed, disable the ERASE Bit */
    385                    CLEAR_BIT(FLASH->PECR, FLASH_PECR_ERASE);
   \   0000009C   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40023c04
   \   0000009E   0x6800             LDR      R0,[R0, #+0]
   \   000000A0   0xF430 0x7000      BICS     R0,R0,#0x200
   \   000000A4   0x....             LDR.N    R1,??DataTable10_1  ;; 0x40023c04
   \   000000A6   0x6008             STR      R0,[R1, #+0]
    386          
    387                    FLASH_PageErase(addresstmp);
   \   000000A8   0x0020             MOVS     R0,R4
   \   000000AA   0x.... 0x....      BL       FLASH_PageErase
   \   000000AE   0xE01B             B.N      ??HAL_FLASH_IRQHandler_4
    388                  }
    389                  else
    390                  {
    391                    /* No more pages to Erase, user callback can be called. */
    392                    /* Reset Sector and stop Erase pages procedure */
    393                    pFlash.Page = addresstmp = 0xFFFFFFFFU;
   \                     ??HAL_FLASH_IRQHandler_6: (+1)
   \   000000B0   0xF05F 0x34FF      MOVS     R4,#-1
   \   000000B4   0x....             LDR.N    R0,??DataTable10
   \   000000B6   0x60C4             STR      R4,[R0, #+12]
    394                    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x....             LDR.N    R1,??DataTable10
   \   000000BC   0x7008             STRB     R0,[R1, #+0]
    395                    /* FLASH EOP interrupt user callback */
    396                    HAL_FLASH_EndOfOperationCallback(addresstmp);
   \   000000BE   0x0020             MOVS     R0,R4
   \   000000C0   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
   \   000000C4   0xE010             B.N      ??HAL_FLASH_IRQHandler_4
    397                  }
    398                }
    399                else
    400                {
    401                    /* If the program operation is completed, disable the PROG Bit */
    402                    CLEAR_BIT(FLASH->PECR, FLASH_PECR_PROG);
   \                     ??HAL_FLASH_IRQHandler_5: (+1)
   \   000000C6   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40023c04
   \   000000C8   0x6800             LDR      R0,[R0, #+0]
   \   000000CA   0xF030 0x0008      BICS     R0,R0,#0x8
   \   000000CE   0x....             LDR.N    R1,??DataTable10_1  ;; 0x40023c04
   \   000000D0   0x6008             STR      R0,[R1, #+0]
    403          
    404                    /* Program ended. Return the selected address */
    405                    /* FLASH EOP interrupt user callback */
    406                    HAL_FLASH_EndOfOperationCallback(pFlash.Address);
   \   000000D2   0x....             LDR.N    R0,??DataTable10
   \   000000D4   0x6880             LDR      R0,[R0, #+8]
   \   000000D6   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
    407                  
    408                    /* Reset Address and stop Program procedure */
    409                    pFlash.Address = 0xFFFFFFFFU;
   \   000000DA   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000DE   0x....             LDR.N    R1,??DataTable10
   \   000000E0   0x6088             STR      R0,[R1, #+8]
    410                    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0x....             LDR.N    R1,??DataTable10
   \   000000E6   0x7008             STRB     R0,[R1, #+0]
    411                }
    412              }
    413            }
    414            
    415          
    416            if(pFlash.ProcedureOnGoing == FLASH_PROC_NONE)
   \                     ??HAL_FLASH_IRQHandler_4: (+1)
   \   000000E8   0x....             LDR.N    R0,??DataTable10
   \   000000EA   0x7800             LDRB     R0,[R0, #+0]
   \   000000EC   0x2800             CMP      R0,#+0
   \   000000EE   0xD10E             BNE.N    ??HAL_FLASH_IRQHandler_7
    417            {
    418              /* Operation is completed, disable the PROG and ERASE */
    419              CLEAR_BIT(FLASH->PECR, (FLASH_PECR_ERASE | FLASH_PECR_PROG));
   \   000000F0   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40023c04
   \   000000F2   0x6800             LDR      R0,[R0, #+0]
   \   000000F4   0xF430 0x7002      BICS     R0,R0,#0x208
   \   000000F8   0x....             LDR.N    R1,??DataTable10_1  ;; 0x40023c04
   \   000000FA   0x6008             STR      R0,[R1, #+0]
    420          
    421              /* Disable End of FLASH Operation and Error source interrupts */
    422              __HAL_FLASH_DISABLE_IT(FLASH_IT_EOP | FLASH_IT_ERR);
   \   000000FC   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40023c04
   \   000000FE   0x6800             LDR      R0,[R0, #+0]
   \   00000100   0xF430 0x3040      BICS     R0,R0,#0x30000
   \   00000104   0x....             LDR.N    R1,??DataTable10_1  ;; 0x40023c04
   \   00000106   0x6008             STR      R0,[R1, #+0]
    423          
    424              /* Process Unlocked */
    425              __HAL_UNLOCK(&pFlash);
   \   00000108   0x2000             MOVS     R0,#+0
   \   0000010A   0x....             LDR.N    R1,??DataTable10
   \   0000010C   0x7408             STRB     R0,[R1, #+16]
    426            }
    427          }
   \                     ??HAL_FLASH_IRQHandler_7: (+1)
   \   0000010E   0xBD10             POP      {R4,PC}          ;; return
    428          
    429          /**
    430            * @brief  FLASH end of operation interrupt callback
    431            * @param  ReturnValue: The value saved in this parameter depends on the ongoing procedure
    432            *                 - Pages Erase: Address of the page which has been erased 
    433            *                    (if 0xFFFFFFFF, it means that all the selected pages have been erased)
    434            *                 - Program: Address which was selected for data program
    435            * @retval none
    436            */

   \                                 In section .text, align 2, keep-with-next
    437          __weak void HAL_FLASH_EndOfOperationCallback(uint32_t ReturnValue)
    438          {
    439            /* Prevent unused argument(s) compilation warning */
    440            UNUSED(ReturnValue);
    441          
    442            /* NOTE : This function Should not be modified, when the callback is needed,
    443                      the HAL_FLASH_EndOfOperationCallback could be implemented in the user file
    444             */ 
    445          }
   \                     HAL_FLASH_EndOfOperationCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    446          
    447          /**
    448            * @brief  FLASH operation error interrupt callback
    449            * @param  ReturnValue: The value saved in this parameter depends on the ongoing procedure
    450            *                 - Pages Erase: Address of the page which returned an error
    451            *                 - Program: Address which was selected for data program
    452            * @retval none
    453            */

   \                                 In section .text, align 2, keep-with-next
    454          __weak void HAL_FLASH_OperationErrorCallback(uint32_t ReturnValue)
    455          {
    456            /* Prevent unused argument(s) compilation warning */
    457            UNUSED(ReturnValue);
    458          
    459            /* NOTE : This function Should not be modified, when the callback is needed,
    460                      the HAL_FLASH_OperationErrorCallback could be implemented in the user file
    461             */ 
    462          }
   \                     HAL_FLASH_OperationErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    463          
    464          /**
    465            * @}
    466            */
    467          
    468          /** @defgroup FLASH_Exported_Functions_Group2 Peripheral Control functions 
    469           *  @brief   management functions 
    470           *
    471          @verbatim   
    472           ===============================================================================
    473                                ##### Peripheral Control functions #####
    474           ===============================================================================  
    475              [..]
    476              This subsection provides a set of functions allowing to control the FLASH 
    477              memory operations.
    478          
    479          @endverbatim
    480            * @{
    481            */
    482          
    483          /**
    484            * @brief  Unlock the FLASH control register access
    485            * @retval HAL Status
    486            */

   \                                 In section .text, align 2, keep-with-next
    487          HAL_StatusTypeDef HAL_FLASH_Unlock(void)
    488          {
    489            if (HAL_IS_BIT_SET(FLASH->PECR, FLASH_PECR_PRGLOCK))
   \                     HAL_FLASH_Unlock: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40023c04
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0780             LSLS     R0,R0,#+30
   \   00000006   0xD511             BPL.N    ??HAL_FLASH_Unlock_0
    490            {
    491              /* Unlocking FLASH_PECR register access*/
    492              if(HAL_IS_BIT_SET(FLASH->PECR, FLASH_PECR_PELOCK))
   \   00000008   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40023c04
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x07C0             LSLS     R0,R0,#+31
   \   0000000E   0xD505             BPL.N    ??HAL_FLASH_Unlock_1
    493              {  
    494                WRITE_REG(FLASH->PEKEYR, FLASH_PEKEY1);
   \   00000010   0x....             LDR.N    R0,??DataTable10_3  ;; 0x89abcdef
   \   00000012   0x....             LDR.N    R1,??DataTable10_4  ;; 0x40023c0c
   \   00000014   0x6008             STR      R0,[R1, #+0]
    495                WRITE_REG(FLASH->PEKEYR, FLASH_PEKEY2);
   \   00000016   0x....             LDR.N    R0,??DataTable10_5  ;; 0x2030405
   \   00000018   0x....             LDR.N    R1,??DataTable10_4  ;; 0x40023c0c
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    496              }
    497              
    498              /* Unlocking the program memory access */
    499              WRITE_REG(FLASH->PRGKEYR, FLASH_PRGKEY1);
   \                     ??HAL_FLASH_Unlock_1: (+1)
   \   0000001C   0x....             LDR.N    R0,??DataTable10_6  ;; 0x8c9daebf
   \   0000001E   0x....             LDR.N    R1,??DataTable10_7  ;; 0x40023c10
   \   00000020   0x6008             STR      R0,[R1, #+0]
    500              WRITE_REG(FLASH->PRGKEYR, FLASH_PRGKEY2);  
   \   00000022   0x....             LDR.N    R0,??DataTable10_8  ;; 0x13141516
   \   00000024   0x....             LDR.N    R1,??DataTable10_7  ;; 0x40023c10
   \   00000026   0x6008             STR      R0,[R1, #+0]
    501            }
    502            else
    503            {
    504              return HAL_ERROR;
    505            }
    506          
    507            return HAL_OK; 
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xE000             B.N      ??HAL_FLASH_Unlock_2
   \                     ??HAL_FLASH_Unlock_0: (+1)
   \   0000002C   0x2001             MOVS     R0,#+1
   \                     ??HAL_FLASH_Unlock_2: (+1)
   \   0000002E   0x4770             BX       LR               ;; return
    508          }
    509          
    510          /**
    511            * @brief  Locks the FLASH control register access
    512            * @retval HAL Status
    513            */

   \                                 In section .text, align 2, keep-with-next
    514          HAL_StatusTypeDef HAL_FLASH_Lock(void)
    515          {
    516            /* Set the PRGLOCK Bit to lock the FLASH Registers access */
    517            SET_BIT(FLASH->PECR, FLASH_PECR_PRGLOCK);
   \                     HAL_FLASH_Lock: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40023c04
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000008   0x....             LDR.N    R1,??DataTable10_1  ;; 0x40023c04
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    518            
    519            return HAL_OK;  
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
    520          }
    521          
    522          /**
    523            * @brief  Unlock the FLASH Option Control Registers access.
    524            * @retval HAL Status
    525            */

   \                                 In section .text, align 2, keep-with-next
    526          HAL_StatusTypeDef HAL_FLASH_OB_Unlock(void)
    527          {
    528            if(HAL_IS_BIT_SET(FLASH->PECR, FLASH_PECR_OPTLOCK))
   \                     HAL_FLASH_OB_Unlock: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40023c04
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0740             LSLS     R0,R0,#+29
   \   00000006   0xD511             BPL.N    ??HAL_FLASH_OB_Unlock_0
    529            {
    530              /* Unlocking FLASH_PECR register access*/
    531              if(HAL_IS_BIT_SET(FLASH->PECR, FLASH_PECR_PELOCK))
   \   00000008   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40023c04
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x07C0             LSLS     R0,R0,#+31
   \   0000000E   0xD505             BPL.N    ??HAL_FLASH_OB_Unlock_1
    532              {  
    533                /* Unlocking FLASH_PECR register access*/
    534                WRITE_REG(FLASH->PEKEYR, FLASH_PEKEY1);
   \   00000010   0x....             LDR.N    R0,??DataTable10_3  ;; 0x89abcdef
   \   00000012   0x....             LDR.N    R1,??DataTable10_4  ;; 0x40023c0c
   \   00000014   0x6008             STR      R0,[R1, #+0]
    535                WRITE_REG(FLASH->PEKEYR, FLASH_PEKEY2);
   \   00000016   0x....             LDR.N    R0,??DataTable10_5  ;; 0x2030405
   \   00000018   0x....             LDR.N    R1,??DataTable10_4  ;; 0x40023c0c
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    536              }
    537          
    538              /* Unlocking the option bytes block access */
    539              WRITE_REG(FLASH->OPTKEYR, FLASH_OPTKEY1);
   \                     ??HAL_FLASH_OB_Unlock_1: (+1)
   \   0000001C   0x....             LDR.N    R0,??DataTable10_9  ;; 0xfbead9c8
   \   0000001E   0x....             LDR.N    R1,??DataTable10_10  ;; 0x40023c14
   \   00000020   0x6008             STR      R0,[R1, #+0]
    540              WRITE_REG(FLASH->OPTKEYR, FLASH_OPTKEY2);
   \   00000022   0x....             LDR.N    R0,??DataTable10_11  ;; 0x24252627
   \   00000024   0x....             LDR.N    R1,??DataTable10_10  ;; 0x40023c14
   \   00000026   0x6008             STR      R0,[R1, #+0]
    541            }
    542            else
    543            {
    544              return HAL_ERROR;
    545            }  
    546            
    547            return HAL_OK;  
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xE000             B.N      ??HAL_FLASH_OB_Unlock_2
   \                     ??HAL_FLASH_OB_Unlock_0: (+1)
   \   0000002C   0x2001             MOVS     R0,#+1
   \                     ??HAL_FLASH_OB_Unlock_2: (+1)
   \   0000002E   0x4770             BX       LR               ;; return
    548          }
    549          
    550          /**
    551            * @brief  Lock the FLASH Option Control Registers access.
    552            * @retval HAL Status 
    553            */

   \                                 In section .text, align 2, keep-with-next
    554          HAL_StatusTypeDef HAL_FLASH_OB_Lock(void)
    555          {
    556            /* Set the OPTLOCK Bit to lock the option bytes block access */
    557            SET_BIT(FLASH->PECR, FLASH_PECR_OPTLOCK);
   \                     HAL_FLASH_OB_Lock: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40023c04
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000008   0x....             LDR.N    R1,??DataTable10_1  ;; 0x40023c04
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    558            
    559            return HAL_OK;  
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
    560          }
    561            
    562          /**
    563            * @brief  Launch the option byte loading.
    564            * @note   This function will reset automatically the MCU.
    565            * @retval HAL Status
    566            */

   \                                 In section .text, align 2, keep-with-next
    567          HAL_StatusTypeDef HAL_FLASH_OB_Launch(void)
    568          {
   \                     HAL_FLASH_OB_Launch: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    569            /* Set the OBL_Launch bit to launch the option byte loading */
    570            SET_BIT(FLASH->PECR, FLASH_PECR_OBL_LAUNCH);
   \   00000002   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40023c04
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF450 0x2080      ORRS     R0,R0,#0x40000
   \   0000000A   0x....             LDR.N    R1,??DataTable10_1  ;; 0x40023c04
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    571            
    572            /* Wait for last operation to be completed */
    573            return(FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE));
   \   0000000E   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000012   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
    574          }
    575          
    576          /**
    577            * @}
    578            */  
    579          
    580          /** @defgroup FLASH_Exported_Functions_Group3 Peripheral errors functions 
    581           *  @brief    Peripheral errors functions 
    582           *
    583          @verbatim   
    584           ===============================================================================
    585                                ##### Peripheral Errors functions #####
    586           ===============================================================================  
    587              [..]
    588              This subsection permit to get in run-time errors of  the FLASH peripheral.
    589          
    590          @endverbatim
    591            * @{
    592            */
    593          
    594          /**
    595            * @brief  Get the specific FLASH error flag.
    596            * @retval FLASH_ErrorCode The returned value can be:
    597            *            @ref FLASH_Error_Codes
    598            */

   \                                 In section .text, align 2, keep-with-next
    599          uint32_t HAL_FLASH_GetError(void)
    600          {
    601             return pFlash.ErrorCode;
   \                     HAL_FLASH_GetError: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10
   \   00000002   0x6940             LDR      R0,[R0, #+20]
   \   00000004   0x4770             BX       LR               ;; return
    602          }
    603          
    604          /**
    605            * @}
    606            */
    607          
    608          /**
    609            * @}
    610            */
    611          
    612          /** @addtogroup FLASH_Private_Functions
    613           * @{
    614           */
    615          
    616          /**
    617            * @brief  Wait for a FLASH operation to complete.
    618            * @param  Timeout  maximum flash operation timeout
    619            * @retval HAL Status
    620            */

   \                                 In section .text, align 2, keep-with-next
    621          HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
    622          {
   \                     FLASH_WaitForLastOperation: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    623            /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
    624               Even if the FLASH operation fails, the BUSY flag will be reset and an error
    625               flag will be set */
    626               
    627            uint32_t tickstart = HAL_GetTick();
   \   00000004   0x.... 0x....      BL       HAL_GetTick
   \   00000008   0x0005             MOVS     R5,R0
    628               
    629            while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
   \                     ??FLASH_WaitForLastOperation_0: (+1)
   \   0000000A   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40023c18
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x07C0             LSLS     R0,R0,#+31
   \   00000010   0xD50B             BPL.N    ??FLASH_WaitForLastOperation_1
    630            { 
    631              if (Timeout != HAL_MAX_DELAY)
   \   00000012   0xF114 0x0F01      CMN      R4,#+1
   \   00000016   0xD0F8             BEQ.N    ??FLASH_WaitForLastOperation_0
    632              {
    633                if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout))
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD004             BEQ.N    ??FLASH_WaitForLastOperation_2
   \   0000001C   0x.... 0x....      BL       HAL_GetTick
   \   00000020   0x1B40             SUBS     R0,R0,R5
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD2F1             BCS.N    ??FLASH_WaitForLastOperation_0
    634                {
    635                  return HAL_TIMEOUT;
   \                     ??FLASH_WaitForLastOperation_2: (+1)
   \   00000026   0x2003             MOVS     R0,#+3
   \   00000028   0xE01B             B.N      ??FLASH_WaitForLastOperation_3
    636                }
    637              }
    638            }
    639            
    640            /* Check FLASH End of Operation flag  */
    641            if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
   \                     ??FLASH_WaitForLastOperation_1: (+1)
   \   0000002A   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40023c18
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x0780             LSLS     R0,R0,#+30
   \   00000030   0xD502             BPL.N    ??FLASH_WaitForLastOperation_4
    642            {
    643              /* Clear FLASH End of Operation pending bit */
    644              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0x....             LDR.N    R1,??DataTable10_2  ;; 0x40023c18
   \   00000036   0x6008             STR      R0,[R1, #+0]
    645            }
    646            
    647            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)  || 
    648               __HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR) || 
    649          #if defined(FLASH_SR_RDERR)
    650                __HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR) || 
    651          #endif /* FLASH_SR_RDERR */
    652          #if defined(FLASH_SR_OPTVERRUSR)
    653                __HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERRUSR) || 
    654          #endif /* FLASH_SR_OPTVERRUSR */
    655               __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR))
   \                     ??FLASH_WaitForLastOperation_4: (+1)
   \   00000038   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40023c18
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x05C0             LSLS     R0,R0,#+23
   \   0000003E   0xD40B             BMI.N    ??FLASH_WaitForLastOperation_5
   \   00000040   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40023c18
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x0500             LSLS     R0,R0,#+20
   \   00000046   0xD407             BMI.N    ??FLASH_WaitForLastOperation_5
   \   00000048   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40023c18
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x04C0             LSLS     R0,R0,#+19
   \   0000004E   0xD403             BMI.N    ??FLASH_WaitForLastOperation_5
   \   00000050   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40023c18
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x0580             LSLS     R0,R0,#+22
   \   00000056   0xD503             BPL.N    ??FLASH_WaitForLastOperation_6
    656            {
    657              /*Save the error code*/
    658              FLASH_SetErrorCode();
   \                     ??FLASH_WaitForLastOperation_5: (+1)
   \   00000058   0x.... 0x....      BL       FLASH_SetErrorCode
    659              return HAL_ERROR;
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0xE000             B.N      ??FLASH_WaitForLastOperation_3
    660            }
    661          
    662            /* There is no error flag set */
    663            return HAL_OK;
   \                     ??FLASH_WaitForLastOperation_6: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \                     ??FLASH_WaitForLastOperation_3: (+1)
   \   00000062   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    664          }
    665          
    666          
    667          /**
    668            * @brief  Set the specific FLASH error flag.
    669            * @retval None
    670            */

   \                                 In section .text, align 2, keep-with-next
    671          static void FLASH_SetErrorCode(void)
    672          {
    673            uint32_t flags = 0;
   \                     FLASH_SetErrorCode: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
    674            
    675            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR))
   \   00000002   0x....             LDR.N    R1,??DataTable10_2  ;; 0x40023c18
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x05C9             LSLS     R1,R1,#+23
   \   00000008   0xD507             BPL.N    ??FLASH_SetErrorCode_0
    676            {
    677              pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
   \   0000000A   0x....             LDR.N    R1,??DataTable10
   \   0000000C   0x6949             LDR      R1,[R1, #+20]
   \   0000000E   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   00000012   0x....             LDR.N    R2,??DataTable10
   \   00000014   0x6151             STR      R1,[R2, #+20]
    678              flags |= FLASH_FLAG_WRPERR;
   \   00000016   0xF450 0x7080      ORRS     R0,R0,#0x100
    679            }
    680            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR))
   \                     ??FLASH_SetErrorCode_0: (+1)
   \   0000001A   0x....             LDR.N    R1,??DataTable10_2  ;; 0x40023c18
   \   0000001C   0x6809             LDR      R1,[R1, #+0]
   \   0000001E   0x0589             LSLS     R1,R1,#+22
   \   00000020   0xD507             BPL.N    ??FLASH_SetErrorCode_1
    681            {
    682              pFlash.ErrorCode |= HAL_FLASH_ERROR_PGA;
   \   00000022   0x....             LDR.N    R1,??DataTable10
   \   00000024   0x6949             LDR      R1,[R1, #+20]
   \   00000026   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   0000002A   0x....             LDR.N    R2,??DataTable10
   \   0000002C   0x6151             STR      R1,[R2, #+20]
    683              flags |= FLASH_FLAG_PGAERR;
   \   0000002E   0xF450 0x7000      ORRS     R0,R0,#0x200
    684            }
    685            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR))
   \                     ??FLASH_SetErrorCode_1: (+1)
   \   00000032   0x....             LDR.N    R1,??DataTable10_2  ;; 0x40023c18
   \   00000034   0x6809             LDR      R1,[R1, #+0]
   \   00000036   0x0509             LSLS     R1,R1,#+20
   \   00000038   0xD507             BPL.N    ??FLASH_SetErrorCode_2
    686            {
    687              pFlash.ErrorCode |= HAL_FLASH_ERROR_OPTV;
   \   0000003A   0x....             LDR.N    R1,??DataTable10
   \   0000003C   0x6949             LDR      R1,[R1, #+20]
   \   0000003E   0xF051 0x0104      ORRS     R1,R1,#0x4
   \   00000042   0x....             LDR.N    R2,??DataTable10
   \   00000044   0x6151             STR      R1,[R2, #+20]
    688              flags |= FLASH_FLAG_OPTVERR;
   \   00000046   0xF450 0x6000      ORRS     R0,R0,#0x800
    689            }
    690          
    691          #if defined(FLASH_SR_RDERR)
    692            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR))
    693            {
    694              pFlash.ErrorCode |= HAL_FLASH_ERROR_RD;
    695              flags |= FLASH_FLAG_RDERR;
    696            }
    697          #endif /* FLASH_SR_RDERR */
    698          #if defined(FLASH_SR_OPTVERRUSR)
    699            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERRUSR))
   \                     ??FLASH_SetErrorCode_2: (+1)
   \   0000004A   0x....             LDR.N    R1,??DataTable10_2  ;; 0x40023c18
   \   0000004C   0x6809             LDR      R1,[R1, #+0]
   \   0000004E   0x04C9             LSLS     R1,R1,#+19
   \   00000050   0xD507             BPL.N    ??FLASH_SetErrorCode_3
    700            {
    701              pFlash.ErrorCode |= HAL_FLASH_ERROR_OPTVUSR;
   \   00000052   0x....             LDR.N    R1,??DataTable10
   \   00000054   0x6949             LDR      R1,[R1, #+20]
   \   00000056   0xF051 0x0120      ORRS     R1,R1,#0x20
   \   0000005A   0x....             LDR.N    R2,??DataTable10
   \   0000005C   0x6151             STR      R1,[R2, #+20]
    702              flags |= FLASH_FLAG_OPTVERRUSR;
   \   0000005E   0xF450 0x5080      ORRS     R0,R0,#0x1000
    703            }
    704          #endif /* FLASH_SR_OPTVERRUSR */
    705          
    706            /* Clear FLASH error pending bits */
    707            __HAL_FLASH_CLEAR_FLAG(flags);
   \                     ??FLASH_SetErrorCode_3: (+1)
   \   00000062   0x....             LDR.N    R1,??DataTable10_2  ;; 0x40023c18
   \   00000064   0x6008             STR      R0,[R1, #+0]
    708          }  
   \   00000066   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     pFlash

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x40023C04         DC32     0x40023c04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x40023C18         DC32     0x40023c18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x89ABCDEF         DC32     0x89abcdef

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x40023C0C         DC32     0x40023c0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x02030405         DC32     0x2030405

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x8C9DAEBF         DC32     0x8c9daebf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x40023C10         DC32     0x40023c10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x13141516         DC32     0x13141516

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0xFBEAD9C8         DC32     0xfbead9c8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   0x40023C14         DC32     0x40023c14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \   00000000   0x24252627         DC32     0x24252627
    709          /**
    710            * @}
    711            */
    712          
    713          /**
    714            * @}
    715            */
    716          
    717          #endif /* HAL_FLASH_MODULE_ENABLED */
    718          
    719          /**
    720            * @}
    721            */
    722          
    723          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FLASH_SetErrorCode
      16   FLASH_WaitForLastOperation
        16   -> FLASH_SetErrorCode
        16   -> HAL_GetTick
       0   HAL_FLASH_EndOfOperationCallback
       0   HAL_FLASH_GetError
       8   HAL_FLASH_IRQHandler
         8   -> FLASH_PageErase
         8   -> FLASH_SetErrorCode
         8   -> HAL_FLASH_EndOfOperationCallback
         8   -> HAL_FLASH_OperationErrorCallback
       0   HAL_FLASH_Lock
       8   HAL_FLASH_OB_Launch
         8   -> FLASH_WaitForLastOperation
       0   HAL_FLASH_OB_Lock
       0   HAL_FLASH_OB_Unlock
       0   HAL_FLASH_OperationErrorCallback
      16   HAL_FLASH_Program
        16   -> FLASH_WaitForLastOperation
       8   HAL_FLASH_Program_IT
       0   HAL_FLASH_Unlock


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
     104  FLASH_SetErrorCode
     100  FLASH_WaitForLastOperation
       2  HAL_FLASH_EndOfOperationCallback
       6  HAL_FLASH_GetError
     272  HAL_FLASH_IRQHandler
      16  HAL_FLASH_Lock
      24  HAL_FLASH_OB_Launch
      16  HAL_FLASH_OB_Lock
      48  HAL_FLASH_OB_Unlock
       2  HAL_FLASH_OperationErrorCallback
      70  HAL_FLASH_Program
      64  HAL_FLASH_Program_IT
      48  HAL_FLASH_Unlock
      24  pFlash

 
  24 bytes in section .bss
 820 bytes in section .text
 
 820 bytes of CODE memory
  24 bytes of DATA memory

Errors: none
Warnings: none
