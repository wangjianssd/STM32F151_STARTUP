###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       21/Sep/2016  16:57:25
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\01work\proj\地磁\Code\Drivers\Core\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_rcc_ex.c
#    Command line =  
#        D:\01work\proj\地磁\Code\Drivers\Core\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_rcc_ex.c
#        -D USE_HAL_DRIVER -D STM32L151xD -lC
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5\Debug\List -lA
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5\Debug\List -o
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5\Debug\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Apps/Config\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers\Inc\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers\Core\CMSIS\RTOS\Template\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/STM32L1xx_HAL_Driver/Config\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Middlewares/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Middlewares/FreeRTOS/Source/include\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/CMSIS/Include\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/RTT\
#        -I D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers\
#        -I D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../BSP/Inc/\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/CMSIS/Device/ST/STM32L1xx/Include\
#        -Ol
#    List file    =  
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5\Debug\List\stm32l1xx_hal_rcc_ex.lst
#    Object file  =  
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5\Debug\Obj\stm32l1xx_hal_rcc_ex.o
#
###############################################################################

D:\01work\proj\地磁\Code\Drivers\Core\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_rcc_ex.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_hal_rcc_ex.c
      4            * @author  MCD Application Team
      5            * @version V1.2.0
      6            * @date    01-July-2016
      7            * @brief   Extended RCC HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities RCC extension peripheral:
     10            *           + Extended Peripheral Control functions
     11            *
     12            ******************************************************************************
     13            * @attention
     14            *
     15            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
     16            *
     17            * Redistribution and use in source and binary forms, with or without modification,
     18            * are permitted provided that the following conditions are met:
     19            *   1. Redistributions of source code must retain the above copyright notice,
     20            *      this list of conditions and the following disclaimer.
     21            *   2. Redistributions in binary form must reproduce the above copyright notice,
     22            *      this list of conditions and the following disclaimer in the documentation
     23            *      and/or other materials provided with the distribution.
     24            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     25            *      may be used to endorse or promote products derived from this software
     26            *      without specific prior written permission.
     27            *
     28            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     29            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     30            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     31            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     32            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     33            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     34            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     35            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     36            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     37            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     38            *
     39            ******************************************************************************  
     40            */ 
     41          
     42          /* Includes ------------------------------------------------------------------*/
     43          #include "stm32l1xx_hal.h"
     44          
     45          /** @addtogroup STM32L1xx_HAL_Driver
     46            * @{
     47            */
     48          
     49          #ifdef HAL_RCC_MODULE_ENABLED
     50          
     51          /** @defgroup RCCEx RCCEx
     52            * @brief RCC Extension HAL module driver
     53            * @{
     54            */
     55          
     56          /* Private typedef -----------------------------------------------------------*/
     57          /* Private define ------------------------------------------------------------*/
     58          /** @defgroup RCCEx_Private_Constants RCCEx Private Constants
     59            * @{
     60            */
     61          /**
     62            * @}
     63            */
     64            
     65          /* Private macro -------------------------------------------------------------*/
     66          /** @defgroup RCCEx_Private_Macros RCCEx Private Macros
     67            * @{
     68            */
     69          /**
     70            * @}
     71            */
     72          
     73          /* Private variables ---------------------------------------------------------*/
     74          /* Private function prototypes -----------------------------------------------*/
     75          /* Private functions ---------------------------------------------------------*/
     76          
     77          /** @defgroup RCCEx_Exported_Functions RCCEx Exported Functions
     78            * @{
     79            */
     80          
     81          /** @defgroup RCCEx_Exported_Functions_Group1 Extended Peripheral Control functions 
     82           *  @brief  Extended Peripheral Control functions  
     83           *
     84          @verbatim   
     85           ===============================================================================
     86                          ##### Extended Peripheral Control functions  #####
     87           ===============================================================================  
     88              [..]
     89              This subsection provides a set of functions allowing to control the RCC Clocks 
     90              frequencies.
     91              [..] 
     92              (@) Important note: Care must be taken when HAL_RCCEx_PeriphCLKConfig() is used to
     93                  select the RTC clock source; in this case the Backup domain will be reset in  
     94                  order to modify the RTC Clock source, as consequence RTC registers (including 
     95                  the backup registers) are set to their reset values.
     96                
     97          @endverbatim
     98            * @{
     99            */
    100          
    101          /**
    102            * @brief  Initializes the RCC extended peripherals clocks according to the specified
    103            *         parameters in the RCC_PeriphCLKInitTypeDef.
    104            * @param  PeriphClkInit pointer to an RCC_PeriphCLKInitTypeDef structure that
    105            *         contains the configuration information for the Extended Peripherals clocks(RTC/LCD clock).
    106            * @retval HAL status
    107            * @note   If HAL_ERROR returned, first switch-OFF HSE clock oscillator with @ref HAL_RCC_OscConfig()
    108            *         to possibly update HSE divider.
    109            */

   \                                 In section .text, align 2, keep-with-next
    110          HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
    111          {
   \                     HAL_RCCEx_PeriphCLKConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    112            uint32_t tickstart = 0U;
   \   00000006   0x2600             MOVS     R6,#+0
    113            uint32_t temp_reg = 0U;
   \   00000008   0x2000             MOVS     R0,#+0
    114            
    115            /* Check the parameters */
    116            assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
    117            
    118            /*------------------------------- RTC/LCD Configuration ------------------------*/ 
    119            if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC) 
    120          #if defined(LCD)
    121             || (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LCD) == RCC_PERIPHCLK_LCD)
    122          #endif /* LCD */
    123               )
   \   0000000A   0x7820             LDRB     R0,[R4, #+0]
   \   0000000C   0x07C0             LSLS     R0,R0,#+31
   \   0000000E   0xF140 0x80A3      BPL.W    ??HAL_RCCEx_PeriphCLKConfig_0
    124            {
    125              /* check for RTC Parameters used to output RTCCLK */
    126              if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
   \   00000012   0x7820             LDRB     R0,[R4, #+0]
   \   00000014   0x07C0             LSLS     R0,R0,#+31
    127              {
    128                assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
    129              }
    130          
    131          #if defined(LCD)
    132              if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LCD) == RCC_PERIPHCLK_LCD)
    133              {
    134                assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->LCDClockSelection));
    135              }
    136          #endif /* LCD */
    137          
    138              FlagStatus       pwrclkchanged = RESET;
   \                     ??HAL_RCCEx_PeriphCLKConfig_1: (+1)
   \   00000016   0x2500             MOVS     R5,#+0
    139          
    140              /* As soon as function is called to change RTC clock source, activation of the 
    141                 power domain is done. */
    142              /* Requires to enable write access to Backup Domain of necessary */
    143              if(__HAL_RCC_PWR_IS_CLK_DISABLED())
   \   00000018   0x....             LDR.N    R0,??DataTable6  ;; 0x40023824
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x00C0             LSLS     R0,R0,#+3
   \   0000001E   0xD40C             BMI.N    ??HAL_RCCEx_PeriphCLKConfig_2
    144              {
    145                __HAL_RCC_PWR_CLK_ENABLE();
   \   00000020   0x....             LDR.N    R0,??DataTable6  ;; 0x40023824
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   00000028   0x....             LDR.N    R1,??DataTable6  ;; 0x40023824
   \   0000002A   0x6008             STR      R0,[R1, #+0]
   \   0000002C   0x....             LDR.N    R0,??DataTable6  ;; 0x40023824
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xF010 0x5080      ANDS     R0,R0,#0x10000000
   \   00000034   0x9000             STR      R0,[SP, #+0]
   \   00000036   0x9800             LDR      R0,[SP, #+0]
    146                pwrclkchanged = SET;
   \   00000038   0x2501             MOVS     R5,#+1
    147              }
    148              
    149              if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
   \                     ??HAL_RCCEx_PeriphCLKConfig_2: (+1)
   \   0000003A   0x....             LDR.N    R0,??DataTable6_1  ;; 0x40007000
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x05C0             LSLS     R0,R0,#+23
   \   00000040   0xD413             BMI.N    ??HAL_RCCEx_PeriphCLKConfig_3
    150              {
    151                /* Enable write access to Backup domain */
    152                SET_BIT(PWR->CR, PWR_CR_DBP);
   \   00000042   0x....             LDR.N    R0,??DataTable6_1  ;; 0x40007000
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000004A   0x....             LDR.N    R1,??DataTable6_1  ;; 0x40007000
   \   0000004C   0x6008             STR      R0,[R1, #+0]
    153                
    154                /* Wait for Backup domain Write protection disable */
    155                tickstart = HAL_GetTick();
   \   0000004E   0x.... 0x....      BL       HAL_GetTick
   \   00000052   0x0006             MOVS     R6,R0
    156          
    157                while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
   \                     ??HAL_RCCEx_PeriphCLKConfig_4: (+1)
   \   00000054   0x....             LDR.N    R0,??DataTable6_1  ;; 0x40007000
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x05C0             LSLS     R0,R0,#+23
   \   0000005A   0xD406             BMI.N    ??HAL_RCCEx_PeriphCLKConfig_3
    158                {
    159                  if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
   \   0000005C   0x.... 0x....      BL       HAL_GetTick
   \   00000060   0x1B80             SUBS     R0,R0,R6
   \   00000062   0x2865             CMP      R0,#+101
   \   00000064   0xD3F6             BCC.N    ??HAL_RCCEx_PeriphCLKConfig_4
    160                  {
    161                    return HAL_TIMEOUT;
   \   00000066   0x2003             MOVS     R0,#+3
   \   00000068   0xE077             B.N      ??HAL_RCCEx_PeriphCLKConfig_5
    162                  }
    163                }
    164              }
    165          
    166              /* Check if user wants to change HSE RTC prescaler whereas HSE is enabled */ 
    167              temp_reg = (RCC->CR & RCC_CR_RTCPRE);
   \                     ??HAL_RCCEx_PeriphCLKConfig_3: (+1)
   \   0000006A   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40023800
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0xF010 0x40C0      ANDS     R0,R0,#0x60000000
    168              if ((temp_reg != (PeriphClkInit->RTCClockSelection & RCC_CR_RTCPRE))
    169          #if defined (LCD)
    170               || (temp_reg != (PeriphClkInit->LCDClockSelection & RCC_CR_RTCPRE))
    171          #endif /* LCD */
    172                 )
   \   00000072   0x6861             LDR      R1,[R4, #+4]
   \   00000074   0xF011 0x41C0      ANDS     R1,R1,#0x60000000
   \   00000078   0x4288             CMP      R0,R1
   \   0000007A   0xD00B             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_6
    173              { /* Check HSE State */
    174                if (((PeriphClkInit->RTCClockSelection & RCC_CSR_RTCSEL) == RCC_CSR_RTCSEL_HSE) && HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
   \   0000007C   0x6860             LDR      R0,[R4, #+4]
   \   0000007E   0xF410 0x3040      ANDS     R0,R0,#0x30000
   \   00000082   0xF5B0 0x3F40      CMP      R0,#+196608
   \   00000086   0xD105             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_6
   \   00000088   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40023800
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0x0380             LSLS     R0,R0,#+14
   \   0000008E   0xD501             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_6
    175                {
    176                  /* To update HSE divider, first switch-OFF HSE clock oscillator*/
    177                  return HAL_ERROR; 
   \   00000090   0x2001             MOVS     R0,#+1
   \   00000092   0xE062             B.N      ??HAL_RCCEx_PeriphCLKConfig_5
    178                }
    179              }
    180              
    181              /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */ 
    182              temp_reg = (RCC->CSR & RCC_CSR_RTCSEL);
   \                     ??HAL_RCCEx_PeriphCLKConfig_6: (+1)
   \   00000094   0x....             LDR.N    R0,??DataTable6_3  ;; 0x40023834
   \   00000096   0x6800             LDR      R0,[R0, #+0]
   \   00000098   0xF410 0x3040      ANDS     R0,R0,#0x30000
    183              
    184              if((temp_reg != 0x00000000U) && (((temp_reg != (PeriphClkInit->RTCClockSelection & RCC_CSR_RTCSEL)) \
    185                && (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC))
    186          #if defined(LCD)
    187                || ((temp_reg != (PeriphClkInit->LCDClockSelection & RCC_CSR_RTCSEL)) \
    188                 && (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LCD) == RCC_PERIPHCLK_LCD))
    189          #endif /* LCD */
    190               ))
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD03A             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_7
   \   000000A0   0x6861             LDR      R1,[R4, #+4]
   \   000000A2   0xF411 0x3140      ANDS     R1,R1,#0x30000
   \   000000A6   0x4288             CMP      R0,R1
   \   000000A8   0xD035             BEQ.N    ??HAL_RCCEx_PeriphCLKConfig_7
   \   000000AA   0x7820             LDRB     R0,[R4, #+0]
   \   000000AC   0x07C0             LSLS     R0,R0,#+31
   \   000000AE   0xD532             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_7
    191              {
    192                /* Store the content of CSR register before the reset of Backup Domain */
    193                temp_reg = (RCC->CSR & ~(RCC_CSR_RTCSEL));
   \   000000B0   0x....             LDR.N    R0,??DataTable6_3  ;; 0x40023834
   \   000000B2   0x6800             LDR      R0,[R0, #+0]
   \   000000B4   0xF430 0x3040      BICS     R0,R0,#0x30000
    194                
    195                /* RTC Clock selection can be changed only if the Backup Domain is reset */
    196                __HAL_RCC_BACKUPRESET_FORCE();
   \   000000B8   0x2101             MOVS     R1,#+1
   \   000000BA   0xF44F 0x7280      MOV      R2,#+256
   \   000000BE   0xFAB2 0xF282      CLZ      R2,R2
   \   000000C2   0x....             LDR.N    R3,??DataTable6_4  ;; 0x42470680
   \   000000C4   0xF843 0x1022      STR      R1,[R3, R2, LSL #+2]
    197                __HAL_RCC_BACKUPRESET_RELEASE();
   \   000000C8   0x2100             MOVS     R1,#+0
   \   000000CA   0xF44F 0x7280      MOV      R2,#+256
   \   000000CE   0xFAB2 0xF282      CLZ      R2,R2
   \   000000D2   0x....             LDR.N    R3,??DataTable6_4  ;; 0x42470680
   \   000000D4   0xF843 0x1022      STR      R1,[R3, R2, LSL #+2]
    198                
    199                /* Restore the Content of CSR register */
    200                RCC->CSR = temp_reg;
   \   000000D8   0x....             LDR.N    R1,??DataTable6_3  ;; 0x40023834
   \   000000DA   0x6008             STR      R0,[R1, #+0]
    201                
    202                 /* Wait for LSERDY if LSE was enabled */
    203                if (HAL_IS_BIT_SET(temp_reg, RCC_CSR_LSEON))
   \   000000DC   0x05C0             LSLS     R0,R0,#+23
   \   000000DE   0xD51A             BPL.N    ??HAL_RCCEx_PeriphCLKConfig_7
    204                {
    205                  /* Get Start Tick */
    206                  tickstart = HAL_GetTick();
   \   000000E0   0x.... 0x....      BL       HAL_GetTick
   \   000000E4   0x0006             MOVS     R6,R0
    207                  
    208                  /* Wait till LSE is ready */  
    209                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
   \                     ??HAL_RCCEx_PeriphCLKConfig_8: (+1)
   \   000000E6   0xF45F 0x0080      MOVS     R0,#+4194304
   \   000000EA   0xFAB0 0xF080      CLZ      R0,R0
   \   000000EE   0x....             LDR.N    R0,??DataTable6_3  ;; 0x40023834
   \   000000F0   0x6800             LDR      R0,[R0, #+0]
   \   000000F2   0xF45F 0x0180      MOVS     R1,#+4194304
   \   000000F6   0xFAB1 0xF181      CLZ      R1,R1
   \   000000FA   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000000FE   0x40C8             LSRS     R0,R0,R1
   \   00000100   0x07C0             LSLS     R0,R0,#+31
   \   00000102   0xD408             BMI.N    ??HAL_RCCEx_PeriphCLKConfig_7
    210                  {
    211                    if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
   \   00000104   0x.... 0x....      BL       HAL_GetTick
   \   00000108   0x1B80             SUBS     R0,R0,R6
   \   0000010A   0xF241 0x3189      MOVW     R1,#+5001
   \   0000010E   0x4288             CMP      R0,R1
   \   00000110   0xD3E9             BCC.N    ??HAL_RCCEx_PeriphCLKConfig_8
    212                    {
    213                      return HAL_TIMEOUT;
   \   00000112   0x2003             MOVS     R0,#+3
   \   00000114   0xE021             B.N      ??HAL_RCCEx_PeriphCLKConfig_5
    214                    }
    215                  }
    216                }
    217              }
    218              __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
   \                     ??HAL_RCCEx_PeriphCLKConfig_7: (+1)
   \   00000116   0x6860             LDR      R0,[R4, #+4]
   \   00000118   0xF410 0x3040      ANDS     R0,R0,#0x30000
   \   0000011C   0xF5B0 0x3F40      CMP      R0,#+196608
   \   00000120   0xD109             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_9
   \   00000122   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40023800
   \   00000124   0x6800             LDR      R0,[R0, #+0]
   \   00000126   0xF030 0x40C0      BICS     R0,R0,#0x60000000
   \   0000012A   0x6861             LDR      R1,[R4, #+4]
   \   0000012C   0xF011 0x41C0      ANDS     R1,R1,#0x60000000
   \   00000130   0x4308             ORRS     R0,R1,R0
   \   00000132   0x....             LDR.N    R1,??DataTable6_2  ;; 0x40023800
   \   00000134   0x6008             STR      R0,[R1, #+0]
   \                     ??HAL_RCCEx_PeriphCLKConfig_9: (+1)
   \   00000136   0x....             LDR.N    R0,??DataTable6_3  ;; 0x40023834
   \   00000138   0x6800             LDR      R0,[R0, #+0]
   \   0000013A   0x6861             LDR      R1,[R4, #+4]
   \   0000013C   0xF411 0x3140      ANDS     R1,R1,#0x30000
   \   00000140   0x4308             ORRS     R0,R1,R0
   \   00000142   0x....             LDR.N    R1,??DataTable6_3  ;; 0x40023834
   \   00000144   0x6008             STR      R0,[R1, #+0]
    219          
    220              /* Require to disable power clock if necessary */
    221              if(pwrclkchanged == SET)
   \   00000146   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000148   0x2D01             CMP      R5,#+1
   \   0000014A   0xD105             BNE.N    ??HAL_RCCEx_PeriphCLKConfig_0
    222              {
    223                __HAL_RCC_PWR_CLK_DISABLE();
   \   0000014C   0x....             LDR.N    R0,??DataTable6  ;; 0x40023824
   \   0000014E   0x6800             LDR      R0,[R0, #+0]
   \   00000150   0xF030 0x5080      BICS     R0,R0,#0x10000000
   \   00000154   0x....             LDR.N    R1,??DataTable6  ;; 0x40023824
   \   00000156   0x6008             STR      R0,[R1, #+0]
    224              }
    225            }
    226            
    227            return HAL_OK;
   \                     ??HAL_RCCEx_PeriphCLKConfig_0: (+1)
   \   00000158   0x2000             MOVS     R0,#+0
   \                     ??HAL_RCCEx_PeriphCLKConfig_5: (+1)
   \   0000015A   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    228          }
    229          
    230          /**
    231            * @brief  Get the PeriphClkInit according to the internal RCC configuration registers.
    232            * @param  PeriphClkInit pointer to an RCC_PeriphCLKInitTypeDef structure that 
    233            *         returns the configuration information for the Extended Peripherals clocks(RTC/LCD clocks).
    234            * @retval None
    235            */

   \                                 In section .text, align 2, keep-with-next
    236          void HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
    237          {
    238            uint32_t srcclk = 0;
   \                     HAL_RCCEx_GetPeriphCLKConfig: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    239            
    240            /* Set all possible values for the extended clock type parameter------------*/
    241            PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_RTC;
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x6001             STR      R1,[R0, #+0]
    242          #if defined(LCD)   
    243            PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_LCD;
    244          #endif /* LCD */
    245          
    246            /* Get the RTC/LCD configuration -----------------------------------------------*/
    247            srcclk = __HAL_RCC_GET_RTC_SOURCE();
   \   00000006   0x....             LDR.N    R1,??DataTable6_3  ;; 0x40023834
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0xF411 0x3140      ANDS     R1,R1,#0x30000
    248            if (srcclk != RCC_RTCCLKSOURCE_HSE_DIV2)
   \   0000000E   0xF5B1 0x3F40      CMP      R1,#+196608
   \   00000012   0xD001             BEQ.N    ??HAL_RCCEx_GetPeriphCLKConfig_0
    249            {
    250              /* Source clock is LSE or LSI*/
    251              PeriphClkInit->RTCClockSelection = srcclk;
   \   00000014   0x6041             STR      R1,[R0, #+4]
   \   00000016   0xE005             B.N      ??HAL_RCCEx_GetPeriphCLKConfig_1
    252            }
    253            else
    254            {
    255              /* Source clock is HSE. Need to get the prescaler value*/
    256              PeriphClkInit->RTCClockSelection = srcclk | (READ_BIT(RCC->CR, RCC_CR_RTCPRE));
   \                     ??HAL_RCCEx_GetPeriphCLKConfig_0: (+1)
   \   00000018   0x....             LDR.N    R2,??DataTable6_2  ;; 0x40023800
   \   0000001A   0x6812             LDR      R2,[R2, #+0]
   \   0000001C   0xF012 0x42C0      ANDS     R2,R2,#0x60000000
   \   00000020   0x4311             ORRS     R1,R2,R1
   \   00000022   0x6041             STR      R1,[R0, #+4]
    257            }
    258          #if defined(LCD)
    259            PeriphClkInit->LCDClockSelection = PeriphClkInit->RTCClockSelection;
    260          #endif /* LCD */
    261          }
   \                     ??HAL_RCCEx_GetPeriphCLKConfig_1: (+1)
   \   00000024   0x4770             BX       LR               ;; return
    262          
    263          /**
    264            * @brief  Return the peripheral clock frequency
    265            * @note   Return 0 if peripheral clock is unknown
    266            * @param  PeriphClk Peripheral clock identifier
    267            *         This parameter can be one of the following values:
    268            *            @arg @ref RCC_PERIPHCLK_RTC      RTC peripheral clock
    269            *            @arg @ref RCC_PERIPHCLK_LCD      LCD peripheral clock (*)
    270            * @note   (*) means that this peripheral is not present on all the devices
    271            * @retval Frequency in Hz (0: means that no available frequency for the peripheral)
    272            */

   \                                 In section .text, align 2, keep-with-next
    273          uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
    274          {
    275            uint32_t temp_reg = 0U, clkprediv = 0U, frequency = 0U;
   \                     HAL_RCCEx_GetPeriphCLKFreq: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x2100             MOVS     R1,#+0
    276            uint32_t srcclk = 0U;
   \   00000006   0x2200             MOVS     R2,#+0
    277          
    278            /* Check the parameters */
    279            assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));
    280            
    281            switch (PeriphClk)
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD133             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_0
    282            {
    283            case RCC_PERIPHCLK_RTC:
    284          #if defined(LCD)
    285            case RCC_PERIPHCLK_LCD:
    286          #endif /* LCD */
    287              {
    288                /* Get RCC CSR configuration ------------------------------------------------------*/
    289                temp_reg = RCC->CSR;
   \   0000000C   0x....             LDR.N    R0,??DataTable6_3  ;; 0x40023834
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
    290          
    291                /* Get the current RTC source */
    292                srcclk = __HAL_RCC_GET_RTC_SOURCE();
   \   00000010   0x....             LDR.N    R0,??DataTable6_3  ;; 0x40023834
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF410 0x3240      ANDS     R2,R0,#0x30000
    293          
    294                /* Check if LSE is ready if RTC clock selection is LSE */
    295                if ((srcclk == RCC_RTCCLKSOURCE_LSE) && (HAL_IS_BIT_SET(temp_reg, RCC_CSR_LSERDY)))
   \   00000018   0xF5B2 0x3F80      CMP      R2,#+65536
   \   0000001C   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_1
   \   0000001E   0x0588             LSLS     R0,R1,#+22
   \   00000020   0xD502             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_1
    296                {
    297                  frequency = LSE_VALUE;
   \   00000022   0xF44F 0x4100      MOV      R1,#+32768
   \   00000026   0xE024             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_2
    298                }
    299                /* Check if LSI is ready if RTC clock selection is LSI */
    300                else if ((srcclk == RCC_RTCCLKSOURCE_LSI) && (HAL_IS_BIT_SET(temp_reg, RCC_CSR_LSIRDY)))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_1: (+1)
   \   00000028   0xF5B2 0x3F00      CMP      R2,#+131072
   \   0000002C   0xD104             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_3
   \   0000002E   0x0788             LSLS     R0,R1,#+30
   \   00000030   0xD502             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_3
    301                {
    302                  frequency = LSI_VALUE;
   \   00000032   0xF249 0x0188      MOVW     R1,#+37000
   \   00000036   0xE01C             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_2
    303                }
    304                /* Check if HSE is ready and if RTC clock selection is HSE */
    305                else if ((srcclk == RCC_RTCCLKSOURCE_HSE_DIVX) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)))
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_3: (+1)
   \   00000038   0xF5B2 0x3F40      CMP      R2,#+196608
   \   0000003C   0xD118             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_4
   \   0000003E   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40023800
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x0380             LSLS     R0,R0,#+14
   \   00000044   0xD514             BPL.N    ??HAL_RCCEx_GetPeriphCLKFreq_4
    306                {
    307                  /* Get the current HSE clock divider */
    308                  clkprediv = __HAL_RCC_GET_RTC_HSE_PRESCALER();
   \   00000046   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40023800
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xF010 0x41C0      ANDS     R1,R0,#0x60000000
    309          
    310                  switch (clkprediv)
   \   0000004E   0xF1B1 0x5F00      CMP      R1,#+536870912
   \   00000052   0xD009             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_5
   \   00000054   0xF1B1 0x4F80      CMP      R1,#+1073741824
   \   00000058   0xD004             BEQ.N    ??HAL_RCCEx_GetPeriphCLKFreq_6
   \   0000005A   0xF1B1 0x4FC0      CMP      R1,#+1610612736
   \   0000005E   0xD105             BNE.N    ??HAL_RCCEx_GetPeriphCLKFreq_7
    311                  {
    312                    case RCC_RTC_HSE_DIV_16:  /* HSE DIV16 has been selected */
    313                    {
    314                      frequency = HSE_VALUE / 16U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_8: (+1)
   \   00000060   0x....             LDR.N    R1,??DataTable6_5  ;; 0x16e360
    315                      break;
   \   00000062   0xE006             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_2
    316                    }
    317                    case RCC_RTC_HSE_DIV_8:   /* HSE DIV8 has been selected  */
    318                    {
    319                      frequency = HSE_VALUE / 8U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_6: (+1)
   \   00000064   0x....             LDR.N    R1,??DataTable6_6  ;; 0x2dc6c0
    320                      break;
   \   00000066   0xE004             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_2
    321                    }
    322                    case RCC_RTC_HSE_DIV_4:   /* HSE DIV4 has been selected  */
    323                    {
    324                      frequency = HSE_VALUE / 4U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_5: (+1)
   \   00000068   0x....             LDR.N    R1,??DataTable6_7  ;; 0x5b8d80
    325                      break;
   \   0000006A   0xE002             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_2
    326                    }
    327                    default:                  /* HSE DIV2 has been selected  */
    328                    {
    329                      frequency = HSE_VALUE / 2U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_7: (+1)
   \   0000006C   0x....             LDR.N    R1,??DataTable6_8  ;; 0xb71b00
    330                      break;
   \   0000006E   0xE000             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_2
    331                    }
    332                  }
    333                }
    334                /* Clock not enabled for RTC */
    335                else
    336                {
    337                  frequency = 0U;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_4: (+1)
   \   00000070   0x2100             MOVS     R1,#+0
    338                }
    339                break;
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_2: (+1)
   \   00000072   0xE7FF             B.N      ??HAL_RCCEx_GetPeriphCLKFreq_9
    340              }
    341            default: 
    342              {
    343                break;
    344              }
    345            }
    346            return(frequency);
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_0: (+1)
   \                     ??HAL_RCCEx_GetPeriphCLKFreq_9: (+1)
   \   00000074   0x0008             MOVS     R0,R1
   \   00000076   0x4770             BX       LR               ;; return
    347          }
    348          
    349          #if defined(RCC_LSECSS_SUPPORT)
    350          /**
    351            * @brief  Enables the LSE Clock Security System.
    352            * @note   If a failure is detected on the external 32 kHz oscillator, the LSE clock is no longer supplied
    353            *         to the RTC but no hardware action is made to the registers.
    354            *         In Standby mode a wakeup is generated. In other modes an interrupt can be sent to wakeup
    355            *         the software (see Section 5.3.4: Clock interrupt register (RCC_CIR) on page 104).
    356            *         The software MUST then disable the LSECSSON bit, stop the defective 32 kHz oscillator
    357            *         (disabling LSEON), and can change the RTC clock source (no clock or LSI or HSE, with
    358            *         RTCSEL), or take any required action to secure the application.  
    359            * @note   LSE CSS available only for high density and medium+ devices
    360            * @retval None
    361            */

   \                                 In section .text, align 2, keep-with-next
    362          void HAL_RCCEx_EnableLSECSS(void)
    363          {
    364            *(__IO uint32_t *) CSR_LSECSSON_BB = (uint32_t)ENABLE;
   \                     HAL_RCCEx_EnableLSECSS: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0xF45F 0x1180      MOVS     R1,#+1048576
   \   00000006   0xFAB1 0xF181      CLZ      R1,R1
   \   0000000A   0x....             LDR.N    R2,??DataTable6_4  ;; 0x42470680
   \   0000000C   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
    365          }
   \   00000010   0x4770             BX       LR               ;; return
    366          
    367          /**
    368            * @brief  Disables the LSE Clock Security System.
    369            * @note   Once enabled this bit cannot be disabled, except after an LSE failure detection 
    370            *         (LSECSSD=1). In that case the software MUST disable the LSECSSON bit.
    371            *         Reset by power on reset and RTC software reset (RTCRST bit).
    372            * @note   LSE CSS available only for high density and medium+ devices
    373            * @retval None
    374            */

   \                                 In section .text, align 2, keep-with-next
    375          void HAL_RCCEx_DisableLSECSS(void)
    376          {
    377            /* Disable LSE CSS */
    378            *(__IO uint32_t *) CSR_LSECSSON_BB = (uint32_t)DISABLE;
   \                     HAL_RCCEx_DisableLSECSS: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0xF45F 0x1180      MOVS     R1,#+1048576
   \   00000006   0xFAB1 0xF181      CLZ      R1,R1
   \   0000000A   0x....             LDR.N    R2,??DataTable6_4  ;; 0x42470680
   \   0000000C   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
    379          
    380            /* Disable LSE CSS IT */
    381            __HAL_RCC_DISABLE_IT(RCC_IT_LSECSS);
   \   00000010   0x....             LDR.N    R0,??DataTable6_9  ;; 0x4002380d
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   00000018   0x....             LDR.N    R1,??DataTable6_9  ;; 0x4002380d
   \   0000001A   0x7008             STRB     R0,[R1, #+0]
    382          }
   \   0000001C   0x4770             BX       LR               ;; return
    383          
    384          /**
    385            * @brief  Enable the LSE Clock Security System IT & corresponding EXTI line.
    386            * @note   LSE Clock Security System IT is mapped on RTC EXTI line 19
    387            * @retval None
    388            */

   \                                 In section .text, align 2, keep-with-next
    389          void HAL_RCCEx_EnableLSECSS_IT(void)
    390          {
    391            /* Enable LSE CSS */
    392            *(__IO uint32_t *) CSR_LSECSSON_BB = (uint32_t)ENABLE;
   \                     HAL_RCCEx_EnableLSECSS_IT: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0xF45F 0x1180      MOVS     R1,#+1048576
   \   00000006   0xFAB1 0xF181      CLZ      R1,R1
   \   0000000A   0x....             LDR.N    R2,??DataTable6_4  ;; 0x42470680
   \   0000000C   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
    393          
    394            /* Enable LSE CSS IT */
    395            __HAL_RCC_ENABLE_IT(RCC_IT_LSECSS);
   \   00000010   0x....             LDR.N    R0,??DataTable6_9  ;; 0x4002380d
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000018   0x....             LDR.N    R1,??DataTable6_9  ;; 0x4002380d
   \   0000001A   0x7008             STRB     R0,[R1, #+0]
    396            
    397            /* Enable IT on EXTI Line 19 */
    398            __HAL_RCC_LSECSS_EXTI_ENABLE_IT();
   \   0000001C   0x....             LDR.N    R0,??DataTable6_10  ;; 0x40010400
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF450 0x2000      ORRS     R0,R0,#0x80000
   \   00000024   0x....             LDR.N    R1,??DataTable6_10  ;; 0x40010400
   \   00000026   0x6008             STR      R0,[R1, #+0]
    399            __HAL_RCC_LSECSS_EXTI_ENABLE_RISING_EDGE();
   \   00000028   0x....             LDR.N    R0,??DataTable6_11  ;; 0x40010408
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0xF450 0x2000      ORRS     R0,R0,#0x80000
   \   00000030   0x....             LDR.N    R1,??DataTable6_11  ;; 0x40010408
   \   00000032   0x6008             STR      R0,[R1, #+0]
    400          }
   \   00000034   0x4770             BX       LR               ;; return
    401          
    402          /**
    403            * @brief Handle the RCC LSE Clock Security System interrupt request.
    404            * @retval None
    405            */

   \                                 In section .text, align 2, keep-with-next
    406          void HAL_RCCEx_LSECSS_IRQHandler(void)
    407          {
   \                     HAL_RCCEx_LSECSS_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    408            /* Check RCC LSE CSSF flag  */
    409            if(__HAL_RCC_GET_IT(RCC_IT_LSECSS))
   \   00000002   0x....             LDR.N    R0,??DataTable6_12  ;; 0x4002380c
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x0640             LSLS     R0,R0,#+25
   \   00000008   0xD504             BPL.N    ??HAL_RCCEx_LSECSS_IRQHandler_0
    410            {
    411              /* RCC LSE Clock Security System interrupt user callback */
    412              HAL_RCCEx_LSECSS_Callback();
   \   0000000A   0x.... 0x....      BL       HAL_RCCEx_LSECSS_Callback
    413          
    414              /* Clear RCC LSE CSS pending bit */
    415              __HAL_RCC_CLEAR_IT(RCC_IT_LSECSS);
   \   0000000E   0x2040             MOVS     R0,#+64
   \   00000010   0x....             LDR.N    R1,??DataTable6_13  ;; 0x4002380e
   \   00000012   0x7008             STRB     R0,[R1, #+0]
    416            }
    417          }                                                                            
   \                     ??HAL_RCCEx_LSECSS_IRQHandler_0: (+1)
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    418          
    419          /**
    420            * @brief  RCCEx LSE Clock Security System interrupt callback.
    421            * @retval none
    422            */

   \                                 In section .text, align 2, keep-with-next
    423          __weak void HAL_RCCEx_LSECSS_Callback(void)
    424          {
    425            /* NOTE : This function should not be modified, when the callback is needed,
    426                      the @ref HAL_RCCEx_LSECSS_Callback should be implemented in the user file
    427             */
    428          }
   \                     HAL_RCCEx_LSECSS_Callback: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x40023824         DC32     0x40023824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x40007000         DC32     0x40007000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x40023800         DC32     0x40023800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x40023834         DC32     0x40023834

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x42470680         DC32     0x42470680

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x0016E360         DC32     0x16e360

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x002DC6C0         DC32     0x2dc6c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x005B8D80         DC32     0x5b8d80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x00B71B00         DC32     0xb71b00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \   00000000   0x4002380D         DC32     0x4002380d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \   00000000   0x40010400         DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_11:
   \   00000000   0x40010408         DC32     0x40010408

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_12:
   \   00000000   0x4002380C         DC32     0x4002380c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_13:
   \   00000000   0x4002380E         DC32     0x4002380e
    429          #endif /* RCC_LSECSS_SUPPORT */
    430            
    431          /**
    432            * @}
    433            */
    434          
    435          /**
    436            * @}
    437            */
    438          
    439          /**
    440            * @}
    441            */
    442          
    443          /**
    444            * @}
    445            */
    446          
    447          #endif /* HAL_RCC_MODULE_ENABLED */
    448          /**
    449            * @}
    450            */
    451          
    452          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_RCCEx_DisableLSECSS
       0   HAL_RCCEx_EnableLSECSS
       0   HAL_RCCEx_EnableLSECSS_IT
       0   HAL_RCCEx_GetPeriphCLKConfig
       0   HAL_RCCEx_GetPeriphCLKFreq
       0   HAL_RCCEx_LSECSS_Callback
       8   HAL_RCCEx_LSECSS_IRQHandler
         8   -> HAL_RCCEx_LSECSS_Callback
      24   HAL_RCCEx_PeriphCLKConfig
        24   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_12
       4  ??DataTable6_13
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
      30  HAL_RCCEx_DisableLSECSS
      18  HAL_RCCEx_EnableLSECSS
      54  HAL_RCCEx_EnableLSECSS_IT
      38  HAL_RCCEx_GetPeriphCLKConfig
     120  HAL_RCCEx_GetPeriphCLKFreq
       2  HAL_RCCEx_LSECSS_Callback
      22  HAL_RCCEx_LSECSS_IRQHandler
     348  HAL_RCCEx_PeriphCLKConfig

 
 688 bytes in section .text
 
 688 bytes of CODE memory

Errors: none
Warnings: none
