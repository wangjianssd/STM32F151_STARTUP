###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       21/Sep/2016  16:57:22
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  D:\01work\proj\地磁\Code\Drivers\Src\i2c.c
#    Command line =  
#        D:\01work\proj\地磁\Code\Drivers\Src\i2c.c -D USE_HAL_DRIVER -D
#        STM32L151xD -lC
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5\Debug\List -lA
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5\Debug\List -o
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5\Debug\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Apps/Config\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers\Inc\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers\Core\CMSIS\RTOS\Template\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/STM32L1xx_HAL_Driver/Config\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Middlewares/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Middlewares/FreeRTOS/Source/include\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/CMSIS/Include\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/RTT\
#        -I D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers\
#        -I D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../BSP/Inc/\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/CMSIS/Device/ST/STM32L1xx/Include\
#        -Ol
#    List file    =  
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5\Debug\List\i2c.lst
#    Object file  =  
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5\Debug\Obj\i2c.o
#
###############################################################################

D:\01work\proj\地磁\Code\Drivers\Src\i2c.c
      1          /**
      2           * @brief       : 
      3           *
      4           * @file        : i2c.c
      5           * @author      : wangjian
      6           *
      7           * Version      : v0.0.1
      8           * Date         : 2016/09/21
      9           * Change Logs  :
     10           *
     11           * Date          Version      Author        Notes
     12           * 2016/09/21    v0.0.1        wangjian    first version
     13           */
     14          
     15          /* Exported incluides --------------------------------------------------------*/
     16          #include "device.h"
     17          
     18          /* Private variables ---------------------------------------------------------*/

   \                                 In section .bss, align 4
     19          static I2C_HandleTypeDef I2cHander1;
   \                     I2cHander1:
   \   00000000                      DS8 84
     20          
     21          /* Exported functions --------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
     22          bool I2cInit(I2cHanderTypeDef hi2c)
     23          {
   \                     I2cInit: (+1)
   \   00000000   0xB507             PUSH     {R0-R2,LR}
     24          
     25           I2C_HandleTypeDef *hander;
     26          
     27            if (hi2c.i2c == DEVICE_I2C1)
   \   00000002   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD10C             BNE.N    ??I2cInit_0
     28              {
     29                  hander = &I2cHander1;
   \   0000000A   0x....             LDR.N    R0,??DataTable3
     30                  hander->Instance = I2C1;
   \   0000000C   0x....             LDR.N    R1,??DataTable3_1  ;; 0x40005400
   \   0000000E   0x6001             STR      R1,[R0, #+0]
     31              }
     32              else
     33              {
     34                  return false;
     35              }
     36             
     37              hander->Init.ClockSpeed = hi2c.clock;
   \   00000010   0x9901             LDR      R1,[SP, #+4]
   \   00000012   0x6041             STR      R1,[R0, #+4]
     38          
     39              if (hi2c.addr_mode == I2C_ADDRESS_MODE_7BIT)
   \   00000014   0xF89D 0x1008      LDRB     R1,[SP, #+8]
   \   00000018   0x2900             CMP      R1,#+0
   \   0000001A   0xD105             BNE.N    ??I2cInit_1
     40              {
     41                  hander->Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
   \   0000001C   0xF44F 0x4180      MOV      R1,#+16384
   \   00000020   0x6101             STR      R1,[R0, #+16]
   \   00000022   0xE004             B.N      ??I2cInit_2
     42              }
   \                     ??I2cInit_0: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xE015             B.N      ??I2cInit_3
     43              else
     44              {
     45                  hander->Init.AddressingMode = I2C_ADDRESSINGMODE_10BIT;
   \                     ??I2cInit_1: (+1)
   \   00000028   0xF44F 0x4140      MOV      R1,#+49152
   \   0000002C   0x6101             STR      R1,[R0, #+16]
     46              }
     47              
     48              hander->Init.DutyCycle = I2C_DUTYCYCLE_2;
   \                     ??I2cInit_2: (+1)
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x6081             STR      R1,[R0, #+8]
     49              hander->Init.OwnAddress1 = 0;
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x60C1             STR      R1,[R0, #+12]
     50              hander->Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x6141             STR      R1,[R0, #+20]
     51              hander->Init.OwnAddress2 = 0;
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0x6181             STR      R1,[R0, #+24]
     52              hander->Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0x61C1             STR      R1,[R0, #+28]
     53              hander->Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x6201             STR      R1,[R0, #+32]
     54                  
     55              if (HAL_I2C_Init(hander) != HAL_OK)
   \   00000046   0x.... 0x....      BL       HAL_I2C_Init
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD001             BEQ.N    ??I2cInit_4
     56              {
     57                  return false;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xE000             B.N      ??I2cInit_3
     58              }
     59              
     60            return true;
   \                     ??I2cInit_4: (+1)
   \   00000052   0x2001             MOVS     R0,#+1
   \                     ??I2cInit_3: (+1)
   \   00000054   0xBD0E             POP      {R1-R3,PC}       ;; return
     61          }
     62          

   \                                 In section .text, align 2, keep-with-next
     63          bool  I2cByteRead (I2cHanderTypeDef hi2c,  uint8_t addr, uint8_t reg, uint8_t* data)
     64          {
   \                     I2cByteRead: (+1)
   \   00000000   0xB577             PUSH     {R0-R2,R4-R6,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x001C             MOVS     R4,R3
     65              uint8_t count = 0;
   \   00000006   0x2500             MOVS     R5,#+0
     66             // HAL_StatusTypeDef temp;
     67              I2C_HandleTypeDef *hander;
     68          
     69              if (hi2c.i2c == DEVICE_I2C1 )
   \   00000008   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD114             BNE.N    ??I2cByteRead_0
     70              {
     71                  hander = &I2cHander1;
   \   00000010   0x....             LDR.N    R6,??DataTable3
     72              }
     73              else
     74              {
     75                  return false;
     76              }
     77            //  temp = HAL_I2C_Master_Transmit(hander, addr, &reg, 1, 500);
     78              while( HAL_I2C_Master_Transmit(hander, addr, &reg, 1, 500) != HAL_OK)
   \                     ??I2cByteRead_1: (+1)
   \   00000012   0xF44F 0x70FA      MOV      R0,#+500
   \   00000016   0x9000             STR      R0,[SP, #+0]
   \   00000018   0x2301             MOVS     R3,#+1
   \   0000001A   0xAA08             ADD      R2,SP,#+32
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x0021             MOVS     R1,R4
   \   00000020   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000022   0x0030             MOVS     R0,R6
   \   00000024   0x.... 0x....      BL       HAL_I2C_Master_Transmit
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD00E             BEQ.N    ??I2cByteRead_2
     79              {
     80                   if (HAL_I2C_GetError(hander) != HAL_I2C_ERROR_AF)
   \   0000002C   0x0030             MOVS     R0,R6
   \   0000002E   0x.... 0x....      BL       HAL_I2C_GetError
   \   00000032   0x2804             CMP      R0,#+4
   \   00000034   0xD003             BEQ.N    ??I2cByteRead_3
     81                  {
     82                    return false;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xE01D             B.N      ??I2cByteRead_4
     83                  }
   \                     ??I2cByteRead_0: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xE01B             B.N      ??I2cByteRead_4
     84                   
     85                   count++;
   \                     ??I2cByteRead_3: (+1)
   \   0000003E   0x1C6D             ADDS     R5,R5,#+1
     86                   
     87                   if (count > 3)
   \   00000040   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000042   0x2D04             CMP      R5,#+4
   \   00000044   0xDBE5             BLT.N    ??I2cByteRead_1
     88                   {
     89                      return false;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xE015             B.N      ??I2cByteRead_4
     90                   }
     91                   
     92                   //temp = HAL_I2C_Master_Transmit(hander, addr, &reg, 1, 500);
     93              }
     94             
     95              if(HAL_I2C_Master_Receive(hander,  (addr | 0x01), data, 1, 1000) != HAL_OK)
   \                     ??I2cByteRead_2: (+1)
   \   0000004A   0xF44F 0x707A      MOV      R0,#+1000
   \   0000004E   0x9000             STR      R0,[SP, #+0]
   \   00000050   0x2301             MOVS     R3,#+1
   \   00000052   0x9A09             LDR      R2,[SP, #+36]
   \   00000054   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000056   0xF054 0x0101      ORRS     R1,R4,#0x1
   \   0000005A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000005C   0x0030             MOVS     R0,R6
   \   0000005E   0x.... 0x....      BL       HAL_I2C_Master_Receive
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD006             BEQ.N    ??I2cByteRead_5
     96              {
     97                  if (HAL_I2C_GetError(hander) != HAL_I2C_ERROR_AF)
   \   00000066   0x0030             MOVS     R0,R6
   \   00000068   0x.... 0x....      BL       HAL_I2C_GetError
   \   0000006C   0x2804             CMP      R0,#+4
   \   0000006E   0xD001             BEQ.N    ??I2cByteRead_5
     98                          {
     99                            return false;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0xE000             B.N      ??I2cByteRead_4
    100                          }
    101              }
    102              return true;
   \                     ??I2cByteRead_5: (+1)
   \   00000074   0x2001             MOVS     R0,#+1
   \                     ??I2cByteRead_4: (+1)
   \   00000076   0xB004             ADD      SP,SP,#+16
   \   00000078   0xBD70             POP      {R4-R6,PC}       ;; return
    103          
    104          }
    105          

   \                                 In section .text, align 2, keep-with-next
    106          bool  I2cBytesRead (I2cHanderTypeDef hi2c,  uint8_t addr, uint8_t reg, uint8_t* data, uint16_t size)
    107          {
   \                     I2cBytesRead: (+1)
   \   00000000   0xB577             PUSH     {R0-R2,R4-R6,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x001C             MOVS     R4,R3
    108              uint8_t count = 0;
   \   00000006   0x2500             MOVS     R5,#+0
    109              
    110              I2C_HandleTypeDef *hander;
    111          
    112              if (hi2c.i2c == DEVICE_I2C1 )
   \   00000008   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD114             BNE.N    ??I2cBytesRead_0
    113              {
    114                  hander = &I2cHander1;
   \   00000010   0x....             LDR.N    R6,??DataTable3
    115              }
    116              else
    117              {
    118                  return false;
    119              }
    120          
    121              
    122              while(HAL_I2C_Master_Transmit(hander, addr, &reg, 1, 500) != HAL_OK)
   \                     ??I2cBytesRead_1: (+1)
   \   00000012   0xF44F 0x70FA      MOV      R0,#+500
   \   00000016   0x9000             STR      R0,[SP, #+0]
   \   00000018   0x2301             MOVS     R3,#+1
   \   0000001A   0xAA08             ADD      R2,SP,#+32
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x0021             MOVS     R1,R4
   \   00000020   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000022   0x0030             MOVS     R0,R6
   \   00000024   0x.... 0x....      BL       HAL_I2C_Master_Transmit
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD00E             BEQ.N    ??I2cBytesRead_2
    123              {
    124                   if (HAL_I2C_GetError(hander) != HAL_I2C_ERROR_AF)
   \   0000002C   0x0030             MOVS     R0,R6
   \   0000002E   0x.... 0x....      BL       HAL_I2C_GetError
   \   00000032   0x2804             CMP      R0,#+4
   \   00000034   0xD003             BEQ.N    ??I2cBytesRead_3
    125                  {
    126                    return false;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xE023             B.N      ??I2cBytesRead_4
    127                  }
   \                     ??I2cBytesRead_0: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xE021             B.N      ??I2cBytesRead_4
    128                   
    129                   count++;
   \                     ??I2cBytesRead_3: (+1)
   \   0000003E   0x1C6D             ADDS     R5,R5,#+1
    130                   
    131                   if (count > 3)
   \   00000040   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000042   0x2D04             CMP      R5,#+4
   \   00000044   0xDBE5             BLT.N    ??I2cBytesRead_1
    132                   {
    133                      return false;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xE01B             B.N      ??I2cBytesRead_4
    134                   }
    135              }
   \                     ??I2cBytesRead_2: (+1)
   \   0000004A   0x9B0A             LDR      R3,[SP, #+40]
    136             
    137             
    138              if(HAL_I2C_Master_Receive(hander,  (addr | 0x01), data, size, (size * 500) + 500) != HAL_OK)
   \   0000004C   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000004E   0xF44F 0x70FA      MOV      R0,#+500
   \   00000052   0xFB00 0xF003      MUL      R0,R0,R3
   \   00000056   0xF510 0x70FA      ADDS     R0,R0,#+500
   \   0000005A   0x9000             STR      R0,[SP, #+0]
   \   0000005C   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000005E   0x9A09             LDR      R2,[SP, #+36]
   \   00000060   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000062   0xF054 0x0101      ORRS     R1,R4,#0x1
   \   00000066   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000068   0x0030             MOVS     R0,R6
   \   0000006A   0x.... 0x....      BL       HAL_I2C_Master_Receive
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD006             BEQ.N    ??I2cBytesRead_5
    139              {
    140                  if (HAL_I2C_GetError(hander) != HAL_I2C_ERROR_AF)
   \   00000072   0x0030             MOVS     R0,R6
   \   00000074   0x.... 0x....      BL       HAL_I2C_GetError
   \   00000078   0x2804             CMP      R0,#+4
   \   0000007A   0xD001             BEQ.N    ??I2cBytesRead_5
    141                          {
    142                            return false;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0xE000             B.N      ??I2cBytesRead_4
    143                          }
    144              }
    145              return true;
   \                     ??I2cBytesRead_5: (+1)
   \   00000080   0x2001             MOVS     R0,#+1
   \                     ??I2cBytesRead_4: (+1)
   \   00000082   0xB004             ADD      SP,SP,#+16
   \   00000084   0xBD70             POP      {R4-R6,PC}       ;; return
    146          
    147          }
    148          

   \                                 In section .text, align 2, keep-with-next
    149          bool  I2cByteWrite (I2cHanderTypeDef hi2c , uint8_t addr, uint8_t reg, uint8_t  data)
    150          {
   \                     I2cByteWrite: (+1)
   \   00000000   0xB577             PUSH     {R0-R2,R4-R6,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x001C             MOVS     R4,R3
    151              uint8_t tx_data[2] = {reg, data};
   \   00000006   0x980A             LDR      R0,[SP, #+40]
   \   00000008   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \   0000000C   0x980B             LDR      R0,[SP, #+44]
   \   0000000E   0xF88D 0x0005      STRB     R0,[SP, #+5]
    152              
    153              uint8_t count = 0;
   \   00000012   0x2500             MOVS     R5,#+0
    154              
    155              I2C_HandleTypeDef *hander;
    156          
    157              if (hi2c.i2c == DEVICE_I2C1 )
   \   00000014   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD114             BNE.N    ??I2cByteWrite_0
    158              {
    159                  hander = &I2cHander1;
   \   0000001C   0x....             LDR.N    R6,??DataTable3
    160              }
    161              else
    162              {
    163                  return false;
    164              }
    165              
    166               while(HAL_I2C_Master_Transmit(hander, addr, (uint8_t*)tx_data, 2, 1000) != HAL_OK)
   \                     ??I2cByteWrite_1: (+1)
   \   0000001E   0xF44F 0x707A      MOV      R0,#+1000
   \   00000022   0x9000             STR      R0,[SP, #+0]
   \   00000024   0x2302             MOVS     R3,#+2
   \   00000026   0xAA01             ADD      R2,SP,#+4
   \   00000028   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002A   0x0021             MOVS     R1,R4
   \   0000002C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000002E   0x0030             MOVS     R0,R6
   \   00000030   0x.... 0x....      BL       HAL_I2C_Master_Transmit
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD00D             BEQ.N    ??I2cByteWrite_2
    167               {
    168                   if (HAL_I2C_GetError(hander) != HAL_I2C_ERROR_AF)
   \   00000038   0x0030             MOVS     R0,R6
   \   0000003A   0x.... 0x....      BL       HAL_I2C_GetError
   \   0000003E   0x2804             CMP      R0,#+4
   \   00000040   0xD003             BEQ.N    ??I2cByteWrite_3
    169                   {
    170                       return false;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xE007             B.N      ??I2cByteWrite_4
    171                   }
   \                     ??I2cByteWrite_0: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xE005             B.N      ??I2cByteWrite_4
    172              
    173                   if (count > 3)
   \                     ??I2cByteWrite_3: (+1)
   \   0000004A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004C   0x2D04             CMP      R5,#+4
   \   0000004E   0xDBE6             BLT.N    ??I2cByteWrite_1
    174                   {
    175                       return false;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xE000             B.N      ??I2cByteWrite_4
    176                   }
    177               }
    178               
    179               return true;
   \                     ??I2cByteWrite_2: (+1)
   \   00000054   0x2001             MOVS     R0,#+1
   \                     ??I2cByteWrite_4: (+1)
   \   00000056   0xB006             ADD      SP,SP,#+24
   \   00000058   0xBD70             POP      {R4-R6,PC}       ;; return
    180          
    181          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     I2cHander1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x40005400         DC32     0x40005400
    182          
    183          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   I2cByteRead
        32   -> HAL_I2C_GetError
        32   -> HAL_I2C_Master_Receive
        32   -> HAL_I2C_Master_Transmit
      40   I2cByteWrite
        40   -> HAL_I2C_GetError
        40   -> HAL_I2C_Master_Transmit
      32   I2cBytesRead
        32   -> HAL_I2C_GetError
        32   -> HAL_I2C_Master_Receive
        32   -> HAL_I2C_Master_Transmit
      16   I2cInit
        16   -> HAL_I2C_Init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
     122  I2cByteRead
      90  I2cByteWrite
     134  I2cBytesRead
      84  I2cHander1
      86  I2cInit

 
  84 bytes in section .bss
 440 bytes in section .text
 
 440 bytes of CODE memory
  84 bytes of DATA memory

Errors: none
Warnings: none
