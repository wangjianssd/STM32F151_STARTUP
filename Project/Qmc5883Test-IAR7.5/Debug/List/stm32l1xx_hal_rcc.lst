###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       21/Sep/2016  16:57:25
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\01work\proj\地磁\Code\Drivers\Core\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_rcc.c
#    Command line =  
#        D:\01work\proj\地磁\Code\Drivers\Core\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_rcc.c
#        -D USE_HAL_DRIVER -D STM32L151xD -lC
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5\Debug\List -lA
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5\Debug\List -o
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5\Debug\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Apps/Config\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers\Inc\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers\Core\CMSIS\RTOS\Template\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/STM32L1xx_HAL_Driver/Config\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Middlewares/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Middlewares/FreeRTOS/Source/include\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/CMSIS/Include\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/RTT\
#        -I D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers\
#        -I D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../BSP/Inc/\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/CMSIS/Device/ST/STM32L1xx/Include\
#        -Ol
#    List file    =  
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5\Debug\List\stm32l1xx_hal_rcc.lst
#    Object file  =  
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5\Debug\Obj\stm32l1xx_hal_rcc.o
#
###############################################################################

D:\01work\proj\地磁\Code\Drivers\Core\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_rcc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_hal_rcc.c
      4            * @author  MCD Application Team
      5            * @version V1.2.0
      6            * @date    01-July-2016
      7            * @brief   RCC HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Reset and Clock Control (RCC) peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + Peripheral Control functions
     12            *       
     13            @verbatim                
     14            ==============================================================================
     15                                ##### RCC specific features #####
     16            ==============================================================================
     17              [..]  
     18                After reset the device is running from multispeed internal oscillator clock 
     19                (MSI 2.097MHz) with Flash 0 wait state and Flash prefetch buffer is disabled, 
     20                and all peripherals are off except internal SRAM, Flash and JTAG.
     21                (+) There is no prescaler on High speed (AHB) and Low speed (APB) buses;
     22                    all peripherals mapped on these buses are running at MSI speed.
     23                (+) The clock for all peripherals is switched off, except the SRAM and FLASH.
     24                (+) All GPIOs are in input floating state, except the JTAG pins which
     25                    are assigned to be used for debug purpose.
     26              [..] Once the device started from reset, the user application has to:
     27                (+) Configure the clock source to be used to drive the System clock
     28                    (if the application needs higher frequency/performance)
     29                (+) Configure the System clock frequency and Flash settings  
     30                (+) Configure the AHB and APB buses prescalers
     31                (+) Enable the clock for the peripheral(s) to be used
     32                (+) Configure the clock source(s) for peripherals whose clocks are not
     33                    derived from the System clock (I2S, RTC, ADC, USB OTG FS/SDIO/RNG) 
     34                    (*) SDIO only for STM32L1xxxD devices
     35          
     36                                ##### RCC Limitations #####
     37            ==============================================================================
     38              [..]  
     39                A delay between an RCC peripheral clock enable and the effective peripheral 
     40                enabling should be taken into account in order to manage the peripheral read/write 
     41                from/to registers.
     42                (+) This delay depends on the peripheral mapping.
     43                  (++) AHB & APB peripherals, 1 dummy read is necessary
     44          
     45              [..]  
     46                Workarounds:
     47                (#) For AHB & APB peripherals, a dummy read to the peripheral register has been
     48                    inserted in each __HAL_RCC_PPP_CLK_ENABLE() macro.
     49          
     50            @endverbatim
     51            ******************************************************************************
     52            * @attention
     53            *
     54            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
     55            *
     56            * Redistribution and use in source and binary forms, with or without modification,
     57            * are permitted provided that the following conditions are met:
     58            *   1. Redistributions of source code must retain the above copyright notice,
     59            *      this list of conditions and the following disclaimer.
     60            *   2. Redistributions in binary form must reproduce the above copyright notice,
     61            *      this list of conditions and the following disclaimer in the documentation
     62            *      and/or other materials provided with the distribution.
     63            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     64            *      may be used to endorse or promote products derived from this software
     65            *      without specific prior written permission.
     66            *
     67            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     68            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     69            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     70            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     71            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     72            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     73            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     74            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     75            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     76            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     77            *
     78            ******************************************************************************  
     79          */
     80          
     81          /* Includes ------------------------------------------------------------------*/
     82          #include "stm32l1xx_hal.h"
     83          
     84          /** @addtogroup STM32L1xx_HAL_Driver
     85            * @{
     86            */
     87          
     88          /** @defgroup RCC RCC
     89          * @brief RCC HAL module driver
     90            * @{
     91            */
     92          
     93          #ifdef HAL_RCC_MODULE_ENABLED
     94          
     95          /* Private typedef -----------------------------------------------------------*/
     96          /* Private define ------------------------------------------------------------*/
     97          /** @defgroup RCC_Private_Constants RCC Private Constants
     98           * @{
     99           */
    100          /* Bits position in  in the CFGR register */
    101          #define RCC_CFGR_PLLMUL_BITNUMBER         POSITION_VAL(RCC_CFGR_PLLMUL)
    102          #define RCC_CFGR_PLLDIV_BITNUMBER         POSITION_VAL(RCC_CFGR_PLLDIV)
    103          #define RCC_CFGR_HPRE_BITNUMBER           POSITION_VAL(RCC_CFGR_HPRE)
    104          #define RCC_CFGR_PPRE1_BITNUMBER          POSITION_VAL(RCC_CFGR_PPRE1)
    105          #define RCC_CFGR_PPRE2_BITNUMBER          POSITION_VAL(RCC_CFGR_PPRE2)
    106          /* Bits position in  in the ICSCR register */
    107          #define RCC_ICSCR_MSIRANGE_BITNUMBER      POSITION_VAL(RCC_ICSCR_MSIRANGE)
    108          #define RCC_ICSCR_MSITRIM_BITNUMBER       POSITION_VAL(RCC_ICSCR_MSITRIM)
    109          /**
    110            * @}
    111            */
    112          /* Private macro -------------------------------------------------------------*/
    113          /** @defgroup RCC_Private_Macros RCC Private Macros
    114            * @{
    115            */
    116          
    117          #define MCO1_CLK_ENABLE()     __HAL_RCC_GPIOA_CLK_ENABLE()
    118          #define MCO1_GPIO_PORT        GPIOA
    119          #define MCO1_PIN              GPIO_PIN_8
    120          
    121          /**
    122            * @}
    123            */
    124          
    125          /* Private variables ---------------------------------------------------------*/
    126          /** @defgroup RCC_Private_Variables RCC Private Variables
    127            * @{
    128            */
    129          extern const uint8_t PLLMulTable[];          /* Defined in CMSIS (system_stm32l0xx.c)*/
    130          /**
    131            * @}
    132            */
    133          
    134          /* Private function prototypes -----------------------------------------------*/
    135          /** @defgroup RCC_Private_Functions RCC Private Functions
    136            * @{
    137            */
    138          static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t MSIrange);
    139          /**
    140            * @}
    141            */
    142          
    143          /* Exported functions ---------------------------------------------------------*/
    144          
    145          /** @defgroup RCC_Exported_Functions RCC Exported Functions
    146            * @{
    147            */
    148          
    149          /** @defgroup RCC_Exported_Functions_Group1 Initialization and de-initialization functions 
    150            *  @brief    Initialization and Configuration functions 
    151            *
    152            @verbatim    
    153            ===============================================================================
    154                     ##### Initialization and de-initialization functions #####
    155            ===============================================================================
    156              [..]
    157                This section provides functions allowing to configure the internal/external oscillators
    158                (MSI, HSE, HSI, LSE, LSI, PLL, CSS and MCO) and the System buses clocks (SYSCLK, AHB, APB1 
    159                and APB2).
    160          
    161              [..] Internal/external clock and PLL configuration
    162                (#) MSI (Multispeed internal), Seven frequency ranges are available: 65.536 kHz, 
    163                    131.072 kHz, 262.144 kHz, 524.288 kHz, 1.048 MHz, 2.097 MHz (default value) and 4.194 MHz.
    164          
    165                (#) HSI (high-speed internal), 16 MHz factory-trimmed RC used directly or through
    166                    the PLL as System clock source.
    167                (#) LSI (low-speed internal), ~37 KHz low consumption RC used as IWDG and/or RTC
    168                    clock source.
    169          
    170                (#) HSE (high-speed external), 1 to 24 MHz crystal oscillator used directly or
    171                    through the PLL as System clock source. Can be used also as RTC clock source.
    172          
    173                (#) LSE (low-speed external), 32 KHz oscillator used as RTC clock source.   
    174          
    175                (#) PLL (clocked by HSI or HSE), featuring different output clocks:
    176                  (++) The first output is used to generate the high speed system clock (up to 32 MHz)
    177                  (++) The second output is used to generate the clock for the USB OTG FS (48 MHz)
    178          
    179                (#) CSS (Clock security system), once enable using the macro __HAL_RCC_CSS_ENABLE()
    180                    and if a HSE clock failure occurs(HSE used directly or through PLL as System 
    181                    clock source), the System clocks automatically switched to MSI and an interrupt
    182                    is generated if enabled. The interrupt is linked to the Cortex-M3 NMI 
    183                    (Non-Maskable Interrupt) exception vector.   
    184          
    185                (#) MCO1 (microcontroller clock output), used to output SYSCLK, HSI, LSI, MSI, LSE, 
    186                    HSE or PLL clock (through a configurable prescaler) on PA8 pin.
    187          
    188              [..] System, AHB and APB buses clocks configuration
    189                (#) Several clock sources can be used to drive the System clock (SYSCLK): MSI, HSI,
    190                    HSE and PLL.
    191                    The AHB clock (HCLK) is derived from System clock through configurable
    192                    prescaler and used to clock the CPU, memory and peripherals mapped
    193                    on AHB bus (DMA, GPIO...). APB1 (PCLK1) and APB2 (PCLK2) clocks are derived
    194                    from AHB clock through configurable prescalers and used to clock
    195                    the peripherals mapped on these buses. You can use
    196                    "@ref HAL_RCC_GetSysClockFreq()" function to retrieve the frequencies of these clocks.
    197          
    198                -@- All the peripheral clocks are derived from the System clock (SYSCLK) except:
    199                    (+@) RTC: RTC clock can be derived either from the LSI, LSE or HSE clock
    200                        divided by 2 to 16. You have to use @ref __HAL_RCC_RTC_CONFIG() and @ref __HAL_RCC_RTC_ENABLE()
    201                        macros to configure this clock. 
    202                    (+@) LCD: LCD clock can be derived either from the LSI, LSE or HSE clock
    203                        divided by 2 to 16. You have to use @ref __HAL_RCC_LCD_CONFIG()
    204                        macros to configure this clock. 
    205                    (+@) USB OTG FS: USB OTG FS require a frequency equal to 48 MHz
    206                        to work correctly. This clock is derived of the main PLL through PLL Multiplier.
    207          
    208                    (+@) IWDG clock which is always the LSI clock.
    209          
    210                (#) The maximum frequency of the SYSCLK and HCLK is 32 MHz, PCLK2 32 MHz 
    211                    and PCLK1 32 MHz. Depending on the device voltage range, the maximum 
    212                    frequency should be adapted accordingly.
    213            @endverbatim
    214            * @{
    215            */
    216            
    217          /*
    218            Additional consideration on the HCLK based on Latency settings:
    219            +----------------------------------------------------------------------+     
    220            | Latency       |                HCLK clock frequency (MHz)            |
    221            |               |------------------------------------------------------|     
    222            |               | voltage range 1  | voltage range 2 | voltage range 3 |
    223            |               |      1.8 V       |     1.5 V       |      1.2 V      |
    224            |---------------|------------------|-----------------|-----------------|              
    225            |0WS(1CPU cycle)| 0 < HCLK <= 16   | 0 < HCLK <= 8   | 0 < HCLK <= 2   |
    226            |---------------|------------------|-----------------|-----------------| 
    227            |1WS(2CPU cycle)| 16 < HCLK <= 32  | 8 < HCLK <= 16  | 2 < HCLK <= 4   | 
    228            +----------------------------------------------------------------------+     
    229          
    230            The following table gives the different clock source frequencies depending on the product
    231            voltage range:
    232            +------------------------------------------------------------------------------------------+     
    233            | Product voltage |                    Clock frequency                                     |
    234            |                 |------------------|-----------------------------|-----------------------|              
    235            |      range      |   MSI   |   HSI  |              HSE            |          PLL          |
    236            |-----------------|---------|--------|-----------------------------|-----------------------|              
    237            | Range 1 (1.8 V) | 4.2 MHz | 16 MHz | HSE 32 MHz (external clock) |         32 MHz        |
    238            |                 |         |        |      or 24 MHz (crystal)    | (PLLVCO max = 96 MHz) |
    239            |-----------------|---------|--------|-----------------------------|-----------------------|              
    240            | Range 2 (1.5 V) | 4.2 MHz | 16 MHz |         16 MHz              |         16 MHz        |
    241            |                 |         |        |                             | (PLLVCO max = 48 MHz) |
    242            |-----------------|---------|--------|-----------------------------|-----------------------|              
    243            | Range 3 (1.2 V) | 4.2 MHz |   NA   |         8 MHz               |           4 MHz       |
    244            |                 |         |        |                             | (PLLVCO max = 24 MHz) |
    245            +------------------------------------------------------------------------------------------+     
    246            */
    247          
    248          /**
    249            * @brief  Resets the RCC clock configuration to the default reset state.
    250            * @note   The default reset state of the clock configuration is given below:
    251            *            - MSI ON and used as system clock source
    252            *            - HSI, HSE and PLL  OFF
    253            *            - AHB, APB1 and APB2 prescaler set to 1.
    254            *            - CSS and MCO1 OFF
    255            *            - All interrupts disabled
    256            * @note   This function does not modify the configuration of the
    257            *            - Peripheral clocks
    258            *            - LSI, LSE and RTC clocks
    259            * @retval None
    260            */

   \                                 In section .text, align 2, keep-with-next
    261          void HAL_RCC_DeInit(void)
    262          {
    263            /* Set MSION bit */
    264            SET_BIT(RCC->CR, RCC_CR_MSION);
   \                     HAL_RCC_DeInit: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x40023800
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable8  ;; 0x40023800
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    265            
    266            /* Switch SYSCLK to MSI*/
    267            CLEAR_BIT(RCC->CFGR, RCC_CFGR_SW);
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40023808
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x0880             LSRS     R0,R0,#+2
   \   00000018   0x0080             LSLS     R0,R0,#+2
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x40023808
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    268          
    269            /* Reset HSION, HSEON, CSSON, HSEBYP & PLLON bits */
    270            CLEAR_BIT(RCC->CR, RCC_CR_HSION | RCC_CR_HSEON | RCC_CR_CSSON | RCC_CR_PLLON | RCC_CR_HSEBYP);
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x40023800
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable9_1  ;; 0xeefafffe
   \   0000002A   0x4008             ANDS     R0,R1,R0
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable8  ;; 0x40023800
   \   00000030   0x6008             STR      R0,[R1, #+0]
    271            /* Reset CFGR register */
    272            CLEAR_REG(RCC->CFGR);
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x40023808
   \   00000038   0x6008             STR      R0,[R1, #+0]
    273            
    274            /* Set MSIClockRange & MSITRIM[4:0] bits to the reset value */
    275            MODIFY_REG(RCC->ICSCR, (RCC_ICSCR_MSIRANGE | RCC_ICSCR_MSITRIM), (((uint32_t)0 << RCC_ICSCR_MSITRIM_BITNUMBER) | RCC_ICSCR_MSIRANGE_5));
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x40023804
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x21FF             MOVS     R1,#+255
   \   00000042   0xFAB1 0xF181      CLZ      R1,R1
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable9_3  ;; 0xff1fff
   \   0000004A   0x4008             ANDS     R0,R1,R0
   \   0000004C   0xF450 0x4020      ORRS     R0,R0,#0xA000
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x40023804
   \   00000054   0x6008             STR      R0,[R1, #+0]
    276            
    277            /* Set HSITRIM bits to the reset value */
    278            MODIFY_REG(RCC->ICSCR, RCC_ICSCR_HSITRIM, ((uint32_t)0x10 << POSITION_VAL(RCC_ICSCR_HSITRIM)));
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x40023804
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0xF430 0x50F8      BICS     R0,R0,#0x1F00
   \   00000060   0x2110             MOVS     R1,#+16
   \   00000062   0xF45F 0x0278      MOVS     R2,#+16252928
   \   00000066   0xFAB2 0xF282      CLZ      R2,R2
   \   0000006A   0x4091             LSLS     R1,R1,R2
   \   0000006C   0x4308             ORRS     R0,R1,R0
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x40023804
   \   00000072   0x6008             STR      R0,[R1, #+0]
    279            
    280            /* Disable all interrupts */
    281            CLEAR_REG(RCC->CIR);
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable9_4  ;; 0x4002380c
   \   0000007A   0x6008             STR      R0,[R1, #+0]
    282          
    283            /* Update the SystemCoreClock global variable */
    284            SystemCoreClock = MSI_VALUE;
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable9_5  ;; 0xf42400
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable10
   \   00000084   0x6008             STR      R0,[R1, #+0]
    285          }
   \   00000086   0x4770             BX       LR               ;; return
    286          
    287          /**
    288            * @brief  Initializes the RCC Oscillators according to the specified parameters in the
    289            *         RCC_OscInitTypeDef.
    290            * @param  RCC_OscInitStruct pointer to an RCC_OscInitTypeDef structure that
    291            *         contains the configuration information for the RCC Oscillators.
    292            * @note   The PLL is not disabled when used as system clock.
    293            * @note   Transitions LSE Bypass to LSE On and LSE On to LSE Bypass are not
    294            *         supported by this macro. User should request a transition to LSE Off
    295            *         first and then LSE On or LSE Bypass.
    296            * @note   Transition HSE Bypass to HSE On and HSE On to HSE Bypass are not
    297            *         supported by this macro. User should request a transition to HSE Off
    298            *         first and then HSE On or HSE Bypass.
    299            * @retval HAL status
    300            */

   \                                 In section .text, align 2, keep-with-next
    301          HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
    302          {
   \                     HAL_RCC_OscConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    303             uint32_t tickstart = 0U;
   \   00000006   0x2500             MOVS     R5,#+0
    304            
    305            /* Check the parameters */
    306            assert_param(RCC_OscInitStruct != NULL);
    307            assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
    308          
    309            /*------------------------------- HSE Configuration ------------------------*/ 
    310            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
   \   00000008   0x7820             LDRB     R0,[R4, #+0]
   \   0000000A   0x07C0             LSLS     R0,R0,#+31
   \   0000000C   0xF140 0x80C7      BPL.W    ??HAL_RCC_OscConfig_0
    311            {
    312              /* Check the parameters */
    313              assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    314          
    315              /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    316              if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
    317                 || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40023808
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   0000001A   0x2808             CMP      R0,#+8
   \   0000001C   0xD00B             BEQ.N    ??HAL_RCC_OscConfig_1
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40023808
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   00000028   0x280C             CMP      R0,#+12
   \   0000002A   0xD127             BNE.N    ??HAL_RCC_OscConfig_2
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40023808
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x03C0             LSLS     R0,R0,#+15
   \   00000034   0xD522             BPL.N    ??HAL_RCC_OscConfig_2
    318              {
    319                if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
   \                     ??HAL_RCC_OscConfig_1: (+1)
   \   00000036   0xF44F 0x4080      MOV      R0,#+16384
   \   0000003A   0xFAB0 0xF080      CLZ      R0,R0
   \   0000003E   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0x0940             LSRS     R0,R0,#+5
   \   00000046   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   0x2801             CMP      R0,#+1
   \   0000004A   0xD103             BNE.N    ??HAL_RCC_OscConfig_3
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x40023800
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0xE002             B.N      ??HAL_RCC_OscConfig_4
   \                     ??HAL_RCC_OscConfig_3: (+1)
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_4: (+1)
   \   0000005A   0xF44F 0x4180      MOV      R1,#+16384
   \   0000005E   0xFAB1 0xF181      CLZ      R1,R1
   \   00000062   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000066   0x40C8             LSRS     R0,R0,R1
   \   00000068   0x07C0             LSLS     R0,R0,#+31
   \   0000006A   0xF140 0x8098      BPL.W    ??HAL_RCC_OscConfig_0
   \   0000006E   0x6860             LDR      R0,[R4, #+4]
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xF040 0x8094      BNE.W    ??HAL_RCC_OscConfig_0
    320                {
    321                  return HAL_ERROR;
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0xF000 0xBC06      B.W      ??HAL_RCC_OscConfig_5
    322                }
    323              }
    324              else
    325              {
    326                /* Set the new HSE configuration ---------------------------------------*/
    327                __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
   \                     ??HAL_RCC_OscConfig_2: (+1)
   \   0000007C   0x6860             LDR      R0,[R4, #+4]
   \   0000007E   0x2801             CMP      R0,#+1
   \   00000080   0xD108             BNE.N    ??HAL_RCC_OscConfig_6
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x40023800
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable8  ;; 0x40023800
   \   00000090   0x6008             STR      R0,[R1, #+0]
   \   00000092   0xE037             B.N      ??HAL_RCC_OscConfig_7
   \                     ??HAL_RCC_OscConfig_6: (+1)
   \   00000094   0x6860             LDR      R0,[R4, #+4]
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD110             BNE.N    ??HAL_RCC_OscConfig_8
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x40023800
   \   0000009E   0x6800             LDR      R0,[R0, #+0]
   \   000000A0   0xF430 0x3080      BICS     R0,R0,#0x10000
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable8  ;; 0x40023800
   \   000000A8   0x6008             STR      R0,[R1, #+0]
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x40023800
   \   000000AE   0x6800             LDR      R0,[R0, #+0]
   \   000000B0   0xF430 0x2080      BICS     R0,R0,#0x40000
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable8  ;; 0x40023800
   \   000000B8   0x6008             STR      R0,[R1, #+0]
   \   000000BA   0xE023             B.N      ??HAL_RCC_OscConfig_7
   \                     ??HAL_RCC_OscConfig_8: (+1)
   \   000000BC   0x6860             LDR      R0,[R4, #+4]
   \   000000BE   0x2805             CMP      R0,#+5
   \   000000C0   0xD110             BNE.N    ??HAL_RCC_OscConfig_9
   \   000000C2   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x40023800
   \   000000C6   0x6800             LDR      R0,[R0, #+0]
   \   000000C8   0xF450 0x2080      ORRS     R0,R0,#0x40000
   \   000000CC   0x.... 0x....      LDR.W    R1,??DataTable8  ;; 0x40023800
   \   000000D0   0x6008             STR      R0,[R1, #+0]
   \   000000D2   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x40023800
   \   000000D6   0x6800             LDR      R0,[R0, #+0]
   \   000000D8   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   000000DC   0x.... 0x....      LDR.W    R1,??DataTable8  ;; 0x40023800
   \   000000E0   0x6008             STR      R0,[R1, #+0]
   \   000000E2   0xE00F             B.N      ??HAL_RCC_OscConfig_7
   \                     ??HAL_RCC_OscConfig_9: (+1)
   \   000000E4   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x40023800
   \   000000E8   0x6800             LDR      R0,[R0, #+0]
   \   000000EA   0xF430 0x3080      BICS     R0,R0,#0x10000
   \   000000EE   0x.... 0x....      LDR.W    R1,??DataTable8  ;; 0x40023800
   \   000000F2   0x6008             STR      R0,[R1, #+0]
   \   000000F4   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x40023800
   \   000000F8   0x6800             LDR      R0,[R0, #+0]
   \   000000FA   0xF430 0x2080      BICS     R0,R0,#0x40000
   \   000000FE   0x.... 0x....      LDR.W    R1,??DataTable8  ;; 0x40023800
   \   00000102   0x6008             STR      R0,[R1, #+0]
    328                
    329          
    330                 /* Check the HSE State */
    331                if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
   \                     ??HAL_RCC_OscConfig_7: (+1)
   \   00000104   0x6860             LDR      R0,[R4, #+4]
   \   00000106   0x2800             CMP      R0,#+0
   \   00000108   0xD024             BEQ.N    ??HAL_RCC_OscConfig_10
    332                {
    333                  /* Get Start Tick */
    334                  tickstart = HAL_GetTick();
   \   0000010A   0x.... 0x....      BL       HAL_GetTick
   \   0000010E   0x0005             MOVS     R5,R0
    335                  
    336                  /* Wait till HSE is ready */
    337                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
   \                     ??HAL_RCC_OscConfig_11: (+1)
   \   00000110   0xF44F 0x4080      MOV      R0,#+16384
   \   00000114   0xFAB0 0xF080      CLZ      R0,R0
   \   00000118   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000011C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000011E   0x0940             LSRS     R0,R0,#+5
   \   00000120   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000122   0x2801             CMP      R0,#+1
   \   00000124   0xD103             BNE.N    ??HAL_RCC_OscConfig_12
   \   00000126   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x40023800
   \   0000012A   0x6800             LDR      R0,[R0, #+0]
   \   0000012C   0xE002             B.N      ??HAL_RCC_OscConfig_13
   \                     ??HAL_RCC_OscConfig_12: (+1)
   \   0000012E   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   00000132   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_13: (+1)
   \   00000134   0xF44F 0x4180      MOV      R1,#+16384
   \   00000138   0xFAB1 0xF181      CLZ      R1,R1
   \   0000013C   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000140   0x40C8             LSRS     R0,R0,R1
   \   00000142   0x07C0             LSLS     R0,R0,#+31
   \   00000144   0xD42B             BMI.N    ??HAL_RCC_OscConfig_0
    338                  {
    339                    if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
   \   00000146   0x.... 0x....      BL       HAL_GetTick
   \   0000014A   0x1B40             SUBS     R0,R0,R5
   \   0000014C   0x2865             CMP      R0,#+101
   \   0000014E   0xD3DF             BCC.N    ??HAL_RCC_OscConfig_11
    340                    {
    341                      return HAL_TIMEOUT;
   \   00000150   0x2003             MOVS     R0,#+3
   \   00000152   0xE399             B.N      ??HAL_RCC_OscConfig_5
    342                    }
    343                  }
    344                }
    345                else
    346                {
    347                  /* Get Start Tick */
    348                  tickstart = HAL_GetTick();
   \                     ??HAL_RCC_OscConfig_10: (+1)
   \   00000154   0x.... 0x....      BL       HAL_GetTick
   \   00000158   0x0005             MOVS     R5,R0
    349                  
    350                  /* Wait till HSE is disabled */
    351                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
   \                     ??HAL_RCC_OscConfig_14: (+1)
   \   0000015A   0xF44F 0x4080      MOV      R0,#+16384
   \   0000015E   0xFAB0 0xF080      CLZ      R0,R0
   \   00000162   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000166   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000168   0x0940             LSRS     R0,R0,#+5
   \   0000016A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000016C   0x2801             CMP      R0,#+1
   \   0000016E   0xD103             BNE.N    ??HAL_RCC_OscConfig_15
   \   00000170   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x40023800
   \   00000174   0x6800             LDR      R0,[R0, #+0]
   \   00000176   0xE002             B.N      ??HAL_RCC_OscConfig_16
   \                     ??HAL_RCC_OscConfig_15: (+1)
   \   00000178   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   0000017C   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_16: (+1)
   \   0000017E   0xF44F 0x4180      MOV      R1,#+16384
   \   00000182   0xFAB1 0xF181      CLZ      R1,R1
   \   00000186   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   0000018A   0x40C8             LSRS     R0,R0,R1
   \   0000018C   0x07C0             LSLS     R0,R0,#+31
   \   0000018E   0xD506             BPL.N    ??HAL_RCC_OscConfig_0
    352                  {
    353                     if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
   \   00000190   0x.... 0x....      BL       HAL_GetTick
   \   00000194   0x1B40             SUBS     R0,R0,R5
   \   00000196   0x2865             CMP      R0,#+101
   \   00000198   0xD3DF             BCC.N    ??HAL_RCC_OscConfig_14
    354                    {
    355                      return HAL_TIMEOUT;
   \   0000019A   0x2003             MOVS     R0,#+3
   \   0000019C   0xE374             B.N      ??HAL_RCC_OscConfig_5
    356                    }
    357                  }
    358                }
    359              }
    360            }
    361            /*----------------------------- HSI Configuration --------------------------*/ 
    362            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
   \                     ??HAL_RCC_OscConfig_0: (+1)
   \   0000019E   0x7820             LDRB     R0,[R4, #+0]
   \   000001A0   0x0780             LSLS     R0,R0,#+30
   \   000001A2   0xD542             BPL.N    ??HAL_RCC_OscConfig_17
    363            {
    364              /* Check the parameters */
    365              assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    366              assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    367              
    368              /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    369              if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
    370                 || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
   \   000001A4   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40023808
   \   000001A8   0x6800             LDR      R0,[R0, #+0]
   \   000001AA   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   000001AE   0x2804             CMP      R0,#+4
   \   000001B0   0xD00B             BEQ.N    ??HAL_RCC_OscConfig_18
   \   000001B2   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40023808
   \   000001B6   0x6800             LDR      R0,[R0, #+0]
   \   000001B8   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   000001BC   0x280C             CMP      R0,#+12
   \   000001BE   0xD14E             BNE.N    ??HAL_RCC_OscConfig_19
   \   000001C0   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40023808
   \   000001C4   0x6800             LDR      R0,[R0, #+0]
   \   000001C6   0x03C0             LSLS     R0,R0,#+15
   \   000001C8   0xD449             BMI.N    ??HAL_RCC_OscConfig_19
    371              {
    372                /* When HSI is used as system clock it will not disabled */
    373                if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
   \                     ??HAL_RCC_OscConfig_18: (+1)
   \   000001CA   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   000001CE   0xFAB0 0xF080      CLZ      R0,R0
   \   000001D2   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000001D6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001D8   0x0940             LSRS     R0,R0,#+5
   \   000001DA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001DC   0x2801             CMP      R0,#+1
   \   000001DE   0xD103             BNE.N    ??HAL_RCC_OscConfig_20
   \   000001E0   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x40023800
   \   000001E4   0x6800             LDR      R0,[R0, #+0]
   \   000001E6   0xE002             B.N      ??HAL_RCC_OscConfig_21
   \                     ??HAL_RCC_OscConfig_20: (+1)
   \   000001E8   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   000001EC   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_21: (+1)
   \   000001EE   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   000001F2   0xFAB1 0xF181      CLZ      R1,R1
   \   000001F6   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000001FA   0x40C8             LSRS     R0,R0,R1
   \   000001FC   0x07C0             LSLS     R0,R0,#+31
   \   000001FE   0xD504             BPL.N    ??HAL_RCC_OscConfig_22
   \   00000200   0x68E0             LDR      R0,[R4, #+12]
   \   00000202   0x2801             CMP      R0,#+1
   \   00000204   0xD001             BEQ.N    ??HAL_RCC_OscConfig_22
    374                {
    375                  return HAL_ERROR;
   \   00000206   0x2001             MOVS     R0,#+1
   \   00000208   0xE33E             B.N      ??HAL_RCC_OscConfig_5
    376                }
    377                /* Otherwise, just the calibration is allowed */
    378                else
    379                {
    380                  /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
    381                  __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
   \                     ??HAL_RCC_OscConfig_22: (+1)
   \   0000020A   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x40023804
   \   0000020E   0x6800             LDR      R0,[R0, #+0]
   \   00000210   0xF45F 0x0178      MOVS     R1,#+16252928
   \   00000214   0xFAB1 0xF181      CLZ      R1,R1
   \   00000218   0xF430 0x50F8      BICS     R0,R0,#0x1F00
   \   0000021C   0x6922             LDR      R2,[R4, #+16]
   \   0000021E   0xFA12 0xF101      LSLS     R1,R2,R1
   \   00000222   0x4308             ORRS     R0,R1,R0
   \   00000224   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x40023804
   \   00000228   0x6008             STR      R0,[R1, #+0]
    382                }
    383              }
    384              else
    385              {
    386                /* Check the HSI State */
    387                if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
    388                {
    389                 /* Enable the Internal High Speed oscillator (HSI). */
    390                  __HAL_RCC_HSI_ENABLE();
    391                  
    392                  /* Get Start Tick */
    393                  tickstart = HAL_GetTick();
    394                  
    395                  /* Wait till HSI is ready */
    396                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
    397                  {
    398                    if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
    399                    {
    400                      return HAL_TIMEOUT;
    401                    }
    402                  }
    403                          
    404                  /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
    405                  __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
    406                }
    407                else
    408                {
    409                  /* Disable the Internal High Speed oscillator (HSI). */
    410                  __HAL_RCC_HSI_DISABLE();
    411                  
    412                  /* Get Start Tick */
    413                  tickstart = HAL_GetTick();
    414                  
    415                  /* Wait till HSI is disabled */
    416                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
    417                  {
    418                    if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
    419                    {
    420                      return HAL_TIMEOUT;
    421                    }
    422                  }
    423                }
    424              }
    425            }
    426            /*----------------------------- MSI Configuration --------------------------*/ 
    427            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
   \                     ??HAL_RCC_OscConfig_17: (+1)
   \   0000022A   0x7820             LDRB     R0,[R4, #+0]
   \   0000022C   0x06C0             LSLS     R0,R0,#+27
   \   0000022E   0xF140 0x80E1      BPL.W    ??HAL_RCC_OscConfig_23
    428            {
    429              /* When the MSI is used as system clock it will not be disabled */
    430              if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) )
   \   00000232   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40023808
   \   00000236   0x6800             LDR      R0,[R0, #+0]
   \   00000238   0xF010 0x0F0C      TST      R0,#0xC
   \   0000023C   0xF040 0x8126      BNE.W    ??HAL_RCC_OscConfig_24
    431              {
    432                if((__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
   \   00000240   0xF45F 0x0080      MOVS     R0,#+4194304
   \   00000244   0xFAB0 0xF080      CLZ      R0,R0
   \   00000248   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000024C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000024E   0x0940             LSRS     R0,R0,#+5
   \   00000250   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000252   0x2801             CMP      R0,#+1
   \   00000254   0xD174             BNE.N    ??HAL_RCC_OscConfig_25
   \   00000256   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x40023800
   \   0000025A   0x6800             LDR      R0,[R0, #+0]
   \   0000025C   0xE073             B.N      ??HAL_RCC_OscConfig_26
   \                     ??HAL_RCC_OscConfig_19: (+1)
   \   0000025E   0x68E0             LDR      R0,[R4, #+12]
   \   00000260   0x2800             CMP      R0,#+0
   \   00000262   0xD03E             BEQ.N    ??HAL_RCC_OscConfig_27
   \   00000264   0x2001             MOVS     R0,#+1
   \   00000266   0xF05F 0x4100      MOVS     R1,#-2147483648
   \   0000026A   0xFAB1 0xF181      CLZ      R1,R1
   \   0000026E   0x.... 0x....      LDR.W    R2,??DataTable13  ;; 0x42470000
   \   00000272   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
   \   00000276   0x.... 0x....      BL       HAL_GetTick
   \   0000027A   0x0005             MOVS     R5,R0
   \                     ??HAL_RCC_OscConfig_28: (+1)
   \   0000027C   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   00000280   0xFAB0 0xF080      CLZ      R0,R0
   \   00000284   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000288   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000028A   0x0940             LSRS     R0,R0,#+5
   \   0000028C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000028E   0x2801             CMP      R0,#+1
   \   00000290   0xD103             BNE.N    ??HAL_RCC_OscConfig_29
   \   00000292   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x40023800
   \   00000296   0x6800             LDR      R0,[R0, #+0]
   \   00000298   0xE002             B.N      ??HAL_RCC_OscConfig_30
   \                     ??HAL_RCC_OscConfig_29: (+1)
   \   0000029A   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   0000029E   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_30: (+1)
   \   000002A0   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   000002A4   0xFAB1 0xF181      CLZ      R1,R1
   \   000002A8   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000002AC   0x40C8             LSRS     R0,R0,R1
   \   000002AE   0x07C0             LSLS     R0,R0,#+31
   \   000002B0   0xD406             BMI.N    ??HAL_RCC_OscConfig_31
   \   000002B2   0x.... 0x....      BL       HAL_GetTick
   \   000002B6   0x1B40             SUBS     R0,R0,R5
   \   000002B8   0x2803             CMP      R0,#+3
   \   000002BA   0xD3DF             BCC.N    ??HAL_RCC_OscConfig_28
   \   000002BC   0x2003             MOVS     R0,#+3
   \   000002BE   0xE2E3             B.N      ??HAL_RCC_OscConfig_5
   \                     ??HAL_RCC_OscConfig_31: (+1)
   \   000002C0   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x40023804
   \   000002C4   0x6800             LDR      R0,[R0, #+0]
   \   000002C6   0xF45F 0x0178      MOVS     R1,#+16252928
   \   000002CA   0xFAB1 0xF181      CLZ      R1,R1
   \   000002CE   0xF430 0x50F8      BICS     R0,R0,#0x1F00
   \   000002D2   0x6922             LDR      R2,[R4, #+16]
   \   000002D4   0xFA12 0xF101      LSLS     R1,R2,R1
   \   000002D8   0x4308             ORRS     R0,R1,R0
   \   000002DA   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x40023804
   \   000002DE   0x6008             STR      R0,[R1, #+0]
   \   000002E0   0xE7A3             B.N      ??HAL_RCC_OscConfig_17
   \                     ??HAL_RCC_OscConfig_27: (+1)
   \   000002E2   0x2000             MOVS     R0,#+0
   \   000002E4   0xF05F 0x4100      MOVS     R1,#-2147483648
   \   000002E8   0xFAB1 0xF181      CLZ      R1,R1
   \   000002EC   0x.... 0x....      LDR.W    R2,??DataTable13  ;; 0x42470000
   \   000002F0   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
   \   000002F4   0x.... 0x....      BL       HAL_GetTick
   \   000002F8   0x0005             MOVS     R5,R0
   \                     ??HAL_RCC_OscConfig_32: (+1)
   \   000002FA   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   000002FE   0xFAB0 0xF080      CLZ      R0,R0
   \   00000302   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000306   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000308   0x0940             LSRS     R0,R0,#+5
   \   0000030A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000030C   0x2801             CMP      R0,#+1
   \   0000030E   0xD103             BNE.N    ??HAL_RCC_OscConfig_33
   \   00000310   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x40023800
   \   00000314   0x6800             LDR      R0,[R0, #+0]
   \   00000316   0xE002             B.N      ??HAL_RCC_OscConfig_34
   \                     ??HAL_RCC_OscConfig_33: (+1)
   \   00000318   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   0000031C   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_34: (+1)
   \   0000031E   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   00000322   0xFAB1 0xF181      CLZ      R1,R1
   \   00000326   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   0000032A   0x40C8             LSRS     R0,R0,R1
   \   0000032C   0x07C0             LSLS     R0,R0,#+31
   \   0000032E   0xF57F 0xAF7C      BPL.W    ??HAL_RCC_OscConfig_17
   \   00000332   0x.... 0x....      BL       HAL_GetTick
   \   00000336   0x1B40             SUBS     R0,R0,R5
   \   00000338   0x2803             CMP      R0,#+3
   \   0000033A   0xD3DE             BCC.N    ??HAL_RCC_OscConfig_32
   \   0000033C   0x2003             MOVS     R0,#+3
   \   0000033E   0xE2A3             B.N      ??HAL_RCC_OscConfig_5
   \                     ??HAL_RCC_OscConfig_25: (+1)
   \   00000340   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   00000344   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_26: (+1)
   \   00000346   0xF45F 0x0180      MOVS     R1,#+4194304
   \   0000034A   0xFAB1 0xF181      CLZ      R1,R1
   \   0000034E   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000352   0x40C8             LSRS     R0,R0,R1
   \   00000354   0x07C0             LSLS     R0,R0,#+31
   \   00000356   0xD504             BPL.N    ??HAL_RCC_OscConfig_35
   \   00000358   0x69A0             LDR      R0,[R4, #+24]
   \   0000035A   0x2800             CMP      R0,#+0
   \   0000035C   0xD101             BNE.N    ??HAL_RCC_OscConfig_35
    433                {
    434                  return HAL_ERROR;
   \   0000035E   0x2001             MOVS     R0,#+1
   \   00000360   0xE292             B.N      ??HAL_RCC_OscConfig_5
    435                }
    436                /* Otherwise, just the calibration and MSI range change are allowed */
    437                else
    438                {
    439                 /* Check MSICalibrationValue and MSIClockRange input parameters */
    440                  assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
    441                  assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));
    442          
    443                  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    444                     must be correctly programmed according to the frequency of the CPU clock
    445                     (HCLK) and the supply voltage of the device. */
    446                  if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
   \                     ??HAL_RCC_OscConfig_35: (+1)
   \   00000362   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x40023804
   \   00000366   0x6800             LDR      R0,[R0, #+0]
   \   00000368   0xF410 0x4060      ANDS     R0,R0,#0xE000
   \   0000036C   0x6A21             LDR      R1,[R4, #+32]
   \   0000036E   0x4288             CMP      R0,R1
   \   00000370   0xD26C             BCS.N    ??HAL_RCC_OscConfig_36
    447                  {
    448                    /* First increase number of wait states update if necessary */
    449                    if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
   \   00000372   0x6A20             LDR      R0,[R4, #+32]
   \   00000374   0x.... 0x....      BL       RCC_SetFlashLatencyFromMSIRange
   \   00000378   0x2800             CMP      R0,#+0
   \   0000037A   0xD001             BEQ.N    ??HAL_RCC_OscConfig_37
    450                    {
    451                      return HAL_ERROR;
   \   0000037C   0x2001             MOVS     R0,#+1
   \   0000037E   0xE283             B.N      ??HAL_RCC_OscConfig_5
    452                    }
    453          
    454                    /* Selects the Multiple Speed oscillator (MSI) clock range .*/
    455                    __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
   \                     ??HAL_RCC_OscConfig_37: (+1)
   \   00000380   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x40023804
   \   00000384   0x6800             LDR      R0,[R0, #+0]
   \   00000386   0xF430 0x4060      BICS     R0,R0,#0xE000
   \   0000038A   0x6A21             LDR      R1,[R4, #+32]
   \   0000038C   0x4308             ORRS     R0,R1,R0
   \   0000038E   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x40023804
   \   00000392   0x6008             STR      R0,[R1, #+0]
    456                    /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
    457                    __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
   \   00000394   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x40023804
   \   00000398   0x6800             LDR      R0,[R0, #+0]
   \   0000039A   0x21FF             MOVS     R1,#+255
   \   0000039C   0xFAB1 0xF181      CLZ      R1,R1
   \   000003A0   0x0200             LSLS     R0,R0,#+8        ;; ZeroExtS R0,R0,#+8,#+8
   \   000003A2   0x0A00             LSRS     R0,R0,#+8
   \   000003A4   0x69E2             LDR      R2,[R4, #+28]
   \   000003A6   0xFA12 0xF101      LSLS     R1,R2,R1
   \   000003AA   0x4308             ORRS     R0,R1,R0
   \   000003AC   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x40023804
   \   000003B0   0x6008             STR      R0,[R1, #+0]
    458                  }
    459                  else
    460                  {
    461                    /* Else, keep current flash latency while decreasing applies */
    462                    /* Selects the Multiple Speed oscillator (MSI) clock range .*/
    463                    __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
    464                    /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
    465                    __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
    466          
    467                    /* Decrease number of wait states update if necessary */
    468                    if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
    469                    {
    470                      return HAL_ERROR;
    471                    }          
    472                  }
    473          
    474                  /* Update the SystemCoreClock global variable */
    475                  SystemCoreClock =  (32768U * (1U << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_BITNUMBER) + 1U))) 
    476                                     >> AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_BITNUMBER)];
   \                     ??HAL_RCC_OscConfig_38: (+1)
   \   000003B2   0xF45F 0x20E0      MOVS     R0,#+458752
   \   000003B6   0xFAB0 0xF080      CLZ      R0,R0
   \   000003BA   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x40023808
   \   000003BE   0x6809             LDR      R1,[R1, #+0]
   \   000003C0   0xF05F 0x6270      MOVS     R2,#+251658240
   \   000003C4   0xFAB2 0xF282      CLZ      R2,R2
   \   000003C8   0x2301             MOVS     R3,#+1
   \   000003CA   0x6A25             LDR      R5,[R4, #+32]
   \   000003CC   0x40C5             LSRS     R5,R5,R0
   \   000003CE   0x1C68             ADDS     R0,R5,#+1
   \   000003D0   0xFA13 0xF000      LSLS     R0,R3,R0
   \   000003D4   0xF44F 0x4300      MOV      R3,#+32768
   \   000003D8   0x4358             MULS     R0,R3,R0
   \   000003DA   0x.... 0x....      LDR.W    R3,??DataTable13_1
   \   000003DE   0xF011 0x01F0      ANDS     R1,R1,#0xF0
   \   000003E2   0x40D1             LSRS     R1,R1,R2
   \   000003E4   0x5CC9             LDRB     R1,[R1, R3]
   \   000003E6   0x40C8             LSRS     R0,R0,R1
   \   000003E8   0x.... 0x....      LDR.W    R1,??DataTable10
   \   000003EC   0x6008             STR      R0,[R1, #+0]
    477          
    478                  /* Configure the source of time base considering new system clocks settings*/
    479                  HAL_InitTick (TICK_INT_PRIORITY);
   \   000003EE   0x200F             MOVS     R0,#+15
   \   000003F0   0x.... 0x....      BL       HAL_InitTick
    480                }
    481              }
    482              else
    483              {
    484                /* Check MSI State */
    485                assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));
    486          
    487                /* Check the MSI State */
    488                if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
    489                {
    490                  /* Enable the Multi Speed oscillator (MSI). */
    491                  __HAL_RCC_MSI_ENABLE();
    492          
    493                  /* Get Start Tick */
    494                  tickstart = HAL_GetTick();
    495          
    496                  /* Wait till MSI is ready */
    497                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
    498                  {
    499                    if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
    500                    {
    501                      return HAL_TIMEOUT;
    502                    }
    503                  }
    504                  /* Check MSICalibrationValue and MSIClockRange input parameters */
    505                  assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
    506                  assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));
    507          
    508                  /* Selects the Multiple Speed oscillator (MSI) clock range .*/
    509                  __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
    510                   /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
    511                  __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
    512          
    513                }
    514                else
    515                {
    516                  /* Disable the Multi Speed oscillator (MSI). */
    517                  __HAL_RCC_MSI_DISABLE();
    518          
    519                  /* Get Start Tick */
    520                  tickstart = HAL_GetTick();
    521          
    522                  /* Wait till MSI is ready */
    523                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET)
    524                  {
    525                    if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
    526                    {
    527                      return HAL_TIMEOUT;
    528                    }
    529                  }
    530                }
    531              }
    532            }  
    533            /*------------------------------ LSI Configuration -------------------------*/ 
    534            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
   \                     ??HAL_RCC_OscConfig_23: (+1)
   \   000003F4   0x7820             LDRB     R0,[R4, #+0]
   \   000003F6   0x0700             LSLS     R0,R0,#+28
   \   000003F8   0xF140 0x80E5      BPL.W    ??HAL_RCC_OscConfig_39
    535            {
    536              /* Check the parameters */
    537              assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
    538              
    539              /* Check the LSI State */
    540              if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
   \   000003FC   0x6960             LDR      R0,[R4, #+20]
   \   000003FE   0x2800             CMP      R0,#+0
   \   00000400   0xF000 0x80BE      BEQ.W    ??HAL_RCC_OscConfig_40
    541              {
    542                /* Enable the Internal Low Speed oscillator (LSI). */
    543                __HAL_RCC_LSI_ENABLE();
   \   00000404   0x2001             MOVS     R0,#+1
   \   00000406   0xF05F 0x4100      MOVS     R1,#-2147483648
   \   0000040A   0xFAB1 0xF181      CLZ      R1,R1
   \   0000040E   0x.... 0x....      LDR.W    R2,??DataTable13_2  ;; 0x42470680
   \   00000412   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
    544                
    545                /* Get Start Tick */
    546                tickstart = HAL_GetTick();
   \   00000416   0x.... 0x....      BL       HAL_GetTick
   \   0000041A   0x0005             MOVS     R5,R0
    547                
    548                /* Wait till LSI is ready */  
    549                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
   \                     ??HAL_RCC_OscConfig_41: (+1)
   \   0000041C   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   00000420   0xFAB0 0xF080      CLZ      R0,R0
   \   00000424   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   00000428   0x6800             LDR      R0,[R0, #+0]
   \   0000042A   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   0000042E   0xFAB1 0xF181      CLZ      R1,R1
   \   00000432   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000436   0x40C8             LSRS     R0,R0,R1
   \   00000438   0x07C0             LSLS     R0,R0,#+31
   \   0000043A   0xF100 0x80C4      BMI.W    ??HAL_RCC_OscConfig_39
    550                {
    551                  if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
   \   0000043E   0x.... 0x....      BL       HAL_GetTick
   \   00000442   0x1B40             SUBS     R0,R0,R5
   \   00000444   0x2803             CMP      R0,#+3
   \   00000446   0xD3E9             BCC.N    ??HAL_RCC_OscConfig_41
    552                  {
    553                    return HAL_TIMEOUT;
   \   00000448   0x2003             MOVS     R0,#+3
   \   0000044A   0xE21D             B.N      ??HAL_RCC_OscConfig_5
    554                  }
    555                }
    556              }
   \                     ??HAL_RCC_OscConfig_36: (+1)
   \   0000044C   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x40023804
   \   00000450   0x6800             LDR      R0,[R0, #+0]
   \   00000452   0xF430 0x4060      BICS     R0,R0,#0xE000
   \   00000456   0x6A21             LDR      R1,[R4, #+32]
   \   00000458   0x4308             ORRS     R0,R1,R0
   \   0000045A   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x40023804
   \   0000045E   0x6008             STR      R0,[R1, #+0]
   \   00000460   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x40023804
   \   00000464   0x6800             LDR      R0,[R0, #+0]
   \   00000466   0x21FF             MOVS     R1,#+255
   \   00000468   0xFAB1 0xF181      CLZ      R1,R1
   \   0000046C   0x0200             LSLS     R0,R0,#+8        ;; ZeroExtS R0,R0,#+8,#+8
   \   0000046E   0x0A00             LSRS     R0,R0,#+8
   \   00000470   0x69E2             LDR      R2,[R4, #+28]
   \   00000472   0xFA12 0xF101      LSLS     R1,R2,R1
   \   00000476   0x4308             ORRS     R0,R1,R0
   \   00000478   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x40023804
   \   0000047C   0x6008             STR      R0,[R1, #+0]
   \   0000047E   0x6A20             LDR      R0,[R4, #+32]
   \   00000480   0x.... 0x....      BL       RCC_SetFlashLatencyFromMSIRange
   \   00000484   0x2800             CMP      R0,#+0
   \   00000486   0xD094             BEQ.N    ??HAL_RCC_OscConfig_38
   \   00000488   0x2001             MOVS     R0,#+1
   \   0000048A   0xE1FD             B.N      ??HAL_RCC_OscConfig_5
   \                     ??HAL_RCC_OscConfig_24: (+1)
   \   0000048C   0x69A0             LDR      R0,[R4, #+24]
   \   0000048E   0x2800             CMP      R0,#+0
   \   00000490   0xD047             BEQ.N    ??HAL_RCC_OscConfig_42
   \   00000492   0x2001             MOVS     R0,#+1
   \   00000494   0xF45F 0x0100      MOVS     R1,#+8388608
   \   00000498   0xFAB1 0xF181      CLZ      R1,R1
   \   0000049C   0x.... 0x....      LDR.W    R2,??DataTable13  ;; 0x42470000
   \   000004A0   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
   \   000004A4   0x.... 0x....      BL       HAL_GetTick
   \   000004A8   0x0005             MOVS     R5,R0
   \                     ??HAL_RCC_OscConfig_43: (+1)
   \   000004AA   0xF45F 0x0080      MOVS     R0,#+4194304
   \   000004AE   0xFAB0 0xF080      CLZ      R0,R0
   \   000004B2   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000004B6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000004B8   0x0940             LSRS     R0,R0,#+5
   \   000004BA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000004BC   0x2801             CMP      R0,#+1
   \   000004BE   0xD103             BNE.N    ??HAL_RCC_OscConfig_44
   \   000004C0   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x40023800
   \   000004C4   0x6800             LDR      R0,[R0, #+0]
   \   000004C6   0xE002             B.N      ??HAL_RCC_OscConfig_45
   \                     ??HAL_RCC_OscConfig_44: (+1)
   \   000004C8   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   000004CC   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_45: (+1)
   \   000004CE   0xF45F 0x0180      MOVS     R1,#+4194304
   \   000004D2   0xFAB1 0xF181      CLZ      R1,R1
   \   000004D6   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000004DA   0x40C8             LSRS     R0,R0,R1
   \   000004DC   0x07C0             LSLS     R0,R0,#+31
   \   000004DE   0xD406             BMI.N    ??HAL_RCC_OscConfig_46
   \   000004E0   0x.... 0x....      BL       HAL_GetTick
   \   000004E4   0x1B40             SUBS     R0,R0,R5
   \   000004E6   0x2803             CMP      R0,#+3
   \   000004E8   0xD3DF             BCC.N    ??HAL_RCC_OscConfig_43
   \   000004EA   0x2003             MOVS     R0,#+3
   \   000004EC   0xE1CC             B.N      ??HAL_RCC_OscConfig_5
   \                     ??HAL_RCC_OscConfig_46: (+1)
   \   000004EE   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x40023804
   \   000004F2   0x6800             LDR      R0,[R0, #+0]
   \   000004F4   0xF430 0x4060      BICS     R0,R0,#0xE000
   \   000004F8   0x6A21             LDR      R1,[R4, #+32]
   \   000004FA   0x4308             ORRS     R0,R1,R0
   \   000004FC   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x40023804
   \   00000500   0x6008             STR      R0,[R1, #+0]
   \   00000502   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x40023804
   \   00000506   0x6800             LDR      R0,[R0, #+0]
   \   00000508   0x21FF             MOVS     R1,#+255
   \   0000050A   0xFAB1 0xF181      CLZ      R1,R1
   \   0000050E   0x0200             LSLS     R0,R0,#+8        ;; ZeroExtS R0,R0,#+8,#+8
   \   00000510   0x0A00             LSRS     R0,R0,#+8
   \   00000512   0x69E2             LDR      R2,[R4, #+28]
   \   00000514   0xFA12 0xF101      LSLS     R1,R2,R1
   \   00000518   0x4308             ORRS     R0,R1,R0
   \   0000051A   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x40023804
   \   0000051E   0x6008             STR      R0,[R1, #+0]
   \   00000520   0xE768             B.N      ??HAL_RCC_OscConfig_23
   \                     ??HAL_RCC_OscConfig_42: (+1)
   \   00000522   0x2000             MOVS     R0,#+0
   \   00000524   0xF45F 0x0100      MOVS     R1,#+8388608
   \   00000528   0xFAB1 0xF181      CLZ      R1,R1
   \   0000052C   0x.... 0x....      LDR.W    R2,??DataTable13  ;; 0x42470000
   \   00000530   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
   \   00000534   0x.... 0x....      BL       HAL_GetTick
   \   00000538   0x0005             MOVS     R5,R0
   \                     ??HAL_RCC_OscConfig_47: (+1)
   \   0000053A   0xF45F 0x0080      MOVS     R0,#+4194304
   \   0000053E   0xFAB0 0xF080      CLZ      R0,R0
   \   00000542   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000546   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000548   0x0940             LSRS     R0,R0,#+5
   \   0000054A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000054C   0x2801             CMP      R0,#+1
   \   0000054E   0xD103             BNE.N    ??HAL_RCC_OscConfig_48
   \   00000550   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x40023800
   \   00000554   0x6800             LDR      R0,[R0, #+0]
   \   00000556   0xE002             B.N      ??HAL_RCC_OscConfig_49
   \                     ??HAL_RCC_OscConfig_48: (+1)
   \   00000558   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   0000055C   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_49: (+1)
   \   0000055E   0xF45F 0x0180      MOVS     R1,#+4194304
   \   00000562   0xFAB1 0xF181      CLZ      R1,R1
   \   00000566   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   0000056A   0x40C8             LSRS     R0,R0,R1
   \   0000056C   0x07C0             LSLS     R0,R0,#+31
   \   0000056E   0xF57F 0xAF41      BPL.W    ??HAL_RCC_OscConfig_23
   \   00000572   0x.... 0x....      BL       HAL_GetTick
   \   00000576   0x1B40             SUBS     R0,R0,R5
   \   00000578   0x2803             CMP      R0,#+3
   \   0000057A   0xD3DE             BCC.N    ??HAL_RCC_OscConfig_47
   \   0000057C   0x2003             MOVS     R0,#+3
   \   0000057E   0xE183             B.N      ??HAL_RCC_OscConfig_5
    557              else
    558              {
    559                /* Disable the Internal Low Speed oscillator (LSI). */
    560                __HAL_RCC_LSI_DISABLE();
   \                     ??HAL_RCC_OscConfig_40: (+1)
   \   00000580   0x2000             MOVS     R0,#+0
   \   00000582   0xF05F 0x4100      MOVS     R1,#-2147483648
   \   00000586   0xFAB1 0xF181      CLZ      R1,R1
   \   0000058A   0x.... 0x....      LDR.W    R2,??DataTable13_2  ;; 0x42470680
   \   0000058E   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
    561                
    562                /* Get Start Tick */
    563                tickstart = HAL_GetTick();
   \   00000592   0x.... 0x....      BL       HAL_GetTick
   \   00000596   0x0005             MOVS     R5,R0
    564                
    565                /* Wait till LSI is disabled */  
    566                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
   \                     ??HAL_RCC_OscConfig_50: (+1)
   \   00000598   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   0000059C   0xFAB0 0xF080      CLZ      R0,R0
   \   000005A0   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   000005A4   0x6800             LDR      R0,[R0, #+0]
   \   000005A6   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   000005AA   0xFAB1 0xF181      CLZ      R1,R1
   \   000005AE   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000005B2   0x40C8             LSRS     R0,R0,R1
   \   000005B4   0x07C0             LSLS     R0,R0,#+31
   \   000005B6   0xD506             BPL.N    ??HAL_RCC_OscConfig_39
    567                {
    568                  if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
   \   000005B8   0x.... 0x....      BL       HAL_GetTick
   \   000005BC   0x1B40             SUBS     R0,R0,R5
   \   000005BE   0x2803             CMP      R0,#+3
   \   000005C0   0xD3EA             BCC.N    ??HAL_RCC_OscConfig_50
    569                  {
    570                    return HAL_TIMEOUT;
   \   000005C2   0x2003             MOVS     R0,#+3
   \   000005C4   0xE160             B.N      ??HAL_RCC_OscConfig_5
    571                  }
    572                }
    573              }
    574            }
    575            /*------------------------------ LSE Configuration -------------------------*/ 
    576            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
   \                     ??HAL_RCC_OscConfig_39: (+1)
   \   000005C6   0x7820             LDRB     R0,[R4, #+0]
   \   000005C8   0x0740             LSLS     R0,R0,#+29
   \   000005CA   0xF140 0x80BC      BPL.W    ??HAL_RCC_OscConfig_51
    577            {
    578              FlagStatus       pwrclkchanged = RESET;
   \   000005CE   0x2600             MOVS     R6,#+0
    579              
    580              /* Check the parameters */
    581              assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    582          
    583              /* Update LSE configuration in Backup Domain control register    */
    584              /* Requires to enable write access to Backup Domain of necessary */
    585              if(__HAL_RCC_PWR_IS_CLK_DISABLED())
   \   000005D0   0x.... 0x....      LDR.W    R0,??DataTable13_3  ;; 0x40023824
   \   000005D4   0x6800             LDR      R0,[R0, #+0]
   \   000005D6   0x00C0             LSLS     R0,R0,#+3
   \   000005D8   0xD40F             BMI.N    ??HAL_RCC_OscConfig_52
    586              {
    587                __HAL_RCC_PWR_CLK_ENABLE();
   \   000005DA   0x.... 0x....      LDR.W    R0,??DataTable13_3  ;; 0x40023824
   \   000005DE   0x6800             LDR      R0,[R0, #+0]
   \   000005E0   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   000005E4   0x.... 0x....      LDR.W    R1,??DataTable13_3  ;; 0x40023824
   \   000005E8   0x6008             STR      R0,[R1, #+0]
   \   000005EA   0x.... 0x....      LDR.W    R0,??DataTable13_3  ;; 0x40023824
   \   000005EE   0x6800             LDR      R0,[R0, #+0]
   \   000005F0   0xF010 0x5080      ANDS     R0,R0,#0x10000000
   \   000005F4   0x9000             STR      R0,[SP, #+0]
   \   000005F6   0x9800             LDR      R0,[SP, #+0]
    588                pwrclkchanged = SET;
   \   000005F8   0x2601             MOVS     R6,#+1
    589              }
    590              
    591              if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
   \                     ??HAL_RCC_OscConfig_52: (+1)
   \   000005FA   0x.... 0x....      LDR.W    R0,??DataTable13_4  ;; 0x40007000
   \   000005FE   0x6800             LDR      R0,[R0, #+0]
   \   00000600   0x05C0             LSLS     R0,R0,#+23
   \   00000602   0xD416             BMI.N    ??HAL_RCC_OscConfig_53
    592              {
    593                /* Enable write access to Backup domain */
    594                SET_BIT(PWR->CR, PWR_CR_DBP);
   \   00000604   0x.... 0x....      LDR.W    R0,??DataTable13_4  ;; 0x40007000
   \   00000608   0x6800             LDR      R0,[R0, #+0]
   \   0000060A   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000060E   0x.... 0x....      LDR.W    R1,??DataTable13_4  ;; 0x40007000
   \   00000612   0x6008             STR      R0,[R1, #+0]
    595                
    596                /* Wait for Backup domain Write protection disable */
    597                tickstart = HAL_GetTick();
   \   00000614   0x.... 0x....      BL       HAL_GetTick
   \   00000618   0x0005             MOVS     R5,R0
    598          
    599                while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
   \                     ??HAL_RCC_OscConfig_54: (+1)
   \   0000061A   0x.... 0x....      LDR.W    R0,??DataTable13_4  ;; 0x40007000
   \   0000061E   0x6800             LDR      R0,[R0, #+0]
   \   00000620   0x05C0             LSLS     R0,R0,#+23
   \   00000622   0xD406             BMI.N    ??HAL_RCC_OscConfig_53
    600                {
    601                  if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
   \   00000624   0x.... 0x....      BL       HAL_GetTick
   \   00000628   0x1B40             SUBS     R0,R0,R5
   \   0000062A   0x2865             CMP      R0,#+101
   \   0000062C   0xD3F5             BCC.N    ??HAL_RCC_OscConfig_54
    602                  {
    603                    return HAL_TIMEOUT;
   \   0000062E   0x2003             MOVS     R0,#+3
   \   00000630   0xE12A             B.N      ??HAL_RCC_OscConfig_5
    604                  }
    605                }
    606              }
    607          
    608              /* Set the new LSE configuration -----------------------------------------*/
    609              __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
   \                     ??HAL_RCC_OscConfig_53: (+1)
   \   00000632   0x68A0             LDR      R0,[R4, #+8]
   \   00000634   0x2801             CMP      R0,#+1
   \   00000636   0xD108             BNE.N    ??HAL_RCC_OscConfig_55
   \   00000638   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   0000063C   0x6800             LDR      R0,[R0, #+0]
   \   0000063E   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000642   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023834
   \   00000646   0x6008             STR      R0,[R1, #+0]
   \   00000648   0xE037             B.N      ??HAL_RCC_OscConfig_56
   \                     ??HAL_RCC_OscConfig_55: (+1)
   \   0000064A   0x68A0             LDR      R0,[R4, #+8]
   \   0000064C   0x2800             CMP      R0,#+0
   \   0000064E   0xD110             BNE.N    ??HAL_RCC_OscConfig_57
   \   00000650   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   00000654   0x6800             LDR      R0,[R0, #+0]
   \   00000656   0xF430 0x7080      BICS     R0,R0,#0x100
   \   0000065A   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023834
   \   0000065E   0x6008             STR      R0,[R1, #+0]
   \   00000660   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   00000664   0x6800             LDR      R0,[R0, #+0]
   \   00000666   0xF430 0x6080      BICS     R0,R0,#0x400
   \   0000066A   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023834
   \   0000066E   0x6008             STR      R0,[R1, #+0]
   \   00000670   0xE023             B.N      ??HAL_RCC_OscConfig_56
   \                     ??HAL_RCC_OscConfig_57: (+1)
   \   00000672   0x68A0             LDR      R0,[R4, #+8]
   \   00000674   0x2805             CMP      R0,#+5
   \   00000676   0xD110             BNE.N    ??HAL_RCC_OscConfig_58
   \   00000678   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   0000067C   0x6800             LDR      R0,[R0, #+0]
   \   0000067E   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000682   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023834
   \   00000686   0x6008             STR      R0,[R1, #+0]
   \   00000688   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   0000068C   0x6800             LDR      R0,[R0, #+0]
   \   0000068E   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000692   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023834
   \   00000696   0x6008             STR      R0,[R1, #+0]
   \   00000698   0xE00F             B.N      ??HAL_RCC_OscConfig_56
   \                     ??HAL_RCC_OscConfig_58: (+1)
   \   0000069A   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   0000069E   0x6800             LDR      R0,[R0, #+0]
   \   000006A0   0xF430 0x7080      BICS     R0,R0,#0x100
   \   000006A4   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023834
   \   000006A8   0x6008             STR      R0,[R1, #+0]
   \   000006AA   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   000006AE   0x6800             LDR      R0,[R0, #+0]
   \   000006B0   0xF430 0x6080      BICS     R0,R0,#0x400
   \   000006B4   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40023834
   \   000006B8   0x6008             STR      R0,[R1, #+0]
    610              /* Check the LSE State */
    611              if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
   \                     ??HAL_RCC_OscConfig_56: (+1)
   \   000006BA   0x68A0             LDR      R0,[R4, #+8]
   \   000006BC   0x2800             CMP      R0,#+0
   \   000006BE   0xD01B             BEQ.N    ??HAL_RCC_OscConfig_59
    612              {
    613                /* Get Start Tick */
    614                tickstart = HAL_GetTick();
   \   000006C0   0x.... 0x....      BL       HAL_GetTick
   \   000006C4   0x0005             MOVS     R5,R0
    615                
    616                /* Wait till LSE is ready */  
    617                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
   \                     ??HAL_RCC_OscConfig_60: (+1)
   \   000006C6   0xF45F 0x0080      MOVS     R0,#+4194304
   \   000006CA   0xFAB0 0xF080      CLZ      R0,R0
   \   000006CE   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   000006D2   0x6800             LDR      R0,[R0, #+0]
   \   000006D4   0xF45F 0x0180      MOVS     R1,#+4194304
   \   000006D8   0xFAB1 0xF181      CLZ      R1,R1
   \   000006DC   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000006E0   0x40C8             LSRS     R0,R0,R1
   \   000006E2   0x07C0             LSLS     R0,R0,#+31
   \   000006E4   0xD424             BMI.N    ??HAL_RCC_OscConfig_61
    618                {
    619                  if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
   \   000006E6   0x.... 0x....      BL       HAL_GetTick
   \   000006EA   0x1B40             SUBS     R0,R0,R5
   \   000006EC   0xF241 0x3189      MOVW     R1,#+5001
   \   000006F0   0x4288             CMP      R0,R1
   \   000006F2   0xD3E8             BCC.N    ??HAL_RCC_OscConfig_60
    620                  {
    621                    return HAL_TIMEOUT;
   \   000006F4   0x2003             MOVS     R0,#+3
   \   000006F6   0xE0C7             B.N      ??HAL_RCC_OscConfig_5
    622                  }
    623                }
    624              }
    625              else
    626              {
    627                /* Get Start Tick */
    628                tickstart = HAL_GetTick();
   \                     ??HAL_RCC_OscConfig_59: (+1)
   \   000006F8   0x.... 0x....      BL       HAL_GetTick
   \   000006FC   0x0005             MOVS     R5,R0
    629                
    630                /* Wait till LSE is disabled */  
    631                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
   \                     ??HAL_RCC_OscConfig_62: (+1)
   \   000006FE   0xF45F 0x0080      MOVS     R0,#+4194304
   \   00000702   0xFAB0 0xF080      CLZ      R0,R0
   \   00000706   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   0000070A   0x6800             LDR      R0,[R0, #+0]
   \   0000070C   0xF45F 0x0180      MOVS     R1,#+4194304
   \   00000710   0xFAB1 0xF181      CLZ      R1,R1
   \   00000714   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000718   0x40C8             LSRS     R0,R0,R1
   \   0000071A   0x07C0             LSLS     R0,R0,#+31
   \   0000071C   0xD508             BPL.N    ??HAL_RCC_OscConfig_61
    632                {
    633                  if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
   \   0000071E   0x.... 0x....      BL       HAL_GetTick
   \   00000722   0x1B40             SUBS     R0,R0,R5
   \   00000724   0xF241 0x3189      MOVW     R1,#+5001
   \   00000728   0x4288             CMP      R0,R1
   \   0000072A   0xD3E8             BCC.N    ??HAL_RCC_OscConfig_62
    634                  {
    635                    return HAL_TIMEOUT;
   \   0000072C   0x2003             MOVS     R0,#+3
   \   0000072E   0xE0AB             B.N      ??HAL_RCC_OscConfig_5
    636                  }
    637                }
    638              }
    639          
    640              /* Require to disable power clock if necessary */
    641              if(pwrclkchanged == SET)
   \                     ??HAL_RCC_OscConfig_61: (+1)
   \   00000730   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000732   0x2E01             CMP      R6,#+1
   \   00000734   0xD107             BNE.N    ??HAL_RCC_OscConfig_51
    642              {
    643                __HAL_RCC_PWR_CLK_DISABLE();
   \   00000736   0x.... 0x....      LDR.W    R0,??DataTable13_3  ;; 0x40023824
   \   0000073A   0x6800             LDR      R0,[R0, #+0]
   \   0000073C   0xF030 0x5080      BICS     R0,R0,#0x10000000
   \   00000740   0x.... 0x....      LDR.W    R1,??DataTable13_3  ;; 0x40023824
   \   00000744   0x6008             STR      R0,[R1, #+0]
    644              }
    645            }
    646          
    647            /*-------------------------------- PLL Configuration -----------------------*/
    648            /* Check the parameters */
    649            assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
    650            if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
   \                     ??HAL_RCC_OscConfig_51: (+1)
   \   00000746   0x6A60             LDR      R0,[R4, #+36]
   \   00000748   0x2800             CMP      R0,#+0
   \   0000074A   0xF000 0x809C      BEQ.W    ??HAL_RCC_OscConfig_63
    651            {
    652              /* Check if the PLL is used as system clock or not */
    653              if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
   \   0000074E   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40023808
   \   00000752   0x6800             LDR      R0,[R0, #+0]
   \   00000754   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   00000758   0x280C             CMP      R0,#+12
   \   0000075A   0xF000 0x8092      BEQ.W    ??HAL_RCC_OscConfig_64
    654              { 
    655                if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
   \   0000075E   0x6A60             LDR      R0,[R4, #+36]
   \   00000760   0x2802             CMP      R0,#+2
   \   00000762   0xD163             BNE.N    ??HAL_RCC_OscConfig_65
    656                {
    657                  /* Check the parameters */
    658                  assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
    659                  assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));
    660                  assert_param(IS_RCC_PLL_DIV(RCC_OscInitStruct->PLL.PLLDIV));
    661            
    662                  /* Disable the main PLL. */
    663                  __HAL_RCC_PLL_DISABLE();
   \   00000764   0x2000             MOVS     R0,#+0
   \   00000766   0x2180             MOVS     R1,#+128
   \   00000768   0xFAB1 0xF181      CLZ      R1,R1
   \   0000076C   0x.... 0x....      LDR.W    R2,??DataTable13  ;; 0x42470000
   \   00000770   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
    664                  
    665                  /* Get Start Tick */
    666                  tickstart = HAL_GetTick();
   \   00000774   0x.... 0x....      BL       HAL_GetTick
   \   00000778   0x0005             MOVS     R5,R0
    667                  
    668                  /* Wait till PLL is disabled */
    669                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
   \                     ??HAL_RCC_OscConfig_66: (+1)
   \   0000077A   0x2040             MOVS     R0,#+64
   \   0000077C   0xFAB0 0xF080      CLZ      R0,R0
   \   00000780   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000784   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000786   0x0940             LSRS     R0,R0,#+5
   \   00000788   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000078A   0x2801             CMP      R0,#+1
   \   0000078C   0xD103             BNE.N    ??HAL_RCC_OscConfig_67
   \   0000078E   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x40023800
   \   00000792   0x6800             LDR      R0,[R0, #+0]
   \   00000794   0xE002             B.N      ??HAL_RCC_OscConfig_68
   \                     ??HAL_RCC_OscConfig_67: (+1)
   \   00000796   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   0000079A   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_68: (+1)
   \   0000079C   0x2140             MOVS     R1,#+64
   \   0000079E   0xFAB1 0xF181      CLZ      R1,R1
   \   000007A2   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000007A6   0x40C8             LSRS     R0,R0,R1
   \   000007A8   0x07C0             LSLS     R0,R0,#+31
   \   000007AA   0xD506             BPL.N    ??HAL_RCC_OscConfig_69
    670                  {
    671                    if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
   \   000007AC   0x.... 0x....      BL       HAL_GetTick
   \   000007B0   0x1B40             SUBS     R0,R0,R5
   \   000007B2   0x2803             CMP      R0,#+3
   \   000007B4   0xD3E1             BCC.N    ??HAL_RCC_OscConfig_66
    672                    {
    673                      return HAL_TIMEOUT;
   \   000007B6   0x2003             MOVS     R0,#+3
   \   000007B8   0xE066             B.N      ??HAL_RCC_OscConfig_5
    674                    }
    675                  }
    676          
    677                  /* Configure the main PLL clock source, multiplication and division factors. */
    678                  __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
    679                                       RCC_OscInitStruct->PLL.PLLMUL,
    680                                       RCC_OscInitStruct->PLL.PLLDIV);
   \                     ??HAL_RCC_OscConfig_69: (+1)
   \   000007BA   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40023808
   \   000007BE   0x6800             LDR      R0,[R0, #+0]
   \   000007C0   0xF430 0x007D      BICS     R0,R0,#0xFD0000
   \   000007C4   0x6AA1             LDR      R1,[R4, #+40]
   \   000007C6   0x4308             ORRS     R0,R1,R0
   \   000007C8   0x6AE1             LDR      R1,[R4, #+44]
   \   000007CA   0x4308             ORRS     R0,R1,R0
   \   000007CC   0x6B21             LDR      R1,[R4, #+48]
   \   000007CE   0x4308             ORRS     R0,R1,R0
   \   000007D0   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x40023808
   \   000007D4   0x6008             STR      R0,[R1, #+0]
    681                  /* Enable the main PLL. */
    682                  __HAL_RCC_PLL_ENABLE();
   \   000007D6   0x2001             MOVS     R0,#+1
   \   000007D8   0x2180             MOVS     R1,#+128
   \   000007DA   0xFAB1 0xF181      CLZ      R1,R1
   \   000007DE   0x.... 0x....      LDR.W    R2,??DataTable13  ;; 0x42470000
   \   000007E2   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
    683                  
    684                  /* Get Start Tick */
    685                  tickstart = HAL_GetTick();
   \   000007E6   0x.... 0x....      BL       HAL_GetTick
   \   000007EA   0x0005             MOVS     R5,R0
    686                  
    687                  /* Wait till PLL is ready */
    688                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
   \                     ??HAL_RCC_OscConfig_70: (+1)
   \   000007EC   0x2040             MOVS     R0,#+64
   \   000007EE   0xFAB0 0xF080      CLZ      R0,R0
   \   000007F2   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000007F6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000007F8   0x0940             LSRS     R0,R0,#+5
   \   000007FA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000007FC   0x2801             CMP      R0,#+1
   \   000007FE   0xD103             BNE.N    ??HAL_RCC_OscConfig_71
   \   00000800   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x40023800
   \   00000804   0x6800             LDR      R0,[R0, #+0]
   \   00000806   0xE002             B.N      ??HAL_RCC_OscConfig_72
   \                     ??HAL_RCC_OscConfig_71: (+1)
   \   00000808   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   0000080C   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_72: (+1)
   \   0000080E   0x2140             MOVS     R1,#+64
   \   00000810   0xFAB1 0xF181      CLZ      R1,R1
   \   00000814   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000818   0x40C8             LSRS     R0,R0,R1
   \   0000081A   0x07C0             LSLS     R0,R0,#+31
   \   0000081C   0xD433             BMI.N    ??HAL_RCC_OscConfig_63
    689                  {
    690                    if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
   \   0000081E   0x.... 0x....      BL       HAL_GetTick
   \   00000822   0x1B40             SUBS     R0,R0,R5
   \   00000824   0x2803             CMP      R0,#+3
   \   00000826   0xD3E1             BCC.N    ??HAL_RCC_OscConfig_70
    691                    {
    692                      return HAL_TIMEOUT;
   \   00000828   0x2003             MOVS     R0,#+3
   \   0000082A   0xE02D             B.N      ??HAL_RCC_OscConfig_5
    693                    }
    694                  }
    695                }
    696                else
    697                {
    698                  /* Disable the main PLL. */
    699                  __HAL_RCC_PLL_DISABLE();
   \                     ??HAL_RCC_OscConfig_65: (+1)
   \   0000082C   0x2000             MOVS     R0,#+0
   \   0000082E   0x2180             MOVS     R1,#+128
   \   00000830   0xFAB1 0xF181      CLZ      R1,R1
   \   00000834   0x.... 0x....      LDR.W    R2,??DataTable13  ;; 0x42470000
   \   00000838   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
    700           
    701                  /* Get Start Tick */
    702                  tickstart = HAL_GetTick();
   \   0000083C   0x.... 0x....      BL       HAL_GetTick
   \   00000840   0x0005             MOVS     R5,R0
    703                  
    704                  /* Wait till PLL is disabled */  
    705                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
   \                     ??HAL_RCC_OscConfig_73: (+1)
   \   00000842   0x2040             MOVS     R0,#+64
   \   00000844   0xFAB0 0xF080      CLZ      R0,R0
   \   00000848   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000084C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000084E   0x0940             LSRS     R0,R0,#+5
   \   00000850   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000852   0x2801             CMP      R0,#+1
   \   00000854   0xD103             BNE.N    ??HAL_RCC_OscConfig_74
   \   00000856   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x40023800
   \   0000085A   0x6800             LDR      R0,[R0, #+0]
   \   0000085C   0xE002             B.N      ??HAL_RCC_OscConfig_75
   \                     ??HAL_RCC_OscConfig_74: (+1)
   \   0000085E   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   00000862   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_75: (+1)
   \   00000864   0x2140             MOVS     R1,#+64
   \   00000866   0xFAB1 0xF181      CLZ      R1,R1
   \   0000086A   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   0000086E   0x40C8             LSRS     R0,R0,R1
   \   00000870   0x07C0             LSLS     R0,R0,#+31
   \   00000872   0xD508             BPL.N    ??HAL_RCC_OscConfig_63
    706                  {
    707                    if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
   \   00000874   0x.... 0x....      BL       HAL_GetTick
   \   00000878   0x1B40             SUBS     R0,R0,R5
   \   0000087A   0x2803             CMP      R0,#+3
   \   0000087C   0xD3E1             BCC.N    ??HAL_RCC_OscConfig_73
    708                    {
    709                      return HAL_TIMEOUT;
   \   0000087E   0x2003             MOVS     R0,#+3
   \   00000880   0xE002             B.N      ??HAL_RCC_OscConfig_5
    710                    }
    711                  }
    712                }
    713              }
    714              else
    715              {
    716                return HAL_ERROR;
   \                     ??HAL_RCC_OscConfig_64: (+1)
   \   00000882   0x2001             MOVS     R0,#+1
   \   00000884   0xE000             B.N      ??HAL_RCC_OscConfig_5
    717              }
    718            }
    719            
    720            return HAL_OK;
   \                     ??HAL_RCC_OscConfig_63: (+1)
   \   00000886   0x2000             MOVS     R0,#+0
   \                     ??HAL_RCC_OscConfig_5: (+1)
   \   00000888   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    721          }
    722          
    723          /**
    724            * @brief  Initializes the CPU, AHB and APB buses clocks according to the specified 
    725            *         parameters in the RCC_ClkInitStruct.
    726            * @param  RCC_ClkInitStruct pointer to an RCC_OscInitTypeDef structure that
    727            *         contains the configuration information for the RCC peripheral.
    728            * @param  FLatency FLASH Latency                   
    729            *          The value of this parameter depend on device used within the same series
    730            * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency 
    731            *         and updated by @ref HAL_RCC_GetHCLKFreq() function called within this function
    732            *
    733            * @note   The MSI is used (enabled by hardware) as system clock source after
    734            *         start-up from Reset, wake-up from STOP and STANDBY mode, or in case
    735            *         of failure of the HSE used directly or indirectly as system clock
    736            *         (if the Clock Security System CSS is enabled).
    737            *           
    738            * @note   A switch from one clock source to another occurs only if the target
    739            *         clock source is ready (clock stable after start-up delay or PLL locked). 
    740            *         If a clock source which is not yet ready is selected, the switch will
    741            *         occur when the clock source will be ready. 
    742            *         You can use @ref HAL_RCC_GetClockConfig() function to know which clock is
    743            *         currently used as system clock source.
    744            * @note   Depending on the device voltage range, the software has to set correctly
    745            *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
    746            *         (for more details refer to section above "Initialization/de-initialization functions")
    747            * @retval HAL status
    748            */

   \                                 In section .text, align 2, keep-with-next
    749          HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
    750          {
   \                     HAL_RCC_ClockConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    751            uint32_t tickstart = 0U;
   \   00000006   0x2600             MOVS     R6,#+0
    752            
    753            /* Check the parameters */
    754            assert_param(RCC_ClkInitStruct != NULL);
    755            assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
    756            assert_param(IS_FLASH_LATENCY(FLatency));
    757          
    758            /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
    759            must be correctly programmed according to the frequency of the CPU clock 
    760            (HCLK) and the supply voltage of the device. */
    761          
    762            /* Increasing the number of wait states because of higher CPU frequency */
    763            if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable13_5  ;; 0x40023c00
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000012   0x42A8             CMP      R0,R5
   \   00000014   0xD21B             BCS.N    ??HAL_RCC_ClockConfig_0
    764            {    
    765              /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    766              __HAL_FLASH_SET_LATENCY(FLatency);
   \   00000016   0x2D01             CMP      R5,#+1
   \   00000018   0xD107             BNE.N    ??HAL_RCC_ClockConfig_1
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable13_5  ;; 0x40023c00
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable13_5  ;; 0x40023c00
   \   00000028   0x6008             STR      R0,[R1, #+0]
   \                     ??HAL_RCC_ClockConfig_1: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable13_5  ;; 0x40023c00
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x0840             LSRS     R0,R0,#+1
   \   00000032   0x0040             LSLS     R0,R0,#+1
   \   00000034   0x4328             ORRS     R0,R5,R0
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable13_5  ;; 0x40023c00
   \   0000003A   0x6008             STR      R0,[R1, #+0]
    767              
    768              /* Check that the new number of wait states is taken into account to access the Flash
    769              memory by reading the FLASH_ACR register */
    770              if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable13_5  ;; 0x40023c00
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000046   0x42A8             CMP      R0,R5
   \   00000048   0xD001             BEQ.N    ??HAL_RCC_ClockConfig_0
    771              {
    772                return HAL_ERROR;
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0xE126             B.N      ??HAL_RCC_ClockConfig_2
    773              }
    774            }
    775          
    776            /*-------------------------- HCLK Configuration --------------------------*/
    777            if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
   \                     ??HAL_RCC_ClockConfig_0: (+1)
   \   0000004E   0x7820             LDRB     R0,[R4, #+0]
   \   00000050   0x0780             LSLS     R0,R0,#+30
   \   00000052   0xD509             BPL.N    ??HAL_RCC_ClockConfig_3
    778            {
    779              assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    780              MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40023808
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0xF030 0x00F0      BICS     R0,R0,#0xF0
   \   0000005E   0x68A1             LDR      R1,[R4, #+8]
   \   00000060   0x4308             ORRS     R0,R1,R0
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x40023808
   \   00000066   0x6008             STR      R0,[R1, #+0]
    781            }
    782          
    783            /*------------------------- SYSCLK Configuration ---------------------------*/ 
    784            if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
   \                     ??HAL_RCC_ClockConfig_3: (+1)
   \   00000068   0x7820             LDRB     R0,[R4, #+0]
   \   0000006A   0x07C0             LSLS     R0,R0,#+31
   \   0000006C   0xF140 0x80C6      BPL.W    ??HAL_RCC_ClockConfig_4
    785            {    
    786              assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
    787              
    788              /* HSE is selected as System Clock Source */
    789              if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
   \   00000070   0x6860             LDR      R0,[R4, #+4]
   \   00000072   0x2802             CMP      R0,#+2
   \   00000074   0xD11B             BNE.N    ??HAL_RCC_ClockConfig_5
    790              {
    791                /* Check the HSE ready flag */  
    792                if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
   \   00000076   0xF44F 0x4080      MOV      R0,#+16384
   \   0000007A   0xFAB0 0xF080      CLZ      R0,R0
   \   0000007E   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000082   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000084   0x0940             LSRS     R0,R0,#+5
   \   00000086   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000088   0x2801             CMP      R0,#+1
   \   0000008A   0xD102             BNE.N    ??HAL_RCC_ClockConfig_6
   \   0000008C   0x....             LDR.N    R0,??DataTable8  ;; 0x40023800
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0xE002             B.N      ??HAL_RCC_ClockConfig_7
   \                     ??HAL_RCC_ClockConfig_6: (+1)
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   00000096   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_ClockConfig_7: (+1)
   \   00000098   0xF44F 0x4180      MOV      R1,#+16384
   \   0000009C   0xFAB1 0xF181      CLZ      R1,R1
   \   000000A0   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000000A4   0x40C8             LSRS     R0,R0,R1
   \   000000A6   0x07C0             LSLS     R0,R0,#+31
   \   000000A8   0xD459             BMI.N    ??HAL_RCC_ClockConfig_8
    793                {
    794                  return HAL_ERROR;
   \   000000AA   0x2001             MOVS     R0,#+1
   \   000000AC   0xE0F6             B.N      ??HAL_RCC_ClockConfig_2
    795                }
    796              }
    797              /* PLL is selected as System Clock Source */
    798              else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
   \                     ??HAL_RCC_ClockConfig_5: (+1)
   \   000000AE   0x6860             LDR      R0,[R4, #+4]
   \   000000B0   0x2803             CMP      R0,#+3
   \   000000B2   0xD119             BNE.N    ??HAL_RCC_ClockConfig_9
    799              {
    800                /* Check the PLL ready flag */  
    801                if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
   \   000000B4   0x2040             MOVS     R0,#+64
   \   000000B6   0xFAB0 0xF080      CLZ      R0,R0
   \   000000BA   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000000BE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C0   0x0940             LSRS     R0,R0,#+5
   \   000000C2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C4   0x2801             CMP      R0,#+1
   \   000000C6   0xD102             BNE.N    ??HAL_RCC_ClockConfig_10
   \   000000C8   0x....             LDR.N    R0,??DataTable8  ;; 0x40023800
   \   000000CA   0x6800             LDR      R0,[R0, #+0]
   \   000000CC   0xE002             B.N      ??HAL_RCC_ClockConfig_11
   \                     ??HAL_RCC_ClockConfig_10: (+1)
   \   000000CE   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   000000D2   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_ClockConfig_11: (+1)
   \   000000D4   0x2140             MOVS     R1,#+64
   \   000000D6   0xFAB1 0xF181      CLZ      R1,R1
   \   000000DA   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000000DE   0x40C8             LSRS     R0,R0,R1
   \   000000E0   0x07C0             LSLS     R0,R0,#+31
   \   000000E2   0xD43C             BMI.N    ??HAL_RCC_ClockConfig_8
    802                {
    803                  return HAL_ERROR;
   \   000000E4   0x2001             MOVS     R0,#+1
   \   000000E6   0xE0D9             B.N      ??HAL_RCC_ClockConfig_2
    804                }
    805              }
    806              /* HSI is selected as System Clock Source */
    807              else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
   \                     ??HAL_RCC_ClockConfig_9: (+1)
   \   000000E8   0x6860             LDR      R0,[R4, #+4]
   \   000000EA   0x2801             CMP      R0,#+1
   \   000000EC   0xD11B             BNE.N    ??HAL_RCC_ClockConfig_12
    808              {
    809                /* Check the HSI ready flag */  
    810                if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
   \   000000EE   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   000000F2   0xFAB0 0xF080      CLZ      R0,R0
   \   000000F6   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000000FA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000FC   0x0940             LSRS     R0,R0,#+5
   \   000000FE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000100   0x2801             CMP      R0,#+1
   \   00000102   0xD102             BNE.N    ??HAL_RCC_ClockConfig_13
   \   00000104   0x....             LDR.N    R0,??DataTable8  ;; 0x40023800
   \   00000106   0x6800             LDR      R0,[R0, #+0]
   \   00000108   0xE002             B.N      ??HAL_RCC_ClockConfig_14
   \                     ??HAL_RCC_ClockConfig_13: (+1)
   \   0000010A   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   0000010E   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_ClockConfig_14: (+1)
   \   00000110   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   00000114   0xFAB1 0xF181      CLZ      R1,R1
   \   00000118   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   0000011C   0x40C8             LSRS     R0,R0,R1
   \   0000011E   0x07C0             LSLS     R0,R0,#+31
   \   00000120   0xD41D             BMI.N    ??HAL_RCC_ClockConfig_8
    811                {
    812                  return HAL_ERROR;
   \   00000122   0x2001             MOVS     R0,#+1
   \   00000124   0xE0BA             B.N      ??HAL_RCC_ClockConfig_2
    813                }
    814              }
    815              /* MSI is selected as System Clock Source */
    816              else
    817              {
    818                /* Check the MSI ready flag */  
    819                if(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
   \                     ??HAL_RCC_ClockConfig_12: (+1)
   \   00000126   0xF45F 0x0080      MOVS     R0,#+4194304
   \   0000012A   0xFAB0 0xF080      CLZ      R0,R0
   \   0000012E   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000132   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000134   0x0940             LSRS     R0,R0,#+5
   \   00000136   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000138   0x2801             CMP      R0,#+1
   \   0000013A   0xD102             BNE.N    ??HAL_RCC_ClockConfig_15
   \   0000013C   0x....             LDR.N    R0,??DataTable8  ;; 0x40023800
   \   0000013E   0x6800             LDR      R0,[R0, #+0]
   \   00000140   0xE002             B.N      ??HAL_RCC_ClockConfig_16
   \                     ??HAL_RCC_ClockConfig_15: (+1)
   \   00000142   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40023834
   \   00000146   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_ClockConfig_16: (+1)
   \   00000148   0xF45F 0x0180      MOVS     R1,#+4194304
   \   0000014C   0xFAB1 0xF181      CLZ      R1,R1
   \   00000150   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000154   0x40C8             LSRS     R0,R0,R1
   \   00000156   0x07C0             LSLS     R0,R0,#+31
   \   00000158   0xD401             BMI.N    ??HAL_RCC_ClockConfig_8
    820                {
    821                  return HAL_ERROR;
   \   0000015A   0x2001             MOVS     R0,#+1
   \   0000015C   0xE09E             B.N      ??HAL_RCC_ClockConfig_2
    822                }
    823              }
    824              __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
   \                     ??HAL_RCC_ClockConfig_8: (+1)
   \   0000015E   0x....             LDR.N    R0,??DataTable9  ;; 0x40023808
   \   00000160   0x6800             LDR      R0,[R0, #+0]
   \   00000162   0x0880             LSRS     R0,R0,#+2
   \   00000164   0x0080             LSLS     R0,R0,#+2
   \   00000166   0x6861             LDR      R1,[R4, #+4]
   \   00000168   0x4308             ORRS     R0,R1,R0
   \   0000016A   0x....             LDR.N    R1,??DataTable9  ;; 0x40023808
   \   0000016C   0x6008             STR      R0,[R1, #+0]
    825          
    826              /* Get Start Tick */
    827              tickstart = HAL_GetTick();
   \   0000016E   0x.... 0x....      BL       HAL_GetTick
   \   00000172   0x0006             MOVS     R6,R0
    828              
    829              if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
   \   00000174   0x6860             LDR      R0,[R4, #+4]
   \   00000176   0x2802             CMP      R0,#+2
   \   00000178   0xD10E             BNE.N    ??HAL_RCC_ClockConfig_17
    830              {
    831                while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
   \                     ??HAL_RCC_ClockConfig_18: (+1)
   \   0000017A   0x....             LDR.N    R0,??DataTable9  ;; 0x40023808
   \   0000017C   0x6800             LDR      R0,[R0, #+0]
   \   0000017E   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   00000182   0x2808             CMP      R0,#+8
   \   00000184   0xD03A             BEQ.N    ??HAL_RCC_ClockConfig_4
    832                {
    833                  if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
   \   00000186   0x.... 0x....      BL       HAL_GetTick
   \   0000018A   0x1B80             SUBS     R0,R0,R6
   \   0000018C   0xF241 0x3189      MOVW     R1,#+5001
   \   00000190   0x4288             CMP      R0,R1
   \   00000192   0xD3F2             BCC.N    ??HAL_RCC_ClockConfig_18
    834                  {
    835                    return HAL_TIMEOUT;
   \   00000194   0x2003             MOVS     R0,#+3
   \   00000196   0xE081             B.N      ??HAL_RCC_ClockConfig_2
    836                  }
    837                }
    838              }
    839              else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
   \                     ??HAL_RCC_ClockConfig_17: (+1)
   \   00000198   0x6860             LDR      R0,[R4, #+4]
   \   0000019A   0x2803             CMP      R0,#+3
   \   0000019C   0xD10E             BNE.N    ??HAL_RCC_ClockConfig_19
    840              {
    841                while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
   \                     ??HAL_RCC_ClockConfig_20: (+1)
   \   0000019E   0x....             LDR.N    R0,??DataTable9  ;; 0x40023808
   \   000001A0   0x6800             LDR      R0,[R0, #+0]
   \   000001A2   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   000001A6   0x280C             CMP      R0,#+12
   \   000001A8   0xD028             BEQ.N    ??HAL_RCC_ClockConfig_4
    842                {
    843                  if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
   \   000001AA   0x.... 0x....      BL       HAL_GetTick
   \   000001AE   0x1B80             SUBS     R0,R0,R6
   \   000001B0   0xF241 0x3189      MOVW     R1,#+5001
   \   000001B4   0x4288             CMP      R0,R1
   \   000001B6   0xD3F2             BCC.N    ??HAL_RCC_ClockConfig_20
    844                  {
    845                    return HAL_TIMEOUT;
   \   000001B8   0x2003             MOVS     R0,#+3
   \   000001BA   0xE06F             B.N      ??HAL_RCC_ClockConfig_2
    846                  }
    847                }
    848              }
    849              else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
   \                     ??HAL_RCC_ClockConfig_19: (+1)
   \   000001BC   0x6860             LDR      R0,[R4, #+4]
   \   000001BE   0x2801             CMP      R0,#+1
   \   000001C0   0xD10E             BNE.N    ??HAL_RCC_ClockConfig_21
    850              {
    851                while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
   \                     ??HAL_RCC_ClockConfig_22: (+1)
   \   000001C2   0x....             LDR.N    R0,??DataTable9  ;; 0x40023808
   \   000001C4   0x6800             LDR      R0,[R0, #+0]
   \   000001C6   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   000001CA   0x2804             CMP      R0,#+4
   \   000001CC   0xD016             BEQ.N    ??HAL_RCC_ClockConfig_4
    852                {
    853                  if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
   \   000001CE   0x.... 0x....      BL       HAL_GetTick
   \   000001D2   0x1B80             SUBS     R0,R0,R6
   \   000001D4   0xF241 0x3189      MOVW     R1,#+5001
   \   000001D8   0x4288             CMP      R0,R1
   \   000001DA   0xD3F2             BCC.N    ??HAL_RCC_ClockConfig_22
    854                  {
    855                    return HAL_TIMEOUT;
   \   000001DC   0x2003             MOVS     R0,#+3
   \   000001DE   0xE05D             B.N      ??HAL_RCC_ClockConfig_2
    856                  }
    857                }
    858              }      
    859              else
    860              {
    861                while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
   \                     ??HAL_RCC_ClockConfig_21: (+1)
   \   000001E0   0x....             LDR.N    R0,??DataTable9  ;; 0x40023808
   \   000001E2   0x6800             LDR      R0,[R0, #+0]
   \   000001E4   0xF010 0x0F0C      TST      R0,#0xC
   \   000001E8   0xD008             BEQ.N    ??HAL_RCC_ClockConfig_4
    862                {
    863                  if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
   \   000001EA   0x.... 0x....      BL       HAL_GetTick
   \   000001EE   0x1B80             SUBS     R0,R0,R6
   \   000001F0   0xF241 0x3189      MOVW     R1,#+5001
   \   000001F4   0x4288             CMP      R0,R1
   \   000001F6   0xD3F3             BCC.N    ??HAL_RCC_ClockConfig_21
    864                  {
    865                    return HAL_TIMEOUT;
   \   000001F8   0x2003             MOVS     R0,#+3
   \   000001FA   0xE04F             B.N      ??HAL_RCC_ClockConfig_2
    866                  }
    867                }
    868              }
    869            }    
    870            /* Decreasing the number of wait states because of lower CPU frequency */
    871            if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
   \                     ??HAL_RCC_ClockConfig_4: (+1)
   \   000001FC   0x.... 0x....      LDR.W    R0,??DataTable13_5  ;; 0x40023c00
   \   00000200   0x6800             LDR      R0,[R0, #+0]
   \   00000202   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000206   0x4285             CMP      R5,R0
   \   00000208   0xD21B             BCS.N    ??HAL_RCC_ClockConfig_23
    872            {    
    873              /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    874              __HAL_FLASH_SET_LATENCY(FLatency);
   \   0000020A   0x2D01             CMP      R5,#+1
   \   0000020C   0xD107             BNE.N    ??HAL_RCC_ClockConfig_24
   \   0000020E   0x.... 0x....      LDR.W    R0,??DataTable13_5  ;; 0x40023c00
   \   00000212   0x6800             LDR      R0,[R0, #+0]
   \   00000214   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000218   0x.... 0x....      LDR.W    R1,??DataTable13_5  ;; 0x40023c00
   \   0000021C   0x6008             STR      R0,[R1, #+0]
   \                     ??HAL_RCC_ClockConfig_24: (+1)
   \   0000021E   0x.... 0x....      LDR.W    R0,??DataTable13_5  ;; 0x40023c00
   \   00000222   0x6800             LDR      R0,[R0, #+0]
   \   00000224   0x0840             LSRS     R0,R0,#+1
   \   00000226   0x0040             LSLS     R0,R0,#+1
   \   00000228   0x4328             ORRS     R0,R5,R0
   \   0000022A   0x.... 0x....      LDR.W    R1,??DataTable13_5  ;; 0x40023c00
   \   0000022E   0x6008             STR      R0,[R1, #+0]
    875              
    876              /* Check that the new number of wait states is taken into account to access the Flash
    877              memory by reading the FLASH_ACR register */
    878              if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
   \   00000230   0x.... 0x....      LDR.W    R0,??DataTable13_5  ;; 0x40023c00
   \   00000234   0x6800             LDR      R0,[R0, #+0]
   \   00000236   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000023A   0x42A8             CMP      R0,R5
   \   0000023C   0xD001             BEQ.N    ??HAL_RCC_ClockConfig_23
    879              {
    880                return HAL_ERROR;
   \   0000023E   0x2001             MOVS     R0,#+1
   \   00000240   0xE02C             B.N      ??HAL_RCC_ClockConfig_2
    881              }
    882            }    
    883          
    884            /*-------------------------- PCLK1 Configuration ---------------------------*/ 
    885            if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
   \                     ??HAL_RCC_ClockConfig_23: (+1)
   \   00000242   0x7820             LDRB     R0,[R4, #+0]
   \   00000244   0x0740             LSLS     R0,R0,#+29
   \   00000246   0xD507             BPL.N    ??HAL_RCC_ClockConfig_25
    886            {
    887              assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    888              MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
   \   00000248   0x....             LDR.N    R0,??DataTable9  ;; 0x40023808
   \   0000024A   0x6800             LDR      R0,[R0, #+0]
   \   0000024C   0xF430 0x60E0      BICS     R0,R0,#0x700
   \   00000250   0x68E1             LDR      R1,[R4, #+12]
   \   00000252   0x4308             ORRS     R0,R1,R0
   \   00000254   0x....             LDR.N    R1,??DataTable9  ;; 0x40023808
   \   00000256   0x6008             STR      R0,[R1, #+0]
    889            }
    890            
    891            /*-------------------------- PCLK2 Configuration ---------------------------*/ 
    892            if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
   \                     ??HAL_RCC_ClockConfig_25: (+1)
   \   00000258   0x7820             LDRB     R0,[R4, #+0]
   \   0000025A   0x0700             LSLS     R0,R0,#+28
   \   0000025C   0xD508             BPL.N    ??HAL_RCC_ClockConfig_26
    893            {
    894              assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    895              MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
   \   0000025E   0x....             LDR.N    R0,??DataTable9  ;; 0x40023808
   \   00000260   0x6800             LDR      R0,[R0, #+0]
   \   00000262   0xF430 0x5060      BICS     R0,R0,#0x3800
   \   00000266   0x6921             LDR      R1,[R4, #+16]
   \   00000268   0xEA50 0x00C1      ORRS     R0,R0,R1, LSL #+3
   \   0000026C   0x....             LDR.N    R1,??DataTable9  ;; 0x40023808
   \   0000026E   0x6008             STR      R0,[R1, #+0]
    896            }
    897           
    898            /* Update the SystemCoreClock global variable */
    899            SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_BITNUMBER];
   \                     ??HAL_RCC_ClockConfig_26: (+1)
   \   00000270   0x.... 0x....      BL       HAL_RCC_GetSysClockFreq
   \   00000274   0x....             LDR.N    R1,??DataTable9  ;; 0x40023808
   \   00000276   0x6809             LDR      R1,[R1, #+0]
   \   00000278   0xF05F 0x6270      MOVS     R2,#+251658240
   \   0000027C   0xFAB2 0xF282      CLZ      R2,R2
   \   00000280   0x.... 0x....      LDR.W    R3,??DataTable13_1
   \   00000284   0xF011 0x01F0      ANDS     R1,R1,#0xF0
   \   00000288   0x40D1             LSRS     R1,R1,R2
   \   0000028A   0x5CC9             LDRB     R1,[R1, R3]
   \   0000028C   0x40C8             LSRS     R0,R0,R1
   \   0000028E   0x.... 0x....      LDR.W    R1,??DataTable13_6
   \   00000292   0x6008             STR      R0,[R1, #+0]
    900          
    901            /* Configure the source of time base considering new system clocks settings*/
    902            HAL_InitTick (TICK_INT_PRIORITY);
   \   00000294   0x200F             MOVS     R0,#+15
   \   00000296   0x.... 0x....      BL       HAL_InitTick
    903            
    904            return HAL_OK;
   \   0000029A   0x2000             MOVS     R0,#+0
   \                     ??HAL_RCC_ClockConfig_2: (+1)
   \   0000029C   0xBD70             POP      {R4-R6,PC}       ;; return
    905          }
    906          
    907          /**
    908            * @}
    909            */
    910          
    911          /** @defgroup RCC_Exported_Functions_Group2 Peripheral Control functions
    912            *  @brief   RCC clocks control functions
    913            *
    914            @verbatim   
    915            ===============================================================================
    916                            ##### Peripheral Control functions #####
    917            ===============================================================================  
    918              [..]
    919              This subsection provides a set of functions allowing to control the RCC Clocks 
    920              frequencies.
    921          
    922            @endverbatim
    923            * @{
    924            */
    925          
    926          /**
    927            * @brief  Selects the clock source to output on MCO pin.
    928            * @note   MCO pin should be configured in alternate function mode.
    929            * @param  RCC_MCOx specifies the output direction for the clock source.
    930            *          This parameter can be one of the following values:
    931            *            @arg @ref RCC_MCO1 Clock source to output on MCO1 pin(PA8).
    932            * @param  RCC_MCOSource specifies the clock source to output.
    933            *          This parameter can be one of the following values:
    934            *            @arg @ref RCC_MCO1SOURCE_NOCLOCK     No clock selected as MCO clock
    935            *            @arg @ref RCC_MCO1SOURCE_SYSCLK      System clock selected as MCO clock
    936            *            @arg @ref RCC_MCO1SOURCE_HSI         HSI selected as MCO clock
    937            *            @arg @ref RCC_MCO1SOURCE_HSE         HSE selected as MCO clock
    938            *            @arg @ref RCC_MCO1SOURCE_MSI         MSI oscillator clock selected as MCO clock 
    939            *            @arg @ref RCC_MCO1SOURCE_PLLCLK      PLL clock selected as MCO clock
    940            *            @arg @ref RCC_MCO1SOURCE_LSI         LSI clock selected as MCO clock
    941            *            @arg @ref RCC_MCO1SOURCE_LSE         LSE clock selected as MCO clock
    942            * @param  RCC_MCODiv specifies the MCO DIV.
    943            *          This parameter can be one of the following values:
    944            *            @arg @ref RCC_MCODIV_1 no division applied to MCO clock
    945            *            @arg @ref RCC_MCODIV_2  division by 2 applied to MCO clock
    946            *            @arg @ref RCC_MCODIV_4  division by 4 applied to MCO clock
    947            *            @arg @ref RCC_MCODIV_8  division by 8 applied to MCO clock
    948            *            @arg @ref RCC_MCODIV_16 division by 16 applied to MCO clock
    949            * @retval None
    950            */

   \                                 In section .text, align 2, keep-with-next
    951          void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
    952          {
   \                     HAL_RCC_MCOConfig: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x0015             MOVS     R5,R2
    953            GPIO_InitTypeDef gpio = {0};
   \   00000008   0xA801             ADD      R0,SP,#+4
   \   0000000A   0x2114             MOVS     R1,#+20
   \   0000000C   0x.... 0x....      BL       __aeabi_memclr4
    954          
    955            /* Check the parameters */
    956            assert_param(IS_RCC_MCO(RCC_MCOx));
    957            assert_param(IS_RCC_MCODIV(RCC_MCODiv));
    958            assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));
    959            
    960            /* Configure the MCO1 pin in alternate function mode */
    961            gpio.Mode      = GPIO_MODE_AF_PP;
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0x9002             STR      R0,[SP, #+8]
    962            gpio.Speed     = GPIO_SPEED_FREQ_HIGH;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0x9004             STR      R0,[SP, #+16]
    963            gpio.Pull      = GPIO_NOPULL;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x9003             STR      R0,[SP, #+12]
    964            gpio.Pin       = MCO1_PIN;
   \   0000001C   0xF44F 0x7080      MOV      R0,#+256
   \   00000020   0x9001             STR      R0,[SP, #+4]
    965            gpio.Alternate = GPIO_AF0_MCO;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x9005             STR      R0,[SP, #+20]
    966          
    967            /* MCO1 Clock Enable */
    968            MCO1_CLK_ENABLE();
   \   00000026   0x....             LDR.N    R0,??DataTable13_7  ;; 0x4002381c
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000002E   0x....             LDR.N    R1,??DataTable13_7  ;; 0x4002381c
   \   00000030   0x6008             STR      R0,[R1, #+0]
   \   00000032   0x....             LDR.N    R0,??DataTable13_7  ;; 0x4002381c
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000003A   0x9000             STR      R0,[SP, #+0]
   \   0000003C   0x9800             LDR      R0,[SP, #+0]
    969            
    970            HAL_GPIO_Init(MCO1_GPIO_PORT, &gpio);
   \   0000003E   0xA901             ADD      R1,SP,#+4
   \   00000040   0x....             LDR.N    R0,??DataTable13_8  ;; 0x40020000
   \   00000042   0x.... 0x....      BL       HAL_GPIO_Init
    971            
    972            /* Configure the MCO clock source */
    973            __HAL_RCC_MCO1_CONFIG(RCC_MCOSource, RCC_MCODiv);
   \   00000046   0x....             LDR.N    R0,??DataTable13_9  ;; 0x40023808
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xF030 0x40EE      BICS     R0,R0,#0x77000000
   \   0000004E   0x4320             ORRS     R0,R4,R0
   \   00000050   0x4328             ORRS     R0,R5,R0
   \   00000052   0x....             LDR.N    R1,??DataTable13_9  ;; 0x40023808
   \   00000054   0x6008             STR      R0,[R1, #+0]
    974          }
   \   00000056   0xB007             ADD      SP,SP,#+28
   \   00000058   0xBD30             POP      {R4,R5,PC}       ;; return
    975          
    976          /**
    977            * @brief  Enables the Clock Security System.
    978            * @note   If a failure is detected on the HSE oscillator clock, this oscillator
    979            *         is automatically disabled and an interrupt is generated to inform the
    980            *         software about the failure (Clock Security System Interrupt, CSSI),
    981            *         allowing the MCU to perform rescue operations. The CSSI is linked to 
    982            *         the Cortex-M3 NMI (Non-Maskable Interrupt) exception vector.  
    983            * @retval None
    984            */

   \                                 In section .text, align 2, keep-with-next
    985          void HAL_RCC_EnableCSS(void)
    986          {
    987            *(__IO uint32_t *) RCC_CR_CSSON_BB = (uint32_t)ENABLE;
   \                     HAL_RCC_EnableCSS: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x2108             MOVS     R1,#+8
   \   00000004   0xFAB1 0xF181      CLZ      R1,R1
   \   00000008   0x....             LDR.N    R2,??DataTable13  ;; 0x42470000
   \   0000000A   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
    988          }
   \   0000000E   0x4770             BX       LR               ;; return
    989          
    990          /**
    991            * @brief  Disables the Clock Security System.
    992            * @retval None
    993            */

   \                                 In section .text, align 2, keep-with-next
    994          void HAL_RCC_DisableCSS(void)
    995          {
    996            *(__IO uint32_t *) RCC_CR_CSSON_BB = (uint32_t)DISABLE;
   \                     HAL_RCC_DisableCSS: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x2108             MOVS     R1,#+8
   \   00000004   0xFAB1 0xF181      CLZ      R1,R1
   \   00000008   0x....             LDR.N    R2,??DataTable13  ;; 0x42470000
   \   0000000A   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
    997          }
   \   0000000E   0x4770             BX       LR               ;; return
    998          
    999          /**
   1000            * @brief  Returns the SYSCLK frequency     
   1001            * @note   The system frequency computed by this function is not the real 
   1002            *         frequency in the chip. It is calculated based on the predefined 
   1003            *         constant and the selected clock source:
   1004            * @note     If SYSCLK source is MSI, function returns a value based on MSI
   1005            *             Value as defined by the MSI range.
   1006            * @note     If SYSCLK source is HSI, function returns values based on HSI_VALUE(*)
   1007            * @note     If SYSCLK source is HSE, function returns a value based on HSE_VALUE(**)
   1008            * @note     If SYSCLK source is PLL, function returns a value based on HSE_VALUE(**) 
   1009            *           or HSI_VALUE(*) multiplied/divided by the PLL factors.         
   1010            * @note     (*) HSI_VALUE is a constant defined in stm32l1xx_hal_conf.h file (default value
   1011            *               16 MHz) but the real value may vary depending on the variations
   1012            *               in voltage and temperature.
   1013            * @note     (**) HSE_VALUE is a constant defined in stm32l1xx_hal_conf.h file (default value
   1014            *                8 MHz), user has to ensure that HSE_VALUE is same as the real
   1015            *                frequency of the crystal used. Otherwise, this function may
   1016            *                have wrong result.
   1017            *                  
   1018            * @note   The result of this function could be not correct when using fractional
   1019            *         value for HSE crystal.
   1020            *           
   1021            * @note   This function can be used by the user application to compute the 
   1022            *         baud-rate for the communication peripherals or configure other parameters.
   1023            *           
   1024            * @note   Each time SYSCLK changes, this function must be called to update the
   1025            *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
   1026            *         
   1027            * @retval SYSCLK frequency
   1028            */

   \                                 In section .text, align 2, keep-with-next
   1029          uint32_t HAL_RCC_GetSysClockFreq(void)
   1030          {
   1031            uint32_t tmpreg = 0, pllm = 0, plld = 0, pllvco = 0, msiclkrange = 0;
   \                     HAL_RCC_GetSysClockFreq: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x2000             MOVS     R0,#+0
   1032            uint32_t sysclockfreq = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   1033            
   1034            tmpreg = RCC->CFGR;
   \   0000000C   0x....             LDR.N    R0,??DataTable9  ;; 0x40023808
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   1035            
   1036            /* Get SYSCLK source -------------------------------------------------------*/
   1037            switch (tmpreg & RCC_CFGR_SWS)
   \   00000010   0xF010 0x010C      ANDS     R1,R0,#0xC
   \   00000014   0x2904             CMP      R1,#+4
   \   00000016   0xD004             BEQ.N    ??HAL_RCC_GetSysClockFreq_0
   \   00000018   0x2908             CMP      R1,#+8
   \   0000001A   0xD004             BEQ.N    ??HAL_RCC_GetSysClockFreq_1
   \   0000001C   0x290C             CMP      R1,#+12
   \   0000001E   0xD004             BEQ.N    ??HAL_RCC_GetSysClockFreq_2
   \   00000020   0xE022             B.N      ??HAL_RCC_GetSysClockFreq_3
   1038            {
   1039              case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
   1040              {
   1041                sysclockfreq = HSI_VALUE;
   \                     ??HAL_RCC_GetSysClockFreq_0: (+1)
   \   00000022   0x....             LDR.N    R0,??DataTable9_5  ;; 0xf42400
   1042                break;
   \   00000024   0xE030             B.N      ??HAL_RCC_GetSysClockFreq_4
   1043              }
   1044              case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock */
   1045              {
   1046                sysclockfreq = HSE_VALUE;
   \                     ??HAL_RCC_GetSysClockFreq_1: (+1)
   \   00000026   0x....             LDR.N    R0,??DataTable13_10  ;; 0x16e3600
   1047                break;
   \   00000028   0xE02E             B.N      ??HAL_RCC_GetSysClockFreq_4
   1048              }
   1049              case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
   1050              {
   1051                pllm = PLLMulTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_BITNUMBER];
   \                     ??HAL_RCC_GetSysClockFreq_2: (+1)
   \   0000002A   0xF44F 0x5170      MOV      R1,#+15360
   \   0000002E   0xFAB1 0xF181      CLZ      R1,R1
   \   00000032   0x....             LDR.N    R2,??DataTable13_11
   \   00000034   0xF410 0x1370      ANDS     R3,R0,#0x3C0000
   \   00000038   0x40CB             LSRS     R3,R3,R1
   \   0000003A   0x5C99             LDRB     R1,[R3, R2]
   1052                plld = ((uint32_t)(tmpreg & RCC_CFGR_PLLDIV) >> RCC_CFGR_PLLDIV_BITNUMBER) + 1;
   \   0000003C   0xF410 0x0040      ANDS     R0,R0,#0xC00000
   \   00000040   0xF44F 0x7240      MOV      R2,#+768
   \   00000044   0xFAB2 0xF282      CLZ      R2,R2
   \   00000048   0x40D0             LSRS     R0,R0,R2
   \   0000004A   0x1C40             ADDS     R0,R0,#+1
   1053                if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
   \   0000004C   0x....             LDR.N    R2,??DataTable9  ;; 0x40023808
   \   0000004E   0x6812             LDR      R2,[R2, #+0]
   \   00000050   0x03D2             LSLS     R2,R2,#+15
   \   00000052   0xD504             BPL.N    ??HAL_RCC_GetSysClockFreq_5
   1054                {
   1055                  /* HSE used as PLL clock source */
   1056                  pllvco = (HSE_VALUE * pllm) / plld;
   \   00000054   0x....             LDR.N    R2,??DataTable13_10  ;; 0x16e3600
   \   00000056   0x4351             MULS     R1,R2,R1
   \   00000058   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \   0000005C   0xE003             B.N      ??HAL_RCC_GetSysClockFreq_6
   1057                }
   1058                else
   1059                {
   1060                  /* HSI used as PLL clock source */
   1061                  pllvco = (HSI_VALUE * pllm) / plld;
   \                     ??HAL_RCC_GetSysClockFreq_5: (+1)
   \   0000005E   0x....             LDR.N    R2,??DataTable9_5  ;; 0xf42400
   \   00000060   0x4351             MULS     R1,R2,R1
   \   00000062   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   1062                }
   1063                sysclockfreq = pllvco;
   1064                break;
   \                     ??HAL_RCC_GetSysClockFreq_6: (+1)
   \   00000066   0xE00F             B.N      ??HAL_RCC_GetSysClockFreq_4
   1065              }
   1066              case RCC_SYSCLKSOURCE_STATUS_MSI:  /* MSI used as system clock source */
   1067              default: /* MSI used as system clock */
   1068              {
   1069                msiclkrange = (RCC->ICSCR & RCC_ICSCR_MSIRANGE ) >> RCC_ICSCR_MSIRANGE_BITNUMBER;
   \                     ??HAL_RCC_GetSysClockFreq_3: (+1)
   \   00000068   0x....             LDR.N    R0,??DataTable13_12  ;; 0x40023804
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0xF410 0x4060      ANDS     R0,R0,#0xE000
   \   00000070   0xF45F 0x21E0      MOVS     R1,#+458752
   \   00000074   0xFAB1 0xF181      CLZ      R1,R1
   \   00000078   0x40C8             LSRS     R0,R0,R1
   1070                sysclockfreq = (32768 * (1 << (msiclkrange + 1)));
   \   0000007A   0x2101             MOVS     R1,#+1
   \   0000007C   0x1C40             ADDS     R0,R0,#+1
   \   0000007E   0xFA11 0xF000      LSLS     R0,R1,R0
   \   00000082   0xF44F 0x4100      MOV      R1,#+32768
   \   00000086   0x4348             MULS     R0,R1,R0
   1071                break;
   1072              }
   1073            }
   1074            return sysclockfreq;
   \                     ??HAL_RCC_GetSysClockFreq_4: (+1)
   \   00000088   0x4770             BX       LR               ;; return
   1075          }
   1076          
   1077          /**
   1078            * @brief  Returns the HCLK frequency     
   1079            * @note   Each time HCLK changes, this function must be called to update the
   1080            *         right HCLK value. Otherwise, any configuration based on this function will be incorrect.
   1081            * 
   1082            * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency 
   1083            *         and updated within this function
   1084            * @retval HCLK frequency
   1085            */

   \                                 In section .text, align 2, keep-with-next
   1086          uint32_t HAL_RCC_GetHCLKFreq(void)
   1087          {
   1088            return SystemCoreClock;
   \                     HAL_RCC_GetHCLKFreq: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable13_6
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   1089          }
   1090          
   1091          /**
   1092            * @brief  Returns the PCLK1 frequency     
   1093            * @note   Each time PCLK1 changes, this function must be called to update the
   1094            *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
   1095            * @retval PCLK1 frequency
   1096            */

   \                                 In section .text, align 2, keep-with-next
   1097          uint32_t HAL_RCC_GetPCLK1Freq(void)
   1098          {
   \                     HAL_RCC_GetPCLK1Freq: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1099            /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
   1100            return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_BITNUMBER]);
   \   00000002   0x.... 0x....      BL       HAL_RCC_GetHCLKFreq
   \   00000006   0x....             LDR.N    R1,??DataTable9  ;; 0x40023808
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0xF45F 0x0260      MOVS     R2,#+14680064
   \   0000000E   0xFAB2 0xF282      CLZ      R2,R2
   \   00000012   0x....             LDR.N    R3,??DataTable13_13
   \   00000014   0xF411 0x61E0      ANDS     R1,R1,#0x700
   \   00000018   0x40D1             LSRS     R1,R1,R2
   \   0000001A   0x5CC9             LDRB     R1,[R1, R3]
   \   0000001C   0x40C8             LSRS     R0,R0,R1
   \   0000001E   0xBD02             POP      {R1,PC}          ;; return
   1101          }    
   1102          
   1103          /**
   1104            * @brief  Returns the PCLK2 frequency     
   1105            * @note   Each time PCLK2 changes, this function must be called to update the
   1106            *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
   1107            * @retval PCLK2 frequency
   1108            */

   \                                 In section .text, align 2, keep-with-next
   1109          uint32_t HAL_RCC_GetPCLK2Freq(void)
   1110          {
   \                     HAL_RCC_GetPCLK2Freq: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1111            /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
   1112            return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_BITNUMBER]);
   \   00000002   0x.... 0x....      BL       HAL_RCC_GetHCLKFreq
   \   00000006   0x....             LDR.N    R1,??DataTable9  ;; 0x40023808
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0xF45F 0x12E0      MOVS     R2,#+1835008
   \   0000000E   0xFAB2 0xF282      CLZ      R2,R2
   \   00000012   0x....             LDR.N    R3,??DataTable13_13
   \   00000014   0xF411 0x5160      ANDS     R1,R1,#0x3800
   \   00000018   0x40D1             LSRS     R1,R1,R2
   \   0000001A   0x5CC9             LDRB     R1,[R1, R3]
   \   0000001C   0x40C8             LSRS     R0,R0,R1
   \   0000001E   0xBD02             POP      {R1,PC}          ;; return
   1113          } 
   1114          
   1115          /**
   1116            * @brief  Configures the RCC_OscInitStruct according to the internal 
   1117            * RCC configuration registers.
   1118            * @param  RCC_OscInitStruct pointer to an RCC_OscInitTypeDef structure that 
   1119            * will be configured.
   1120            * @retval None
   1121            */

   \                                 In section .text, align 2, keep-with-next
   1122          void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
   1123          {
   1124            /* Check the parameters */
   1125            assert_param(RCC_OscInitStruct != NULL);
   1126          
   1127            /* Set all possible values for the Oscillator type parameter ---------------*/
   1128            RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI  \
   1129                            | RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_MSI;
   \                     HAL_RCC_GetOscConfig: (+1)
   \   00000000   0x211F             MOVS     R1,#+31
   \   00000002   0x6001             STR      R1,[R0, #+0]
   1130          
   1131          
   1132            /* Get the HSE configuration -----------------------------------------------*/
   1133            if((RCC->CR &RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
   \   00000004   0x....             LDR.N    R1,??DataTable13_14  ;; 0x40023800
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x0349             LSLS     R1,R1,#+13
   \   0000000A   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_0
   1134            {
   1135              RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
   \   0000000C   0x2105             MOVS     R1,#+5
   \   0000000E   0x6041             STR      R1,[R0, #+4]
   \   00000010   0xE008             B.N      ??HAL_RCC_GetOscConfig_1
   1136            }
   1137            else if((RCC->CR &RCC_CR_HSEON) == RCC_CR_HSEON)
   \                     ??HAL_RCC_GetOscConfig_0: (+1)
   \   00000012   0x....             LDR.N    R1,??DataTable13_14  ;; 0x40023800
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x03C9             LSLS     R1,R1,#+15
   \   00000018   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_2
   1138            {
   1139              RCC_OscInitStruct->HSEState = RCC_HSE_ON;
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x6041             STR      R1,[R0, #+4]
   \   0000001E   0xE001             B.N      ??HAL_RCC_GetOscConfig_1
   1140            }
   1141            else
   1142            {
   1143              RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
   \                     ??HAL_RCC_GetOscConfig_2: (+1)
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x6041             STR      R1,[R0, #+4]
   1144            }
   1145          
   1146            /* Get the HSI configuration -----------------------------------------------*/
   1147            if((RCC->CR &RCC_CR_HSION) == RCC_CR_HSION)
   \                     ??HAL_RCC_GetOscConfig_1: (+1)
   \   00000024   0x....             LDR.N    R1,??DataTable13_14  ;; 0x40023800
   \   00000026   0x6809             LDR      R1,[R1, #+0]
   \   00000028   0x07C9             LSLS     R1,R1,#+31
   \   0000002A   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_3
   1148            {
   1149              RCC_OscInitStruct->HSIState = RCC_HSI_ON;
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0x60C1             STR      R1,[R0, #+12]
   \   00000030   0xE001             B.N      ??HAL_RCC_GetOscConfig_4
   1150            }
   1151            else
   1152            {
   1153              RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
   \                     ??HAL_RCC_GetOscConfig_3: (+1)
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x60C1             STR      R1,[R0, #+12]
   1154            }
   1155            
   1156            RCC_OscInitStruct->HSICalibrationValue = (uint32_t)((RCC->ICSCR & RCC_ICSCR_HSITRIM) >> POSITION_VAL(RCC_ICSCR_HSITRIM));
   \                     ??HAL_RCC_GetOscConfig_4: (+1)
   \   00000036   0x....             LDR.N    R1,??DataTable13_12  ;; 0x40023804
   \   00000038   0x6809             LDR      R1,[R1, #+0]
   \   0000003A   0xF411 0x51F8      ANDS     R1,R1,#0x1F00
   \   0000003E   0xF45F 0x0278      MOVS     R2,#+16252928
   \   00000042   0xFAB2 0xF282      CLZ      R2,R2
   \   00000046   0x40D1             LSRS     R1,R1,R2
   \   00000048   0x6101             STR      R1,[R0, #+16]
   1157            
   1158            /* Get the MSI configuration -----------------------------------------------*/
   1159            if((RCC->CR &RCC_CR_MSION) == RCC_CR_MSION)
   \   0000004A   0x....             LDR.N    R1,??DataTable13_14  ;; 0x40023800
   \   0000004C   0x6809             LDR      R1,[R1, #+0]
   \   0000004E   0x05C9             LSLS     R1,R1,#+23
   \   00000050   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_5
   1160            {
   1161              RCC_OscInitStruct->MSIState = RCC_MSI_ON;
   \   00000052   0x2101             MOVS     R1,#+1
   \   00000054   0x6181             STR      R1,[R0, #+24]
   \   00000056   0xE001             B.N      ??HAL_RCC_GetOscConfig_6
   1162            }
   1163            else
   1164            {
   1165              RCC_OscInitStruct->MSIState = RCC_MSI_OFF;
   \                     ??HAL_RCC_GetOscConfig_5: (+1)
   \   00000058   0x2100             MOVS     R1,#+0
   \   0000005A   0x6181             STR      R1,[R0, #+24]
   1166            }
   1167            
   1168            RCC_OscInitStruct->MSICalibrationValue = (uint32_t)((RCC->ICSCR & RCC_ICSCR_MSITRIM) >> RCC_ICSCR_MSITRIM_BITNUMBER);
   \                     ??HAL_RCC_GetOscConfig_6: (+1)
   \   0000005C   0x....             LDR.N    R1,??DataTable13_12  ;; 0x40023804
   \   0000005E   0x6809             LDR      R1,[R1, #+0]
   \   00000060   0xF011 0x417F      ANDS     R1,R1,#0xFF000000
   \   00000064   0x22FF             MOVS     R2,#+255
   \   00000066   0xFAB2 0xF282      CLZ      R2,R2
   \   0000006A   0x40D1             LSRS     R1,R1,R2
   \   0000006C   0x61C1             STR      R1,[R0, #+28]
   1169            RCC_OscInitStruct->MSIClockRange = (uint32_t)((RCC->ICSCR & RCC_ICSCR_MSIRANGE));
   \   0000006E   0x....             LDR.N    R1,??DataTable13_12  ;; 0x40023804
   \   00000070   0x6809             LDR      R1,[R1, #+0]
   \   00000072   0xF411 0x4160      ANDS     R1,R1,#0xE000
   \   00000076   0x6201             STR      R1,[R0, #+32]
   1170            
   1171            /* Get the LSE configuration -----------------------------------------------*/
   1172            if((RCC->CSR &RCC_CSR_LSEBYP) == RCC_CSR_LSEBYP)
   \   00000078   0x....             LDR.N    R1,??DataTable12  ;; 0x40023834
   \   0000007A   0x6809             LDR      R1,[R1, #+0]
   \   0000007C   0x0549             LSLS     R1,R1,#+21
   \   0000007E   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_7
   1173            {
   1174              RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
   \   00000080   0x2105             MOVS     R1,#+5
   \   00000082   0x6081             STR      R1,[R0, #+8]
   \   00000084   0xE008             B.N      ??HAL_RCC_GetOscConfig_8
   1175            }
   1176            else if((RCC->CSR &RCC_CSR_LSEON) == RCC_CSR_LSEON)
   \                     ??HAL_RCC_GetOscConfig_7: (+1)
   \   00000086   0x....             LDR.N    R1,??DataTable12  ;; 0x40023834
   \   00000088   0x6809             LDR      R1,[R1, #+0]
   \   0000008A   0x05C9             LSLS     R1,R1,#+23
   \   0000008C   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_9
   1177            {
   1178              RCC_OscInitStruct->LSEState = RCC_LSE_ON;
   \   0000008E   0x2101             MOVS     R1,#+1
   \   00000090   0x6081             STR      R1,[R0, #+8]
   \   00000092   0xE001             B.N      ??HAL_RCC_GetOscConfig_8
   1179            }
   1180            else
   1181            {
   1182              RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
   \                     ??HAL_RCC_GetOscConfig_9: (+1)
   \   00000094   0x2100             MOVS     R1,#+0
   \   00000096   0x6081             STR      R1,[R0, #+8]
   1183            }
   1184            
   1185            /* Get the LSI configuration -----------------------------------------------*/
   1186            if((RCC->CSR &RCC_CSR_LSION) == RCC_CSR_LSION)
   \                     ??HAL_RCC_GetOscConfig_8: (+1)
   \   00000098   0x....             LDR.N    R1,??DataTable12  ;; 0x40023834
   \   0000009A   0x6809             LDR      R1,[R1, #+0]
   \   0000009C   0x07C9             LSLS     R1,R1,#+31
   \   0000009E   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_10
   1187            {
   1188              RCC_OscInitStruct->LSIState = RCC_LSI_ON;
   \   000000A0   0x2101             MOVS     R1,#+1
   \   000000A2   0x6141             STR      R1,[R0, #+20]
   \   000000A4   0xE001             B.N      ??HAL_RCC_GetOscConfig_11
   1189            }
   1190            else
   1191            {
   1192              RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
   \                     ??HAL_RCC_GetOscConfig_10: (+1)
   \   000000A6   0x2100             MOVS     R1,#+0
   \   000000A8   0x6141             STR      R1,[R0, #+20]
   1193            }
   1194            
   1195          
   1196            /* Get the PLL configuration -----------------------------------------------*/
   1197            if((RCC->CR &RCC_CR_PLLON) == RCC_CR_PLLON)
   \                     ??HAL_RCC_GetOscConfig_11: (+1)
   \   000000AA   0x....             LDR.N    R1,??DataTable13_14  ;; 0x40023800
   \   000000AC   0x6809             LDR      R1,[R1, #+0]
   \   000000AE   0x01C9             LSLS     R1,R1,#+7
   \   000000B0   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_12
   1198            {
   1199              RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
   \   000000B2   0x2102             MOVS     R1,#+2
   \   000000B4   0x6241             STR      R1,[R0, #+36]
   \   000000B6   0xE001             B.N      ??HAL_RCC_GetOscConfig_13
   1200            }
   1201            else
   1202            {
   1203              RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
   \                     ??HAL_RCC_GetOscConfig_12: (+1)
   \   000000B8   0x2101             MOVS     R1,#+1
   \   000000BA   0x6241             STR      R1,[R0, #+36]
   1204            }
   1205            RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLSRC);
   \                     ??HAL_RCC_GetOscConfig_13: (+1)
   \   000000BC   0x....             LDR.N    R1,??DataTable13_9  ;; 0x40023808
   \   000000BE   0x6809             LDR      R1,[R1, #+0]
   \   000000C0   0xF411 0x3180      ANDS     R1,R1,#0x10000
   \   000000C4   0x6281             STR      R1,[R0, #+40]
   1206            RCC_OscInitStruct->PLL.PLLMUL = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLMUL);
   \   000000C6   0x....             LDR.N    R1,??DataTable13_9  ;; 0x40023808
   \   000000C8   0x6809             LDR      R1,[R1, #+0]
   \   000000CA   0xF411 0x1170      ANDS     R1,R1,#0x3C0000
   \   000000CE   0x62C1             STR      R1,[R0, #+44]
   1207            RCC_OscInitStruct->PLL.PLLDIV = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLDIV);
   \   000000D0   0x....             LDR.N    R1,??DataTable13_9  ;; 0x40023808
   \   000000D2   0x6809             LDR      R1,[R1, #+0]
   \   000000D4   0xF411 0x0140      ANDS     R1,R1,#0xC00000
   \   000000D8   0x6301             STR      R1,[R0, #+48]
   1208          }
   \   000000DA   0x4770             BX       LR               ;; return
   1209          
   1210          /**
   1211            * @brief  Get the RCC_ClkInitStruct according to the internal 
   1212            * RCC configuration registers.
   1213            * @param  RCC_ClkInitStruct pointer to an RCC_ClkInitTypeDef structure that 
   1214            * contains the current clock configuration.
   1215            * @param  pFLatency Pointer on the Flash Latency.
   1216            * @retval None
   1217            */

   \                                 In section .text, align 2, keep-with-next
   1218          void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
   1219          {
   1220            /* Check the parameters */
   1221            assert_param(RCC_ClkInitStruct != NULL);
   1222            assert_param(pFLatency != NULL);
   1223          
   1224            /* Set all possible values for the Clock type parameter --------------------*/
   1225            RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
   \                     HAL_RCC_GetClockConfig: (+1)
   \   00000000   0x220F             MOVS     R2,#+15
   \   00000002   0x6002             STR      R2,[R0, #+0]
   1226            
   1227            /* Get the SYSCLK configuration --------------------------------------------*/ 
   1228            RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
   \   00000004   0x....             LDR.N    R2,??DataTable13_9  ;; 0x40023808
   \   00000006   0x6812             LDR      R2,[R2, #+0]
   \   00000008   0xF012 0x0203      ANDS     R2,R2,#0x3
   \   0000000C   0x6042             STR      R2,[R0, #+4]
   1229            
   1230            /* Get the HCLK configuration ----------------------------------------------*/ 
   1231            RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE); 
   \   0000000E   0x....             LDR.N    R2,??DataTable13_9  ;; 0x40023808
   \   00000010   0x6812             LDR      R2,[R2, #+0]
   \   00000012   0xF012 0x02F0      ANDS     R2,R2,#0xF0
   \   00000016   0x6082             STR      R2,[R0, #+8]
   1232            
   1233            /* Get the APB1 configuration ----------------------------------------------*/ 
   1234            RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);   
   \   00000018   0x....             LDR.N    R2,??DataTable13_9  ;; 0x40023808
   \   0000001A   0x6812             LDR      R2,[R2, #+0]
   \   0000001C   0xF412 0x62E0      ANDS     R2,R2,#0x700
   \   00000020   0x60C2             STR      R2,[R0, #+12]
   1235            
   1236            /* Get the APB2 configuration ----------------------------------------------*/ 
   1237            RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
   \   00000022   0x....             LDR.N    R2,??DataTable13_9  ;; 0x40023808
   \   00000024   0x6812             LDR      R2,[R2, #+0]
   \   00000026   0x08D2             LSRS     R2,R2,#+3
   \   00000028   0xF412 0x62E0      ANDS     R2,R2,#0x700
   \   0000002C   0x6102             STR      R2,[R0, #+16]
   1238            
   1239            /* Get the Flash Wait State (Latency) configuration ------------------------*/   
   1240            *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY); 
   \   0000002E   0x....             LDR.N    R0,??DataTable13_5  ;; 0x40023c00
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000036   0x6008             STR      R0,[R1, #+0]
   1241          }
   \   00000038   0x4770             BX       LR               ;; return
   1242          
   1243          /**
   1244            * @brief This function handles the RCC CSS interrupt request.
   1245            * @note This API should be called under the NMI_Handler().
   1246            * @retval None
   1247            */

   \                                 In section .text, align 2, keep-with-next
   1248          void HAL_RCC_NMI_IRQHandler(void)
   1249          {
   \                     HAL_RCC_NMI_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1250            /* Check RCC CSSF flag  */
   1251            if(__HAL_RCC_GET_IT(RCC_IT_CSS))
   \   00000002   0x....             LDR.N    R0,??DataTable13_15  ;; 0x4002380c
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x0600             LSLS     R0,R0,#+24
   \   00000008   0xD504             BPL.N    ??HAL_RCC_NMI_IRQHandler_0
   1252            {
   1253              /* RCC Clock Security System interrupt user callback */
   1254              HAL_RCC_CSSCallback();
   \   0000000A   0x.... 0x....      BL       HAL_RCC_CSSCallback
   1255              
   1256              /* Clear RCC CSS pending bit */
   1257              __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
   \   0000000E   0x2080             MOVS     R0,#+128
   \   00000010   0x....             LDR.N    R1,??DataTable13_16  ;; 0x4002380e
   \   00000012   0x7008             STRB     R0,[R1, #+0]
   1258            }
   1259          }
   \                     ??HAL_RCC_NMI_IRQHandler_0: (+1)
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
   1260          
   1261          /**
   1262            * @brief  RCC Clock Security System interrupt callback
   1263            * @retval none
   1264            */

   \                                 In section .text, align 2, keep-with-next
   1265          __weak void HAL_RCC_CSSCallback(void)
   1266          {
   1267            /* NOTE : This function Should not be modified, when the callback is needed,
   1268              the HAL_RCC_CSSCallback could be implemented in the user file
   1269              */ 
   1270          }
   \                     HAL_RCC_CSSCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1271          
   1272          /**
   1273            * @}
   1274            */
   1275          
   1276          /**
   1277            * @}
   1278            */
   1279          
   1280          /* Private function prototypes -----------------------------------------------*/
   1281          /** @addtogroup RCC_Private_Functions
   1282            * @{
   1283            */
   1284          /**
   1285            * @brief  Update number of Flash wait states in line with MSI range and current 
   1286                      voltage range
   1287            * @param  MSIrange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_6
   1288            * @retval HAL status
   1289            */

   \                                 In section .text, align 2, keep-with-next
   1290          static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t MSIrange)
   1291          {
   \                     RCC_SetFlashLatencyFromMSIRange: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1292            uint32_t vos = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   1293            uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
   \   00000006   0x2500             MOVS     R5,#+0
   1294          
   1295            /* HCLK can reach 4 MHz only if AHB prescaler = 1 */
   1296            if (READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) == RCC_SYSCLK_DIV1)
   \   00000008   0x....             LDR.N    R0,??DataTable13_9  ;; 0x40023808
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0xF010 0x0FF0      TST      R0,#0xF0
   \   00000010   0xD121             BNE.N    ??RCC_SetFlashLatencyFromMSIRange_0
   1297            {
   1298              if(__HAL_RCC_PWR_IS_CLK_ENABLED())
   \   00000012   0x....             LDR.N    R0,??DataTable13_3  ;; 0x40023824
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x00C0             LSLS     R0,R0,#+3
   \   00000018   0xD502             BPL.N    ??RCC_SetFlashLatencyFromMSIRange_1
   1299              {
   1300                vos = HAL_PWREx_GetVoltageRange();
   \   0000001A   0x.... 0x....      BL       HAL_PWREx_GetVoltageRange
   \   0000001E   0xE013             B.N      ??RCC_SetFlashLatencyFromMSIRange_2
   1301              }
   1302              else
   1303              {
   1304                __HAL_RCC_PWR_CLK_ENABLE();
   \                     ??RCC_SetFlashLatencyFromMSIRange_1: (+1)
   \   00000020   0x....             LDR.N    R0,??DataTable13_3  ;; 0x40023824
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   00000028   0x....             LDR.N    R1,??DataTable13_3  ;; 0x40023824
   \   0000002A   0x6008             STR      R0,[R1, #+0]
   \   0000002C   0x....             LDR.N    R0,??DataTable13_3  ;; 0x40023824
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xF010 0x5080      ANDS     R0,R0,#0x10000000
   \   00000034   0x9000             STR      R0,[SP, #+0]
   \   00000036   0x9800             LDR      R0,[SP, #+0]
   1305                vos = HAL_PWREx_GetVoltageRange();
   \   00000038   0x.... 0x....      BL       HAL_PWREx_GetVoltageRange
   1306                __HAL_RCC_PWR_CLK_DISABLE();
   \   0000003C   0x....             LDR.N    R1,??DataTable13_3  ;; 0x40023824
   \   0000003E   0x6809             LDR      R1,[R1, #+0]
   \   00000040   0xF031 0x5180      BICS     R1,R1,#0x10000000
   \   00000044   0x....             LDR.N    R2,??DataTable13_3  ;; 0x40023824
   \   00000046   0x6011             STR      R1,[R2, #+0]
   1307              }
   1308              
   1309              /* Check if need to set latency 1 only for Range 3 & HCLK = 4MHz */
   1310              if((vos == PWR_REGULATOR_VOLTAGE_SCALE3) && (MSIrange == RCC_MSIRANGE_6))
   \                     ??RCC_SetFlashLatencyFromMSIRange_2: (+1)
   \   00000048   0xF5B0 0x5FC0      CMP      R0,#+6144
   \   0000004C   0xD103             BNE.N    ??RCC_SetFlashLatencyFromMSIRange_0
   \   0000004E   0xF5B4 0x4F40      CMP      R4,#+49152
   \   00000052   0xD100             BNE.N    ??RCC_SetFlashLatencyFromMSIRange_0
   1311              {
   1312                latency = FLASH_LATENCY_1; /* 1WS */
   \   00000054   0x2501             MOVS     R5,#+1
   1313              }
   1314            }
   1315            
   1316            __HAL_FLASH_SET_LATENCY(latency);
   \                     ??RCC_SetFlashLatencyFromMSIRange_0: (+1)
   \   00000056   0x2D01             CMP      R5,#+1
   \   00000058   0xD105             BNE.N    ??RCC_SetFlashLatencyFromMSIRange_3
   \   0000005A   0x....             LDR.N    R0,??DataTable13_5  ;; 0x40023c00
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000062   0x....             LDR.N    R1,??DataTable13_5  ;; 0x40023c00
   \   00000064   0x6008             STR      R0,[R1, #+0]
   \                     ??RCC_SetFlashLatencyFromMSIRange_3: (+1)
   \   00000066   0x....             LDR.N    R0,??DataTable13_5  ;; 0x40023c00
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x0840             LSRS     R0,R0,#+1
   \   0000006C   0x0040             LSLS     R0,R0,#+1
   \   0000006E   0x4328             ORRS     R0,R5,R0
   \   00000070   0x....             LDR.N    R1,??DataTable13_5  ;; 0x40023c00
   \   00000072   0x6008             STR      R0,[R1, #+0]
   1317            
   1318            /* Check that the new number of wait states is taken into account to access the Flash
   1319               memory by reading the FLASH_ACR register */
   1320            if((FLASH->ACR & FLASH_ACR_LATENCY) != latency)
   \   00000074   0x....             LDR.N    R0,??DataTable13_5  ;; 0x40023c00
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000007C   0x42A8             CMP      R0,R5
   \   0000007E   0xD001             BEQ.N    ??RCC_SetFlashLatencyFromMSIRange_4
   1321            {
   1322              return HAL_ERROR;
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0xE000             B.N      ??RCC_SetFlashLatencyFromMSIRange_5
   1323            }
   1324            
   1325            return HAL_OK;
   \                     ??RCC_SetFlashLatencyFromMSIRange_4: (+1)
   \   00000084   0x2000             MOVS     R0,#+0
   \                     ??RCC_SetFlashLatencyFromMSIRange_5: (+1)
   \   00000086   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1326          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x40023800         DC32     0x40023800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x40023808         DC32     0x40023808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0xEEFAFFFE         DC32     0xeefafffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x40023804         DC32     0x40023804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x00FF1FFF         DC32     0xff1fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x4002380C         DC32     0x4002380c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x00F42400         DC32     0xf42400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x40023834         DC32     0x40023834

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x42470000         DC32     0x42470000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x........         DC32     AHBPrescTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x42470680         DC32     0x42470680

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x40023824         DC32     0x40023824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x40007000         DC32     0x40007000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x40023C00         DC32     0x40023c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x........         DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   0x4002381C         DC32     0x4002381c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \   00000000   0x40023808         DC32     0x40023808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_10:
   \   00000000   0x016E3600         DC32     0x16e3600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_11:
   \   00000000   0x........         DC32     PLLMulTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_12:
   \   00000000   0x40023804         DC32     0x40023804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_13:
   \   00000000   0x........         DC32     APBPrescTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_14:
   \   00000000   0x40023800         DC32     0x40023800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_15:
   \   00000000   0x4002380C         DC32     0x4002380c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_16:
   \   00000000   0x4002380E         DC32     0x4002380e

   \                                 In section .rodata, align 4
   \   00000000   0x00000000         DC32 0, 0, 0, 0, 0
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   1327          
   1328          /**
   1329            * @}
   1330            */
   1331            
   1332          #endif /* HAL_RCC_MODULE_ENABLED */
   1333          /**
   1334            * @}
   1335            */
   1336          
   1337          /**
   1338            * @}
   1339            */
   1340          
   1341          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_RCC_CSSCallback
      16   HAL_RCC_ClockConfig
        16   -> HAL_GetTick
        16   -> HAL_InitTick
        16   -> HAL_RCC_GetSysClockFreq
       0   HAL_RCC_DeInit
       0   HAL_RCC_DisableCSS
       0   HAL_RCC_EnableCSS
       0   HAL_RCC_GetClockConfig
       0   HAL_RCC_GetHCLKFreq
       0   HAL_RCC_GetOscConfig
       8   HAL_RCC_GetPCLK1Freq
         8   -> HAL_RCC_GetHCLKFreq
       8   HAL_RCC_GetPCLK2Freq
         8   -> HAL_RCC_GetHCLKFreq
       0   HAL_RCC_GetSysClockFreq
      40   HAL_RCC_MCOConfig
        40   -> HAL_GPIO_Init
        40   -> __aeabi_memclr4
       8   HAL_RCC_NMI_IRQHandler
         8   -> HAL_RCC_CSSCallback
      24   HAL_RCC_OscConfig
        24   -> HAL_GetTick
        24   -> HAL_InitTick
        24   -> RCC_SetFlashLatencyFromMSIRange
      16   RCC_SetFlashLatencyFromMSIRange
        16   -> HAL_PWREx_GetVoltageRange


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable12
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_12
       4  ??DataTable13_13
       4  ??DataTable13_14
       4  ??DataTable13_15
       4  ??DataTable13_16
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
       4  ??DataTable8
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
      20  ?_0
       2  HAL_RCC_CSSCallback
     670  HAL_RCC_ClockConfig
     136  HAL_RCC_DeInit
      16  HAL_RCC_DisableCSS
      16  HAL_RCC_EnableCSS
      58  HAL_RCC_GetClockConfig
       6  HAL_RCC_GetHCLKFreq
     220  HAL_RCC_GetOscConfig
      32  HAL_RCC_GetPCLK1Freq
      32  HAL_RCC_GetPCLK2Freq
     138  HAL_RCC_GetSysClockFreq
      90  HAL_RCC_MCOConfig
      22  HAL_RCC_NMI_IRQHandler
    2186  HAL_RCC_OscConfig
     136  RCC_SetFlashLatencyFromMSIRange

 
    20 bytes in section .rodata
 3 864 bytes in section .text
 
 3 864 bytes of CODE  memory
    20 bytes of CONST memory

Errors: none
Warnings: none
