###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       21/Sep/2016  16:57:25
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\01work\proj\地磁\Code\Drivers\Core\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_uart.c
#    Command line =  
#        D:\01work\proj\地磁\Code\Drivers\Core\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_uart.c
#        -D USE_HAL_DRIVER -D STM32L151xD -lC
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5\Debug\List -lA
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5\Debug\List -o
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5\Debug\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Apps/Config\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers\Inc\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers\Core\CMSIS\RTOS\Template\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/STM32L1xx_HAL_Driver/Config\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Middlewares/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Middlewares/FreeRTOS/Source/include\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/CMSIS/Include\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/RTT\
#        -I D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers\
#        -I D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../BSP/Inc/\
#        -I
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/CMSIS/Device/ST/STM32L1xx/Include\
#        -Ol
#    List file    =  
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5\Debug\List\stm32l1xx_hal_uart.lst
#    Object file  =  
#        D:\01work\proj\地磁\Code\Project\Qmc5883Test-IAR7.5\Debug\Obj\stm32l1xx_hal_uart.o
#
###############################################################################

D:\01work\proj\地磁\Code\Drivers\Core\STM32L1xx_HAL_Driver\Src\stm32l1xx_hal_uart.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_hal_uart.c
      4            * @author  MCD Application Team
      5            * @version V1.2.0
      6            * @date    01-July-2016
      7            * @brief   UART HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Universal Asynchronous Receiver Transmitter (UART) peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral Control functions 
     13            *           + Peripheral State and Errors functions  
     14            @verbatim
     15            ==============================================================================
     16                                  ##### How to use this driver #####
     17            ==============================================================================
     18            [..]
     19              The UART HAL driver can be used as follows:
     20              
     21              (#) Declare a UART_HandleTypeDef handle structure.
     22          
     23              (#) Initialize the UART low level resources by implementing the HAL_UART_MspInit() API:
     24                  (##) Enable the USARTx interface clock.
     25                  (##) UART pins configuration:
     26                      (+++) Enable the clock for the UART GPIOs.
     27                      (+++) Configure the UART pins as alternate function pull-up.
     28                  (##) NVIC configuration if you need to use interrupt process (HAL_UART_Transmit_IT()
     29                       and HAL_UART_Receive_IT() APIs):
     30                      (+++) Configure the USARTx interrupt priority.
     31                      (+++) Enable the NVIC USART IRQ handle.
     32                  (##) DMA Configuration if you need to use DMA process (HAL_UART_Transmit_DMA()
     33                       and HAL_UART_Receive_DMA() APIs):
     34                      (+++) Declare a DMA handle structure for the Tx/Rx channel.
     35                      (+++) Enable the DMAx interface clock.
     36                      (+++) Configure the declared DMA handle structure with the required 
     37                            Tx/Rx parameters.                
     38                      (+++) Configure the DMA Tx/Rx channel.
     39                      (+++) Associate the initialized DMA handle to the UART DMA Tx/Rx handle.
     40                      (+++) Configure the priority and enable the NVIC for the transfer complete 
     41                            interrupt on the DMA Tx/Rx channel.
     42                      (+++) Configure the USARTx interrupt priority and enable the NVIC USART IRQ handle
     43                            (used for last byte sending completion detection in DMA non circular mode)
     44          
     45              (#) Program the Baud Rate, Word Length, Stop Bit, Parity, Hardware 
     46                  flow control and Mode(Receiver/Transmitter) in the huart Init structure.
     47          
     48              (#) For the UART asynchronous mode, initialize the UART registers by calling
     49                  the HAL_UART_Init() API.
     50          
     51              (#) For the UART Half duplex mode, initialize the UART registers by calling 
     52                  the HAL_HalfDuplex_Init() API.
     53          
     54              (#) For the LIN mode, initialize the UART registers by calling the HAL_LIN_Init() API.
     55          
     56              (#) For the Multi-Processor mode, initialize the UART registers by calling 
     57                  the HAL_MultiProcessor_Init() API.
     58          
     59               [..] 
     60                 (@) The specific UART interrupts (Transmission complete interrupt, 
     61                      RXNE interrupt and Error Interrupts) will be managed using the macros
     62                      __HAL_UART_ENABLE_IT() and __HAL_UART_DISABLE_IT() inside the transmit 
     63                      and receive process.
     64          
     65               [..] 
     66                 (@) These APIs (HAL_UART_Init() and HAL_HalfDuplex_Init()) configure also the 
     67                      low level Hardware GPIO, CLOCK, CORTEX...etc) by calling the customed 
     68                      HAL_UART_MspInit() API.
     69          
     70               [..] 
     71                  Three operation modes are available within this driver :
     72          
     73               *** Polling mode IO operation ***
     74               =================================
     75               [..]    
     76                 (+) Send an amount of data in blocking mode using HAL_UART_Transmit() 
     77                 (+) Receive an amount of data in blocking mode using HAL_UART_Receive()
     78                 
     79               *** Interrupt mode IO operation ***
     80               ===================================
     81               [..]
     82                 (+) Send an amount of data in non blocking mode using HAL_UART_Transmit_IT() 
     83                 (+) At transmission end of transfer HAL_UART_TxCpltCallback is executed and user can 
     84                      add his own code by customization of function pointer HAL_UART_TxCpltCallback
     85                 (+) Receive an amount of data in non blocking mode using HAL_UART_Receive_IT() 
     86                 (+) At reception end of transfer HAL_UART_RxCpltCallback is executed and user can 
     87                      add his own code by customization of function pointer HAL_UART_RxCpltCallback
     88                 (+) In case of transfer Error, HAL_UART_ErrorCallback() function is executed and user can 
     89                      add his own code by customization of function pointer HAL_UART_ErrorCallback
     90          
     91               *** DMA mode IO operation ***
     92               ==============================
     93               [..] 
     94                 (+) Send an amount of data in non blocking mode (DMA) using HAL_UART_Transmit_DMA() 
     95                 (+) At transmission end of half transfer HAL_UART_TxHalfCpltCallback is executed and user can 
     96                      add his own code by customization of function pointer HAL_UART_TxHalfCpltCallback 
     97                 (+) At transmission end of transfer HAL_UART_TxCpltCallback is executed and user can 
     98                      add his own code by customization of function pointer HAL_UART_TxCpltCallback
     99                 (+) Receive an amount of data in non blocking mode (DMA) using HAL_UART_Receive_DMA() 
    100                 (+) At reception end of half transfer HAL_UART_RxHalfCpltCallback is executed and user can 
    101                      add his own code by customization of function pointer HAL_UART_RxHalfCpltCallback 
    102                 (+) At reception end of transfer HAL_UART_RxCpltCallback is executed and user can 
    103                      add his own code by customization of function pointer HAL_UART_RxCpltCallback
    104                 (+) In case of transfer Error, HAL_UART_ErrorCallback() function is executed and user can 
    105                      add his own code by customization of function pointer HAL_UART_ErrorCallback
    106                 (+) Pause the DMA Transfer using HAL_UART_DMAPause()
    107                 (+) Resume the DMA Transfer using HAL_UART_DMAResume()
    108                 (+) Stop the DMA Transfer using HAL_UART_DMAStop()
    109          
    110               *** UART HAL driver macros list ***
    111               =============================================
    112               [..]
    113                 Below the list of most used macros in UART HAL driver.
    114          
    115                (+) __HAL_UART_ENABLE: Enable the UART peripheral 
    116                (+) __HAL_UART_DISABLE: Disable the UART peripheral
    117                (+) __HAL_UART_GET_FLAG : Check whether the specified UART flag is set or not
    118                (+) __HAL_UART_CLEAR_FLAG : Clear the specified UART pending flag
    119                (+) __HAL_UART_ENABLE_IT: Enable the specified UART interrupt
    120                (+) __HAL_UART_DISABLE_IT: Disable the specified UART interrupt
    121                (+) __HAL_UART_GET_IT_SOURCE: Check whether the specified UART interrupt has occurred or not
    122          
    123               [..]
    124                 (@) You can refer to the UART HAL driver header file for more useful macros 
    125                
    126            @endverbatim
    127            ******************************************************************************
    128            * @attention
    129            *
    130            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
    131            *
    132            * Redistribution and use in source and binary forms, with or without modification,
    133            * are permitted provided that the following conditions are met:
    134            *   1. Redistributions of source code must retain the above copyright notice,
    135            *      this list of conditions and the following disclaimer.
    136            *   2. Redistributions in binary form must reproduce the above copyright notice,
    137            *      this list of conditions and the following disclaimer in the documentation
    138            *      and/or other materials provided with the distribution.
    139            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    140            *      may be used to endorse or promote products derived from this software
    141            *      without specific prior written permission.
    142            *
    143            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    144            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    145            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    146            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    147            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    148            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    149            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    150            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    151            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    152            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    153            *
    154            ******************************************************************************
    155            */
    156          
    157          /* Includes ------------------------------------------------------------------*/
    158          #include "stm32l1xx_hal.h"
    159          
    160          /** @addtogroup STM32L1xx_HAL_Driver
    161            * @{
    162            */
    163          
    164          /** @defgroup UART UART
    165            * @brief HAL UART module driver
    166            * @{
    167            */
    168          #ifdef HAL_UART_MODULE_ENABLED
    169              
    170          /* Private typedef -----------------------------------------------------------*/
    171          /* Private define ------------------------------------------------------------*/
    172          /* Private macros ------------------------------------------------------------*/
    173          /* Private variables ---------------------------------------------------------*/
    174          /* Private function prototypes -----------------------------------------------*/
    175          /** @addtogroup UART_Private_Functions   UART Private Functions
    176            * @{
    177            */
    178          static void UART_SetConfig (UART_HandleTypeDef *huart);
    179          static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart);
    180          static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart);
    181          static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart);
    182          static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma);
    183          static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma);
    184          static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma);
    185          static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma);
    186          static void UART_DMAError(DMA_HandleTypeDef *hdma); 
    187          static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Timeout);
    188          /**
    189            * @}
    190            */
    191          
    192          /* Exported functions ---------------------------------------------------------*/
    193          
    194          /** @defgroup UART_Exported_Functions UART Exported Functions
    195            * @{
    196            */
    197          
    198          /** @defgroup UART_Exported_Functions_Group1 Initialization and de-initialization functions 
    199            *  @brief    Initialization and Configuration functions 
    200            *
    201          @verbatim
    202          ===============================================================================
    203                      ##### Initialization and Configuration functions #####
    204           ===============================================================================  
    205              [..]
    206              This subsection provides a set of functions allowing to initialize the USARTx or the UARTy 
    207              in asynchronous mode.
    208                (+) For the asynchronous mode only these parameters can be configured: 
    209                  (++) Baud Rate
    210                  (++) Word Length 
    211                  (++) Stop Bit
    212                  (++) Parity
    213                  (++) Hardware flow control
    214                  (++) Receiver/transmitter modes
    215                  (++) Over Sampling Methode
    216              [..]
    217              The HAL_UART_Init(), HAL_HalfDuplex_Init(), HAL_LIN_Init() and HAL_MultiProcessor_Init() APIs 
    218              follow respectively the UART asynchronous, UART Half duplex, LIN and Multi-Processor
    219              configuration procedures (details for the procedures are available in reference manual (RM0038)).
    220          
    221          @endverbatim
    222            * @{
    223            */
    224          
    225          /*
    226            Additionnal remark: If the parity is enabled, then the MSB bit of the data written
    227                                in the data register is transmitted but is changed by the parity bit.
    228                                Depending on the frame length defined by the M bit (8-bits or 9-bits),
    229                                the possible UART frame formats are as listed in the following table:
    230              +-------------------------------------------------------------+
    231              |   M bit |  PCE bit  |            UART frame                 |
    232              |---------------------|---------------------------------------|
    233              |    0    |    0      |    | SB | 8 bit data | STB |          |
    234              |---------|-----------|---------------------------------------|
    235              |    0    |    1      |    | SB | 7 bit data | PB | STB |     |
    236              |---------|-----------|---------------------------------------|
    237              |    1    |    0      |    | SB | 9 bit data | STB |          |
    238              |---------|-----------|---------------------------------------|
    239              |    1    |    1      |    | SB | 8 bit data | PB | STB |     |
    240              +-------------------------------------------------------------+
    241          */
    242          
    243          /**
    244            * @brief  Initializes the UART mode according to the specified parameters in
    245            *         the UART_InitTypeDef and create the associated handle.
    246            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    247            *                the configuration information for the specified UART module.
    248            * @retval HAL status
    249            */

   \                                 In section .text, align 2, keep-with-next
    250          HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
    251          {
   \                     HAL_UART_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    252            /* Check the UART handle allocation */
    253            if(huart == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_UART_Init_0
    254            {
    255              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE030             B.N      ??HAL_UART_Init_1
    256            }
    257          
    258            /* Check the parameters */
    259            if(huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
   \                     ??HAL_UART_Init_0: (+1)
   \   0000000C   0x69A0             LDR      R0,[R4, #+24]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD1FF             BNE.N    ??HAL_UART_Init_2
    260            {
    261              /* The hardware flow control is available only for USART1, USART2, USART3 */
    262              assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
    263              assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
    264            }
    265            else
    266            {
    267              assert_param(IS_UART_INSTANCE(huart->Instance));
    268            }
    269            assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
    270            assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
    271            
    272            if(huart->State == HAL_UART_STATE_RESET)
   \                     ??HAL_UART_Init_3: (+1)
   \                     ??HAL_UART_Init_2: (+1)
   \   00000012   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD105             BNE.N    ??HAL_UART_Init_4
    273            {  
    274              /* Allocate lock resource and initialize it */
    275              huart->Lock = HAL_UNLOCKED;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xF884 0x0038      STRB     R0,[R4, #+56]
    276          
    277              /* Init the low level hardware */
    278              HAL_UART_MspInit(huart);
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       HAL_UART_MspInit
    279            }
    280          
    281            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_UART_Init_4: (+1)
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0xF884 0x0039      STRB     R0,[R4, #+57]
    282          
    283            /* Disable the peripheral */
    284            __HAL_UART_DISABLE(huart);
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x68C0             LDR      R0,[R0, #+12]
   \   00000030   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   00000034   0x6821             LDR      R1,[R4, #+0]
   \   00000036   0x60C8             STR      R0,[R1, #+12]
    285            
    286            /* Set the UART Communication parameters */
    287            UART_SetConfig(huart);
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x.... 0x....      BL       UART_SetConfig
    288            
    289            /* In asynchronous mode, the following bits must be kept cleared: 
    290               - LINEN and CLKEN bits in the USART_CR2 register,
    291               - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
    292            CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6900             LDR      R0,[R0, #+16]
   \   00000042   0xF430 0x4090      BICS     R0,R0,#0x4800
   \   00000046   0x6821             LDR      R1,[R4, #+0]
   \   00000048   0x6108             STR      R0,[R1, #+16]
    293            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x6940             LDR      R0,[R0, #+20]
   \   0000004E   0xF030 0x002A      BICS     R0,R0,#0x2A
   \   00000052   0x6821             LDR      R1,[R4, #+0]
   \   00000054   0x6148             STR      R0,[R1, #+20]
    294            
    295            /* Enable the peripheral */
    296            __HAL_UART_ENABLE(huart);
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x68C0             LDR      R0,[R0, #+12]
   \   0000005A   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   0000005E   0x6821             LDR      R1,[R4, #+0]
   \   00000060   0x60C8             STR      R0,[R1, #+12]
    297            
    298            /* Initialize the UART state */
    299            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x63E0             STR      R0,[R4, #+60]
    300            huart->State= HAL_UART_STATE_READY;
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0xF884 0x0039      STRB     R0,[R4, #+57]
    301            
    302            return HAL_OK;
   \   0000006C   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_Init_1: (+1)
   \   0000006E   0xBD10             POP      {R4,PC}          ;; return
    303          }
    304          
    305          /**
    306            * @brief  Initializes the half-duplex mode according to the specified
    307            *         parameters in the UART_InitTypeDef and create the associated handle.
    308            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    309            *                the configuration information for the specified UART module.
    310            * @retval HAL status
    311            */

   \                                 In section .text, align 2, keep-with-next
    312          HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
    313          {
   \                     HAL_HalfDuplex_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    314            /* Check the UART handle allocation */
    315            if(huart == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_HalfDuplex_Init_0
    316            {
    317              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE033             B.N      ??HAL_HalfDuplex_Init_1
    318            }
    319            
    320            /* Check UART instance */
    321            assert_param(IS_UART_HALFDUPLEX_INSTANCE(huart->Instance));
    322            assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
    323            assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
    324          
    325            if(huart->State == HAL_UART_STATE_RESET)
   \                     ??HAL_HalfDuplex_Init_0: (+1)
   \   0000000C   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD105             BNE.N    ??HAL_HalfDuplex_Init_2
    326            {   
    327              /* Allocate lock resource and initialize it */
    328              huart->Lock = HAL_UNLOCKED;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF884 0x0038      STRB     R0,[R4, #+56]
    329          
    330              /* Init the low level hardware */
    331              HAL_UART_MspInit(huart);
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_UART_MspInit
    332            }
    333          
    334            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_HalfDuplex_Init_2: (+1)
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xF884 0x0039      STRB     R0,[R4, #+57]
    335          
    336            /* Disable the peripheral */
    337            __HAL_UART_DISABLE(huart);
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x68C0             LDR      R0,[R0, #+12]
   \   0000002A   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   0000002E   0x6821             LDR      R1,[R4, #+0]
   \   00000030   0x60C8             STR      R0,[R1, #+12]
    338            
    339            /* Set the UART Communication parameters */
    340            UART_SetConfig(huart);
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       UART_SetConfig
    341            
    342            /* In half-duplex mode, the following bits must be kept cleared: 
    343               - LINEN and CLKEN bits in the USART_CR2 register,
    344               - SCEN and IREN bits in the USART_CR3 register.*/
    345            CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x6900             LDR      R0,[R0, #+16]
   \   0000003C   0xF430 0x4090      BICS     R0,R0,#0x4800
   \   00000040   0x6821             LDR      R1,[R4, #+0]
   \   00000042   0x6108             STR      R0,[R1, #+16]
    346            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x6940             LDR      R0,[R0, #+20]
   \   00000048   0xF030 0x0022      BICS     R0,R0,#0x22
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x6148             STR      R0,[R1, #+20]
    347            
    348            /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    349            SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x6940             LDR      R0,[R0, #+20]
   \   00000054   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000058   0x6821             LDR      R1,[R4, #+0]
   \   0000005A   0x6148             STR      R0,[R1, #+20]
    350           
    351            /* Enable the peripheral */
    352            __HAL_UART_ENABLE(huart);
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x68C0             LDR      R0,[R0, #+12]
   \   00000060   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0x60C8             STR      R0,[R1, #+12]
    353            
    354            /* Initialize the UART state*/
    355            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x63E0             STR      R0,[R4, #+60]
    356            huart->State= HAL_UART_STATE_READY;
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0xF884 0x0039      STRB     R0,[R4, #+57]
    357            
    358            return HAL_OK;
   \   00000072   0x2000             MOVS     R0,#+0
   \                     ??HAL_HalfDuplex_Init_1: (+1)
   \   00000074   0xBD10             POP      {R4,PC}          ;; return
    359          }
    360          
    361          /**
    362            * @brief  Initializes the LIN mode according to the specified
    363            *         parameters in the UART_InitTypeDef and create the associated handle.
    364            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    365            *                the configuration information for the specified UART module.
    366            * @param  BreakDetectLength: Specifies the LIN break detection length.
    367            *         This parameter can be one of the following values:
    368            *            @arg UART_LINBREAKDETECTLENGTH_10B: 10-bit break detection
    369            *            @arg UART_LINBREAKDETECTLENGTH_11B: 11-bit break detection
    370            * @retval HAL status
    371            */

   \                                 In section .text, align 2, keep-with-next
    372          HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
    373          {
   \                     HAL_LIN_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    374            /* Check the UART handle allocation */
    375            if(huart == NULL)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??HAL_LIN_Init_0
    376            {
    377              return HAL_ERROR;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE03A             B.N      ??HAL_LIN_Init_1
    378            }
    379            
    380            /* Check the LIN UART instance */  
    381            assert_param(IS_UART_LIN_INSTANCE(huart->Instance));
    382            /* Check the Break detection length parameter */
    383            assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
    384            assert_param(IS_UART_LIN_WORD_LENGTH(huart->Init.WordLength));
    385            assert_param(IS_UART_LIN_OVERSAMPLING(huart->Init.OverSampling));
    386            
    387            if(huart->State == HAL_UART_STATE_RESET)
   \                     ??HAL_LIN_Init_0: (+1)
   \   0000000E   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD105             BNE.N    ??HAL_LIN_Init_2
    388            {   
    389              /* Allocate lock resource and initialize it */
    390              huart->Lock = HAL_UNLOCKED;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF884 0x0038      STRB     R0,[R4, #+56]
    391          
    392              /* Init the low level hardware */
    393              HAL_UART_MspInit(huart);
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       HAL_UART_MspInit
    394            }
    395          
    396            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_LIN_Init_2: (+1)
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xF884 0x0039      STRB     R0,[R4, #+57]
    397          
    398            /* Disable the peripheral */
    399            __HAL_UART_DISABLE(huart);
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x68C0             LDR      R0,[R0, #+12]
   \   0000002C   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x60C8             STR      R0,[R1, #+12]
    400            
    401            /* Set the UART Communication parameters */
    402            UART_SetConfig(huart);
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       UART_SetConfig
    403            
    404            /* In LIN mode, the following bits must be kept cleared: 
    405               - CLKEN bits in the USART_CR2 register,
    406               - SCEN and IREN bits in the USART_CR3 register.*/
    407            CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6900             LDR      R0,[R0, #+16]
   \   0000003E   0xF430 0x6000      BICS     R0,R0,#0x800
   \   00000042   0x6821             LDR      R1,[R4, #+0]
   \   00000044   0x6108             STR      R0,[R1, #+16]
    408            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6940             LDR      R0,[R0, #+20]
   \   0000004A   0xF030 0x002A      BICS     R0,R0,#0x2A
   \   0000004E   0x6821             LDR      R1,[R4, #+0]
   \   00000050   0x6148             STR      R0,[R1, #+20]
    409            
    410            /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    411            SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x6900             LDR      R0,[R0, #+16]
   \   00000056   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \   0000005A   0x6821             LDR      R1,[R4, #+0]
   \   0000005C   0x6108             STR      R0,[R1, #+16]
    412            
    413            /* Set the USART LIN Break detection length. */
    414            MODIFY_REG(huart->Instance->CR2, USART_CR2_LBDL, BreakDetectLength);
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x6900             LDR      R0,[R0, #+16]
   \   00000062   0xF030 0x0020      BICS     R0,R0,#0x20
   \   00000066   0x4328             ORRS     R0,R5,R0
   \   00000068   0x6821             LDR      R1,[R4, #+0]
   \   0000006A   0x6108             STR      R0,[R1, #+16]
    415            
    416            /* Enable the peripheral */
    417            __HAL_UART_ENABLE(huart);
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x68C0             LDR      R0,[R0, #+12]
   \   00000070   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   00000074   0x6821             LDR      R1,[R4, #+0]
   \   00000076   0x60C8             STR      R0,[R1, #+12]
    418            
    419            /* Initialize the UART state*/
    420            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x63E0             STR      R0,[R4, #+60]
    421            huart->State= HAL_UART_STATE_READY;
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0xF884 0x0039      STRB     R0,[R4, #+57]
    422            
    423            return HAL_OK;
   \   00000082   0x2000             MOVS     R0,#+0
   \                     ??HAL_LIN_Init_1: (+1)
   \   00000084   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    424          }
    425          
    426          /**
    427            * @brief  Initializes the Multi-Processor mode according to the specified
    428            *         parameters in the UART_InitTypeDef and create the associated handle.
    429            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    430            *                the configuration information for the specified UART module.
    431            * @param  Address: UART node address
    432            * @param  WakeUpMethod: specifies the UART wakeup method.
    433            *         This parameter can be one of the following values:
    434            *            @arg UART_WAKEUPMETHOD_IDLELINE: Wakeup by an idle line detection
    435            *            @arg UART_WAKEUPMETHOD_ADDRESSMARK: Wakeup by an address mark
    436            * @retval HAL status
    437            */

   \                                 In section .text, align 2, keep-with-next
    438          HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
    439          {
   \                     HAL_MultiProcessor_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    440            /* Check the UART handle allocation */
    441            if(huart == NULL)
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE.N    ??HAL_MultiProcessor_Init_0
    442            {
    443              return HAL_ERROR;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE03C             B.N      ??HAL_MultiProcessor_Init_1
    444            }
    445          
    446            /* Check UART instance capabilities */  
    447            assert_param(IS_UART_MULTIPROCESSOR_INSTANCE(huart->Instance));
    448          
    449            /* Check the Address & wake up method parameters */
    450            assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
    451            assert_param(IS_UART_ADDRESS(Address));
    452            assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
    453            assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
    454          
    455            if(huart->State == HAL_UART_STATE_RESET)
   \                     ??HAL_MultiProcessor_Init_0: (+1)
   \   00000010   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD105             BNE.N    ??HAL_MultiProcessor_Init_2
    456            {   
    457              /* Allocate lock resource and initialize it */
    458              huart->Lock = HAL_UNLOCKED;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF884 0x0038      STRB     R0,[R4, #+56]
    459          
    460              /* Init the low level hardware */
    461              HAL_UART_MspInit(huart);
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       HAL_UART_MspInit
    462            }
    463          
    464            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_MultiProcessor_Init_2: (+1)
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0xF884 0x0039      STRB     R0,[R4, #+57]
    465          
    466            /* Disable the peripheral */
    467            __HAL_UART_DISABLE(huart);
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x68C0             LDR      R0,[R0, #+12]
   \   0000002E   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   00000032   0x6821             LDR      R1,[R4, #+0]
   \   00000034   0x60C8             STR      R0,[R1, #+12]
    468            
    469            /* Set the UART Communication parameters */
    470            UART_SetConfig(huart);
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       UART_SetConfig
    471            
    472            /* In Multi-Processor mode, the following bits must be kept cleared: 
    473               - LINEN and CLKEN bits in the USART_CR2 register,
    474               - SCEN, HDSEL and IREN  bits in the USART_CR3 register */
    475            CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6900             LDR      R0,[R0, #+16]
   \   00000040   0xF430 0x4090      BICS     R0,R0,#0x4800
   \   00000044   0x6821             LDR      R1,[R4, #+0]
   \   00000046   0x6108             STR      R0,[R1, #+16]
    476            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x6940             LDR      R0,[R0, #+20]
   \   0000004C   0xF030 0x002A      BICS     R0,R0,#0x2A
   \   00000050   0x6821             LDR      R1,[R4, #+0]
   \   00000052   0x6148             STR      R0,[R1, #+20]
    477            
    478            /* Set the USART address node */
    479            MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, Address);
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x6900             LDR      R0,[R0, #+16]
   \   00000058   0x0900             LSRS     R0,R0,#+4
   \   0000005A   0x0100             LSLS     R0,R0,#+4
   \   0000005C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005E   0x4328             ORRS     R0,R5,R0
   \   00000060   0x6821             LDR      R1,[R4, #+0]
   \   00000062   0x6108             STR      R0,[R1, #+16]
    480            
    481            /* Set the wake up method by setting the WAKE bit in the CR1 register */
    482            MODIFY_REG(huart->Instance->CR1, USART_CR1_WAKE, WakeUpMethod);
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x68C0             LDR      R0,[R0, #+12]
   \   00000068   0xF430 0x6000      BICS     R0,R0,#0x800
   \   0000006C   0x4330             ORRS     R0,R6,R0
   \   0000006E   0x6821             LDR      R1,[R4, #+0]
   \   00000070   0x60C8             STR      R0,[R1, #+12]
    483            
    484            /* Enable the peripheral */
    485            __HAL_UART_ENABLE(huart);
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0x68C0             LDR      R0,[R0, #+12]
   \   00000076   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   0000007A   0x6821             LDR      R1,[R4, #+0]
   \   0000007C   0x60C8             STR      R0,[R1, #+12]
    486            
    487            /* Initialize the UART state */
    488            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x63E0             STR      R0,[R4, #+60]
    489            huart->State= HAL_UART_STATE_READY;
   \   00000082   0x2001             MOVS     R0,#+1
   \   00000084   0xF884 0x0039      STRB     R0,[R4, #+57]
    490            
    491            return HAL_OK;
   \   00000088   0x2000             MOVS     R0,#+0
   \                     ??HAL_MultiProcessor_Init_1: (+1)
   \   0000008A   0xBD70             POP      {R4-R6,PC}       ;; return
    492          }
    493          
    494          /**
    495            * @brief  DeInitializes the UART peripheral. 
    496            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    497            *                the configuration information for the specified UART module.
    498            * @retval HAL status
    499            */

   \                                 In section .text, align 2, keep-with-next
    500          HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
    501          {
   \                     HAL_UART_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    502            /* Check the UART handle allocation */
    503            if(huart == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_UART_DeInit_0
    504            {
    505              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE01D             B.N      ??HAL_UART_DeInit_1
    506            }
    507            
    508            /* Check the parameters */
    509            assert_param(IS_UART_INSTANCE(huart->Instance));
    510          
    511            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_UART_DeInit_0: (+1)
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xF884 0x0039      STRB     R0,[R4, #+57]
    512            
    513            /* Disable the Peripheral */
    514            __HAL_UART_DISABLE(huart);
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x68C0             LDR      R0,[R0, #+12]
   \   00000016   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   0000001A   0x6821             LDR      R1,[R4, #+0]
   \   0000001C   0x60C8             STR      R0,[R1, #+12]
    515            
    516            huart->Instance->CR1 = 0x0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x6821             LDR      R1,[R4, #+0]
   \   00000022   0x60C8             STR      R0,[R1, #+12]
    517            huart->Instance->CR2 = 0x0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x6821             LDR      R1,[R4, #+0]
   \   00000028   0x6108             STR      R0,[R1, #+16]
    518            huart->Instance->CR3 = 0x0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x6821             LDR      R1,[R4, #+0]
   \   0000002E   0x6148             STR      R0,[R1, #+20]
    519            
    520            /* DeInit the low level hardware */
    521            HAL_UART_MspDeInit(huart);
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       HAL_UART_MspDeInit
    522          
    523            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x63E0             STR      R0,[R4, #+60]
    524            huart->State = HAL_UART_STATE_RESET;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF884 0x0039      STRB     R0,[R4, #+57]
    525          
    526            /* Process Unlock */
    527            __HAL_UNLOCK(huart);
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF884 0x0038      STRB     R0,[R4, #+56]
    528          
    529            return HAL_OK;
   \   00000046   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_DeInit_1: (+1)
   \   00000048   0xBD10             POP      {R4,PC}          ;; return
    530          }
    531          
    532          /**
    533            * @brief  UART MSP Init.
    534            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    535            *                the configuration information for the specified UART module.
    536            * @retval None
    537            */

   \                                 In section .text, align 2, keep-with-next
    538           __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
    539          {
    540            /* Prevent unused argument(s) compilation warning */
    541            UNUSED(huart);
    542          
    543            /* NOTE: This function should not be modified, when the callback is needed,
    544                     the HAL_UART_MspInit can be implemented in the user file
    545             */ 
    546          }
   \                     HAL_UART_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    547          
    548          /**
    549            * @brief  UART MSP DeInit.
    550            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    551            *                the configuration information for the specified UART module.
    552            * @retval None
    553            */

   \                                 In section .text, align 2, keep-with-next
    554           __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
    555          {
    556            /* Prevent unused argument(s) compilation warning */
    557            UNUSED(huart);
    558          
    559            /* NOTE: This function should not be modified, when the callback is needed,
    560                     the HAL_UART_MspDeInit can be implemented in the user file
    561             */ 
    562          }
   \                     HAL_UART_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    563          
    564          /**
    565            * @}
    566            */
    567          
    568          /** @defgroup UART_Exported_Functions_Group2 IO operation functions 
    569            *  @brief UART Transmit and Receive functions 
    570            *
    571          @verbatim
    572            ==============================================================================
    573                                ##### IO operation functions #####
    574            ==============================================================================  
    575            [..]
    576              This subsection provides a set of functions allowing to manage the UART asynchronous
    577              and Half duplex data transfers.
    578          
    579              (#) There are two modes of transfer:
    580                 (++) Blocking mode: The communication is performed in polling mode. 
    581                      The HAL status of all data processing is returned by the same function 
    582                      after finishing transfer.  
    583                 (++) Non blocking mode: The communication is performed using Interrupts 
    584                      or DMA, these APIs return the HAL status.
    585                      The end of the data processing will be indicated through the 
    586                      dedicated UART IRQ when using Interrupt mode or the DMA IRQ when 
    587                      using DMA mode.
    588                      The HAL_UART_TxCpltCallback(), HAL_UART_RxCpltCallback() user callbacks 
    589                      will be executed respectively at the end of the transmit or receive process.
    590                      The HAL_UART_ErrorCallback() user callback will be executed when 
    591                      a communication error is detected.
    592          
    593              (#) Blocking mode APIs are:
    594                  (++) HAL_UART_Transmit()
    595                  (++) HAL_UART_Receive() 
    596          
    597              (#) Non Blocking mode APIs with Interrupt are:
    598                  (++) HAL_UART_Transmit_IT()
    599                  (++) HAL_UART_Receive_IT()
    600                  (++) HAL_UART_IRQHandler()
    601          
    602              (#) Non Blocking mode functions with DMA are:
    603                  (++) HAL_UART_Transmit_DMA()
    604                  (++) HAL_UART_Receive_DMA()
    605                  (++) HAL_UART_DMAPause()
    606                  (++) HAL_UART_DMAResume()
    607                  (++) HAL_UART_DMAStop()
    608          
    609              (#) A set of Transfer Complete Callbacks are provided in non blocking mode:
    610                  (++) HAL_UART_TxHalfCpltCallback()
    611                  (++) HAL_UART_TxCpltCallback()
    612                  (++) HAL_UART_RxHalfCpltCallback()
    613                  (++) HAL_UART_RxCpltCallback()
    614                  (++) HAL_UART_ErrorCallback()
    615          
    616              [..] 
    617                (@) In the Half duplex communication, it is forbidden to run the transmit 
    618                    and receive process in parallel, the UART state HAL_UART_STATE_BUSY_TX_RX 
    619                    can't be useful.
    620                
    621          @endverbatim
    622            * @{
    623            */
    624          
    625          /**
    626            * @brief  Sends an amount of data in blocking mode. 
    627            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    628            *                the configuration information for the specified UART module.
    629            * @param  pData: Pointer to data buffer
    630            * @param  Size: Amount of data to be sent
    631            * @param  Timeout: Timeout duration  
    632            * @retval HAL status
    633            */

   \                                 In section .text, align 2, keep-with-next
    634          HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    635          {
   \                     HAL_UART_Transmit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x001E             MOVS     R6,R3
    636            uint16_t* tmp;
    637            uint32_t tmp_state = 0;
   \   00000008   0x2000             MOVS     R0,#+0
    638            
    639            tmp_state = huart->State;
   \   0000000A   0xF894 0x0039      LDRB     R0,[R4, #+57]
    640            if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_RX))
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD001             BEQ.N    ??HAL_UART_Transmit_0
   \   00000012   0x2822             CMP      R0,#+34
   \   00000014   0xD167             BNE.N    ??HAL_UART_Transmit_1
    641            {
    642              if((pData == NULL) || (Size == 0))
   \                     ??HAL_UART_Transmit_0: (+1)
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD002             BEQ.N    ??HAL_UART_Transmit_2
   \   0000001A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000001C   0x2A00             CMP      R2,#+0
   \   0000001E   0xD101             BNE.N    ??HAL_UART_Transmit_3
    643              {
    644                return  HAL_ERROR;
   \                     ??HAL_UART_Transmit_2: (+1)
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xE061             B.N      ??HAL_UART_Transmit_4
    645              }
    646          
    647              /* Process Locked */
    648              __HAL_LOCK(huart);
   \                     ??HAL_UART_Transmit_3: (+1)
   \   00000024   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD101             BNE.N    ??HAL_UART_Transmit_5
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0xE05B             B.N      ??HAL_UART_Transmit_4
   \                     ??HAL_UART_Transmit_5: (+1)
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0xF884 0x0038      STRB     R0,[R4, #+56]
    649          
    650              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x63E0             STR      R0,[R4, #+60]
    651              /* Check if a non-blocking receive process is ongoing or not */
    652              if(huart->State == HAL_UART_STATE_BUSY_RX) 
   \   0000003A   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000003E   0x2822             CMP      R0,#+34
   \   00000040   0xD103             BNE.N    ??HAL_UART_Transmit_6
    653              {
    654                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   00000042   0x2032             MOVS     R0,#+50
   \   00000044   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000048   0xE002             B.N      ??HAL_UART_Transmit_7
    655              }
    656              else
    657              {
    658                huart->State = HAL_UART_STATE_BUSY_TX;
   \                     ??HAL_UART_Transmit_6: (+1)
   \   0000004A   0x2012             MOVS     R0,#+18
   \   0000004C   0xF884 0x0039      STRB     R0,[R4, #+57]
    659              }
    660          
    661              huart->TxXferSize = Size;
   \                     ??HAL_UART_Transmit_7: (+1)
   \   00000050   0x84A2             STRH     R2,[R4, #+36]
    662              huart->TxXferCount = Size;
   \   00000052   0x84E2             STRH     R2,[R4, #+38]
   \   00000054   0xE003             B.N      ??HAL_UART_Transmit_8
    663              while(huart->TxXferCount > 0)
    664              {
    665                huart->TxXferCount--;
    666                if(huart->Init.WordLength == UART_WORDLENGTH_9B)
    667                {
    668                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, Timeout) != HAL_OK)
    669                  {
    670                    return HAL_TIMEOUT;
    671                  }
    672                  tmp = (uint16_t*) pData;
    673                  huart->Instance->DR = (*tmp & (uint16_t)0x01FF);
    674                  if(huart->Init.Parity == UART_PARITY_NONE)
    675                  {
    676                    pData +=2;
    677                  }
    678                  else
    679                  { 
    680                    pData +=1;
    681                  }
    682                } 
    683                else
    684                {
    685                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, Timeout) != HAL_OK)
    686                  {
    687                    return HAL_TIMEOUT;
    688                  }
    689                  huart->Instance->DR = (*pData++ & (uint8_t)0xFF);
   \                     ??HAL_UART_Transmit_9: (+1)
   \   00000056   0x7828             LDRB     R0,[R5, #+0]
   \   00000058   0x6821             LDR      R1,[R4, #+0]
   \   0000005A   0x6048             STR      R0,[R1, #+4]
   \   0000005C   0x1C6D             ADDS     R5,R5,#+1
   \                     ??HAL_UART_Transmit_8: (+1)
   \   0000005E   0x8CE0             LDRH     R0,[R4, #+38]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD026             BEQ.N    ??HAL_UART_Transmit_10
   \   00000064   0x8CE0             LDRH     R0,[R4, #+38]
   \   00000066   0x1E40             SUBS     R0,R0,#+1
   \   00000068   0x84E0             STRH     R0,[R4, #+38]
   \   0000006A   0x68A0             LDR      R0,[R4, #+8]
   \   0000006C   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000070   0xD115             BNE.N    ??HAL_UART_Transmit_11
   \   00000072   0x0033             MOVS     R3,R6
   \   00000074   0x2200             MOVS     R2,#+0
   \   00000076   0x2180             MOVS     R1,#+128
   \   00000078   0x0020             MOVS     R0,R4
   \   0000007A   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD001             BEQ.N    ??HAL_UART_Transmit_12
   \   00000082   0x2003             MOVS     R0,#+3
   \   00000084   0xE030             B.N      ??HAL_UART_Transmit_4
   \                     ??HAL_UART_Transmit_12: (+1)
   \   00000086   0x8828             LDRH     R0,[R5, #+0]
   \   00000088   0x05C0             LSLS     R0,R0,#+23       ;; ZeroExtS R0,R0,#+23,#+23
   \   0000008A   0x0DC0             LSRS     R0,R0,#+23
   \   0000008C   0x6821             LDR      R1,[R4, #+0]
   \   0000008E   0x6048             STR      R0,[R1, #+4]
   \   00000090   0x6920             LDR      R0,[R4, #+16]
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD101             BNE.N    ??HAL_UART_Transmit_13
   \   00000096   0x1CAD             ADDS     R5,R5,#+2
   \   00000098   0xE7E1             B.N      ??HAL_UART_Transmit_8
   \                     ??HAL_UART_Transmit_13: (+1)
   \   0000009A   0x1C6D             ADDS     R5,R5,#+1
   \   0000009C   0xE7DF             B.N      ??HAL_UART_Transmit_8
   \                     ??HAL_UART_Transmit_11: (+1)
   \   0000009E   0x0033             MOVS     R3,R6
   \   000000A0   0x2200             MOVS     R2,#+0
   \   000000A2   0x2180             MOVS     R1,#+128
   \   000000A4   0x0020             MOVS     R0,R4
   \   000000A6   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD0D3             BEQ.N    ??HAL_UART_Transmit_9
   \   000000AE   0x2003             MOVS     R0,#+3
   \   000000B0   0xE01A             B.N      ??HAL_UART_Transmit_4
    690                }
    691              }
    692          
    693              if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, Timeout) != HAL_OK)
   \                     ??HAL_UART_Transmit_10: (+1)
   \   000000B2   0x0033             MOVS     R3,R6
   \   000000B4   0x2200             MOVS     R2,#+0
   \   000000B6   0x2140             MOVS     R1,#+64
   \   000000B8   0x0020             MOVS     R0,R4
   \   000000BA   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   000000BE   0x2800             CMP      R0,#+0
   \   000000C0   0xD001             BEQ.N    ??HAL_UART_Transmit_14
    694              { 
    695                return HAL_TIMEOUT;
   \   000000C2   0x2003             MOVS     R0,#+3
   \   000000C4   0xE010             B.N      ??HAL_UART_Transmit_4
    696              }
    697          
    698              /* Check if a non-blocking receive process is ongoing or not */
    699              if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   \                     ??HAL_UART_Transmit_14: (+1)
   \   000000C6   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   000000CA   0x2832             CMP      R0,#+50
   \   000000CC   0xD103             BNE.N    ??HAL_UART_Transmit_15
    700              {
    701                huart->State = HAL_UART_STATE_BUSY_RX;
   \   000000CE   0x2022             MOVS     R0,#+34
   \   000000D0   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   000000D4   0xE002             B.N      ??HAL_UART_Transmit_16
    702              }
    703              else
    704              {
    705                huart->State = HAL_UART_STATE_READY;
   \                     ??HAL_UART_Transmit_15: (+1)
   \   000000D6   0x2001             MOVS     R0,#+1
   \   000000D8   0xF884 0x0039      STRB     R0,[R4, #+57]
    706              }
    707          
    708              /* Process Unlocked */
    709              __HAL_UNLOCK(huart);
   \                     ??HAL_UART_Transmit_16: (+1)
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0xF884 0x0038      STRB     R0,[R4, #+56]
    710          
    711              return HAL_OK;
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0xE000             B.N      ??HAL_UART_Transmit_4
    712            }
    713            else
    714            {
    715              return HAL_BUSY;
   \                     ??HAL_UART_Transmit_1: (+1)
   \   000000E6   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Transmit_4: (+1)
   \   000000E8   0xBD70             POP      {R4-R6,PC}       ;; return
    716            }
    717          }
    718          
    719          /**
    720            * @brief  Receives an amount of data in blocking mode. 
    721            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    722            *                the configuration information for the specified UART module.
    723            * @param  pData: Pointer to data buffer
    724            * @param  Size: Amount of data to be received
    725            * @param  Timeout: Timeout duration
    726            * @retval HAL status
    727            */

   \                                 In section .text, align 2, keep-with-next
    728          HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    729          {
   \                     HAL_UART_Receive: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x001E             MOVS     R6,R3
    730            uint16_t* tmp;
    731            uint32_t  tmp_state = 0;
   \   00000008   0x2000             MOVS     R0,#+0
    732          
    733            tmp_state = huart->State;
   \   0000000A   0xF894 0x0039      LDRB     R0,[R4, #+57]
    734            if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_TX))
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD001             BEQ.N    ??HAL_UART_Receive_0
   \   00000012   0x2812             CMP      R0,#+18
   \   00000014   0xD16C             BNE.N    ??HAL_UART_Receive_1
    735            {
    736              if((pData == NULL ) || (Size == 0))
   \                     ??HAL_UART_Receive_0: (+1)
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD002             BEQ.N    ??HAL_UART_Receive_2
   \   0000001A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000001C   0x2A00             CMP      R2,#+0
   \   0000001E   0xD101             BNE.N    ??HAL_UART_Receive_3
    737              {
    738                return  HAL_ERROR;
   \                     ??HAL_UART_Receive_2: (+1)
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xE066             B.N      ??HAL_UART_Receive_4
    739              }
    740          
    741              /* Process Locked */
    742              __HAL_LOCK(huart);
   \                     ??HAL_UART_Receive_3: (+1)
   \   00000024   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD101             BNE.N    ??HAL_UART_Receive_5
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0xE060             B.N      ??HAL_UART_Receive_4
   \                     ??HAL_UART_Receive_5: (+1)
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0xF884 0x0038      STRB     R0,[R4, #+56]
    743          
    744              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x63E0             STR      R0,[R4, #+60]
    745              /* Check if a non-blocking transmit process is ongoing or not */
    746              if(huart->State == HAL_UART_STATE_BUSY_TX)
   \   0000003A   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000003E   0x2812             CMP      R0,#+18
   \   00000040   0xD103             BNE.N    ??HAL_UART_Receive_6
    747              {
    748                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   00000042   0x2032             MOVS     R0,#+50
   \   00000044   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000048   0xE002             B.N      ??HAL_UART_Receive_7
    749              }
    750              else
    751              {
    752                huart->State = HAL_UART_STATE_BUSY_RX;
   \                     ??HAL_UART_Receive_6: (+1)
   \   0000004A   0x2022             MOVS     R0,#+34
   \   0000004C   0xF884 0x0039      STRB     R0,[R4, #+57]
    753              }
    754          
    755              huart->RxXferSize = Size;
   \                     ??HAL_UART_Receive_7: (+1)
   \   00000050   0x85A2             STRH     R2,[R4, #+44]
    756              huart->RxXferCount = Size;
   \   00000052   0x85E2             STRH     R2,[R4, #+46]
   \   00000054   0xE005             B.N      ??HAL_UART_Receive_8
    757          
    758              /* Check the remain data to be received */
    759              while(huart->RxXferCount > 0)
    760              {
    761                huart->RxXferCount--;
    762                if(huart->Init.WordLength == UART_WORDLENGTH_9B)
    763                {
    764                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, Timeout) != HAL_OK)
    765                  {
    766                    return HAL_TIMEOUT;
    767                  }
    768                  tmp = (uint16_t*) pData ;
    769                  if(huart->Init.Parity == UART_PARITY_NONE)
    770                  {
    771                    *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
   \                     ??HAL_UART_Receive_9: (+1)
   \   00000056   0x6821             LDR      R1,[R4, #+0]
   \   00000058   0x6849             LDR      R1,[R1, #+4]
   \   0000005A   0x05C9             LSLS     R1,R1,#+23       ;; ZeroExtS R1,R1,#+23,#+23
   \   0000005C   0x0DC9             LSRS     R1,R1,#+23
   \   0000005E   0x8001             STRH     R1,[R0, #+0]
    772                    pData +=2;
   \   00000060   0x1CAD             ADDS     R5,R5,#+2
    773                  }
   \                     ??HAL_UART_Receive_8: (+1)
   \   00000062   0x8DE0             LDRH     R0,[R4, #+46]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD033             BEQ.N    ??HAL_UART_Receive_10
   \   00000068   0x8DE0             LDRH     R0,[R4, #+46]
   \   0000006A   0x1E40             SUBS     R0,R0,#+1
   \   0000006C   0x85E0             STRH     R0,[R4, #+46]
   \   0000006E   0x68A0             LDR      R0,[R4, #+8]
   \   00000070   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000074   0xD113             BNE.N    ??HAL_UART_Receive_11
   \   00000076   0x0033             MOVS     R3,R6
   \   00000078   0x2200             MOVS     R2,#+0
   \   0000007A   0x2120             MOVS     R1,#+32
   \   0000007C   0x0020             MOVS     R0,R4
   \   0000007E   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD001             BEQ.N    ??HAL_UART_Receive_12
   \   00000086   0x2003             MOVS     R0,#+3
   \   00000088   0xE033             B.N      ??HAL_UART_Receive_4
   \                     ??HAL_UART_Receive_12: (+1)
   \   0000008A   0x0028             MOVS     R0,R5
   \   0000008C   0x6921             LDR      R1,[R4, #+16]
   \   0000008E   0x2900             CMP      R1,#+0
   \   00000090   0xD0E1             BEQ.N    ??HAL_UART_Receive_9
    774                  else
    775                  {
    776                    *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
   \   00000092   0x6821             LDR      R1,[R4, #+0]
   \   00000094   0x6849             LDR      R1,[R1, #+4]
   \   00000096   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000098   0x8001             STRH     R1,[R0, #+0]
    777                    pData +=1;
   \   0000009A   0x1C6D             ADDS     R5,R5,#+1
   \   0000009C   0xE7E1             B.N      ??HAL_UART_Receive_8
    778                  }
    779          
    780                }
    781                else
    782                {
    783                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \                     ??HAL_UART_Receive_11: (+1)
   \   0000009E   0x0033             MOVS     R3,R6
   \   000000A0   0x2200             MOVS     R2,#+0
   \   000000A2   0x2120             MOVS     R1,#+32
   \   000000A4   0x0020             MOVS     R0,R4
   \   000000A6   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD001             BEQ.N    ??HAL_UART_Receive_13
    784                  {
    785                    return HAL_TIMEOUT;
   \   000000AE   0x2003             MOVS     R0,#+3
   \   000000B0   0xE01F             B.N      ??HAL_UART_Receive_4
    786                  }
    787                  if(huart->Init.Parity == UART_PARITY_NONE)
   \                     ??HAL_UART_Receive_13: (+1)
   \   000000B2   0x6920             LDR      R0,[R4, #+16]
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD104             BNE.N    ??HAL_UART_Receive_14
    788                  {
    789                    *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
   \   000000B8   0x6820             LDR      R0,[R4, #+0]
   \   000000BA   0x6840             LDR      R0,[R0, #+4]
   \   000000BC   0x7028             STRB     R0,[R5, #+0]
   \   000000BE   0x1C6D             ADDS     R5,R5,#+1
   \   000000C0   0xE7CF             B.N      ??HAL_UART_Receive_8
    790                  }
    791                  else
    792                  {
    793                    *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
   \                     ??HAL_UART_Receive_14: (+1)
   \   000000C2   0x6820             LDR      R0,[R4, #+0]
   \   000000C4   0x6840             LDR      R0,[R0, #+4]
   \   000000C6   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   000000CA   0x7028             STRB     R0,[R5, #+0]
   \   000000CC   0x1C6D             ADDS     R5,R5,#+1
   \   000000CE   0xE7C8             B.N      ??HAL_UART_Receive_8
    794                  }
    795          
    796                }
    797              }
    798          
    799              /* Check if a non-blocking transmit process is ongoing or not */
    800              if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   \                     ??HAL_UART_Receive_10: (+1)
   \   000000D0   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   000000D4   0x2832             CMP      R0,#+50
   \   000000D6   0xD103             BNE.N    ??HAL_UART_Receive_15
    801              {
    802                huart->State = HAL_UART_STATE_BUSY_TX;
   \   000000D8   0x2012             MOVS     R0,#+18
   \   000000DA   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   000000DE   0xE002             B.N      ??HAL_UART_Receive_16
    803              }
    804              else
    805              {
    806                huart->State = HAL_UART_STATE_READY;
   \                     ??HAL_UART_Receive_15: (+1)
   \   000000E0   0x2001             MOVS     R0,#+1
   \   000000E2   0xF884 0x0039      STRB     R0,[R4, #+57]
    807              }
    808              /* Process Unlocked */
    809              __HAL_UNLOCK(huart);
   \                     ??HAL_UART_Receive_16: (+1)
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0xF884 0x0038      STRB     R0,[R4, #+56]
    810          
    811              return HAL_OK;
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0xE000             B.N      ??HAL_UART_Receive_4
    812            }
    813            else
    814            {
    815              return HAL_BUSY;
   \                     ??HAL_UART_Receive_1: (+1)
   \   000000F0   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Receive_4: (+1)
   \   000000F2   0xBD70             POP      {R4-R6,PC}       ;; return
    816            }
    817          }
    818          
    819          /**
    820            * @brief  Sends an amount of data in non blocking mode.
    821            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    822            *                the configuration information for the specified UART module.
    823            * @param  pData: Pointer to data buffer
    824            * @param  Size: Amount of data to be sent
    825            * @retval HAL status
    826            */

   \                                 In section .text, align 2, keep-with-next
    827          HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    828          {
    829            uint32_t tmp_state = 0;
   \                     HAL_UART_Transmit_IT: (+1)
   \   00000000   0x2300             MOVS     R3,#+0
    830          
    831            tmp_state = huart->State;
   \   00000002   0xF890 0x3039      LDRB     R3,[R0, #+57]
    832            if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_RX))
   \   00000006   0x2B01             CMP      R3,#+1
   \   00000008   0xD001             BEQ.N    ??HAL_UART_Transmit_IT_0
   \   0000000A   0x2B22             CMP      R3,#+34
   \   0000000C   0xD12A             BNE.N    ??HAL_UART_Transmit_IT_1
    833            {
    834              if((pData == NULL ) || (Size == 0))
   \                     ??HAL_UART_Transmit_IT_0: (+1)
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD002             BEQ.N    ??HAL_UART_Transmit_IT_2
   \   00000012   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000014   0x2A00             CMP      R2,#+0
   \   00000016   0xD101             BNE.N    ??HAL_UART_Transmit_IT_3
    835              {
    836                return HAL_ERROR;
   \                     ??HAL_UART_Transmit_IT_2: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xE024             B.N      ??HAL_UART_Transmit_IT_4
    837              }
    838              
    839              /* Process Locked */
    840              __HAL_LOCK(huart);
   \                     ??HAL_UART_Transmit_IT_3: (+1)
   \   0000001C   0xF890 0x3038      LDRB     R3,[R0, #+56]
   \   00000020   0x2B01             CMP      R3,#+1
   \   00000022   0xD101             BNE.N    ??HAL_UART_Transmit_IT_5
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0xE01E             B.N      ??HAL_UART_Transmit_IT_4
   \                     ??HAL_UART_Transmit_IT_5: (+1)
   \   00000028   0x2301             MOVS     R3,#+1
   \   0000002A   0xF880 0x3038      STRB     R3,[R0, #+56]
    841              
    842              huart->pTxBuffPtr = pData;
   \   0000002E   0x6201             STR      R1,[R0, #+32]
    843              huart->TxXferSize = Size;
   \   00000030   0x8482             STRH     R2,[R0, #+36]
    844              huart->TxXferCount = Size;
   \   00000032   0x84C2             STRH     R2,[R0, #+38]
    845          
    846              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x63C1             STR      R1,[R0, #+60]
    847              /* Check if a receive process is ongoing or not */
    848              if(huart->State == HAL_UART_STATE_BUSY_RX) 
   \   00000038   0xF890 0x1039      LDRB     R1,[R0, #+57]
   \   0000003C   0x2922             CMP      R1,#+34
   \   0000003E   0xD103             BNE.N    ??HAL_UART_Transmit_IT_6
    849              {
    850                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   00000040   0x2132             MOVS     R1,#+50
   \   00000042   0xF880 0x1039      STRB     R1,[R0, #+57]
   \   00000046   0xE002             B.N      ??HAL_UART_Transmit_IT_7
    851              }
    852              else
    853              {
    854                huart->State = HAL_UART_STATE_BUSY_TX;
   \                     ??HAL_UART_Transmit_IT_6: (+1)
   \   00000048   0x2112             MOVS     R1,#+18
   \   0000004A   0xF880 0x1039      STRB     R1,[R0, #+57]
    855              }
    856          
    857              /* Process Unlocked */
    858              __HAL_UNLOCK(huart);
   \                     ??HAL_UART_Transmit_IT_7: (+1)
   \   0000004E   0x2100             MOVS     R1,#+0
   \   00000050   0xF880 0x1038      STRB     R1,[R0, #+56]
    859          
    860              /* Enable the UART Transmit data register empty Interrupt */
    861              __HAL_UART_ENABLE_IT(huart, UART_IT_TXE);
   \   00000054   0x6801             LDR      R1,[R0, #+0]
   \   00000056   0x68C9             LDR      R1,[R1, #+12]
   \   00000058   0xF051 0x0180      ORRS     R1,R1,#0x80
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x60C1             STR      R1,[R0, #+12]
    862              
    863              return HAL_OK;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xE000             B.N      ??HAL_UART_Transmit_IT_4
    864            }
    865            else
    866            {
    867              return HAL_BUSY;
   \                     ??HAL_UART_Transmit_IT_1: (+1)
   \   00000064   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Transmit_IT_4: (+1)
   \   00000066   0x4770             BX       LR               ;; return
    868            }
    869          }
    870          
    871          /**
    872            * @brief  Receives an amount of data in non blocking mode 
    873            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    874            *                the configuration information for the specified UART module.
    875            * @param  pData: Pointer to data buffer
    876            * @param  Size: Amount of data to be received
    877            * @retval HAL status
    878            */

   \                                 In section .text, align 2, keep-with-next
    879          HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    880          {
    881            uint32_t tmp_state = 0;
   \                     HAL_UART_Receive_IT: (+1)
   \   00000000   0x2300             MOVS     R3,#+0
    882            
    883            tmp_state = huart->State;
   \   00000002   0xF890 0x3039      LDRB     R3,[R0, #+57]
    884            if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_TX))
   \   00000006   0x2B01             CMP      R3,#+1
   \   00000008   0xD001             BEQ.N    ??HAL_UART_Receive_IT_0
   \   0000000A   0x2B12             CMP      R3,#+18
   \   0000000C   0xD136             BNE.N    ??HAL_UART_Receive_IT_1
    885            {
    886              if((pData == NULL ) || (Size == 0))
   \                     ??HAL_UART_Receive_IT_0: (+1)
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD002             BEQ.N    ??HAL_UART_Receive_IT_2
   \   00000012   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000014   0x2A00             CMP      R2,#+0
   \   00000016   0xD101             BNE.N    ??HAL_UART_Receive_IT_3
    887              {
    888                return HAL_ERROR;
   \                     ??HAL_UART_Receive_IT_2: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xE030             B.N      ??HAL_UART_Receive_IT_4
    889              }
    890          
    891              /* Process Locked */
    892              __HAL_LOCK(huart);
   \                     ??HAL_UART_Receive_IT_3: (+1)
   \   0000001C   0xF890 0x3038      LDRB     R3,[R0, #+56]
   \   00000020   0x2B01             CMP      R3,#+1
   \   00000022   0xD101             BNE.N    ??HAL_UART_Receive_IT_5
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0xE02A             B.N      ??HAL_UART_Receive_IT_4
   \                     ??HAL_UART_Receive_IT_5: (+1)
   \   00000028   0x2301             MOVS     R3,#+1
   \   0000002A   0xF880 0x3038      STRB     R3,[R0, #+56]
    893          
    894              huart->pRxBuffPtr = pData;
   \   0000002E   0x6281             STR      R1,[R0, #+40]
    895              huart->RxXferSize = Size;
   \   00000030   0x8582             STRH     R2,[R0, #+44]
    896              huart->RxXferCount = Size;
   \   00000032   0x85C2             STRH     R2,[R0, #+46]
    897          
    898              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x63C1             STR      R1,[R0, #+60]
    899              /* Check if a transmit process is ongoing or not */
    900              if(huart->State == HAL_UART_STATE_BUSY_TX)
   \   00000038   0xF890 0x1039      LDRB     R1,[R0, #+57]
   \   0000003C   0x2912             CMP      R1,#+18
   \   0000003E   0xD103             BNE.N    ??HAL_UART_Receive_IT_6
    901              {
    902                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   00000040   0x2132             MOVS     R1,#+50
   \   00000042   0xF880 0x1039      STRB     R1,[R0, #+57]
   \   00000046   0xE002             B.N      ??HAL_UART_Receive_IT_7
    903              }
    904              else
    905              {
    906                huart->State = HAL_UART_STATE_BUSY_RX;
   \                     ??HAL_UART_Receive_IT_6: (+1)
   \   00000048   0x2122             MOVS     R1,#+34
   \   0000004A   0xF880 0x1039      STRB     R1,[R0, #+57]
    907              }
    908          
    909              /* Process Unlocked */
    910              __HAL_UNLOCK(huart);
   \                     ??HAL_UART_Receive_IT_7: (+1)
   \   0000004E   0x2100             MOVS     R1,#+0
   \   00000050   0xF880 0x1038      STRB     R1,[R0, #+56]
    911          
    912              /* Enable the UART Parity Error Interrupt */
    913              __HAL_UART_ENABLE_IT(huart, UART_IT_PE);
   \   00000054   0x6801             LDR      R1,[R0, #+0]
   \   00000056   0x68C9             LDR      R1,[R1, #+12]
   \   00000058   0xF451 0x7180      ORRS     R1,R1,#0x100
   \   0000005C   0x6802             LDR      R2,[R0, #+0]
   \   0000005E   0x60D1             STR      R1,[R2, #+12]
    914          
    915              /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
    916              __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
   \   00000060   0x6801             LDR      R1,[R0, #+0]
   \   00000062   0x6949             LDR      R1,[R1, #+20]
   \   00000064   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   00000068   0x6802             LDR      R2,[R0, #+0]
   \   0000006A   0x6151             STR      R1,[R2, #+20]
    917          
    918              /* Enable the UART Data Register not empty Interrupt */
    919              __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE);
   \   0000006C   0x6801             LDR      R1,[R0, #+0]
   \   0000006E   0x68C9             LDR      R1,[R1, #+12]
   \   00000070   0xF051 0x0120      ORRS     R1,R1,#0x20
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0x60C1             STR      R1,[R0, #+12]
    920          
    921              return HAL_OK;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xE000             B.N      ??HAL_UART_Receive_IT_4
    922            }
    923            else
    924            {
    925              return HAL_BUSY;
   \                     ??HAL_UART_Receive_IT_1: (+1)
   \   0000007C   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Receive_IT_4: (+1)
   \   0000007E   0x4770             BX       LR               ;; return
    926            }
    927          }
    928          
    929          /**
    930            * @brief  Sends an amount of data in non blocking mode. 
    931            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    932            *                the configuration information for the specified UART module.
    933            * @param  pData: Pointer to data buffer
    934            * @param  Size: Amount of data to be sent
    935            * @retval HAL status
    936            */

   \                                 In section .text, align 2, keep-with-next
    937          HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    938          {
   \                     HAL_UART_Transmit_DMA: (+1)
   \   00000000   0xB513             PUSH     {R0,R1,R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    939            uint32_t *tmp;
    940            uint32_t tmp_state = 0;
   \   00000004   0x2000             MOVS     R0,#+0
    941          
    942            tmp_state = huart->State;
   \   00000006   0xF894 0x0039      LDRB     R0,[R4, #+57]
    943            if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_RX))
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD001             BEQ.N    ??HAL_UART_Transmit_DMA_0
   \   0000000E   0x2822             CMP      R0,#+34
   \   00000010   0xD145             BNE.N    ??HAL_UART_Transmit_DMA_1
    944            {
    945              if((pData == NULL ) || (Size == 0)) 
   \                     ??HAL_UART_Transmit_DMA_0: (+1)
   \   00000012   0x9801             LDR      R0,[SP, #+4]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD002             BEQ.N    ??HAL_UART_Transmit_DMA_2
   \   00000018   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xD101             BNE.N    ??HAL_UART_Transmit_DMA_3
    946              {
    947                return HAL_ERROR;
   \                     ??HAL_UART_Transmit_DMA_2: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE03E             B.N      ??HAL_UART_Transmit_DMA_4
    948              }
    949          
    950              /* Process Locked */
    951              __HAL_LOCK(huart);
   \                     ??HAL_UART_Transmit_DMA_3: (+1)
   \   00000022   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD101             BNE.N    ??HAL_UART_Transmit_DMA_5
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0xE038             B.N      ??HAL_UART_Transmit_DMA_4
   \                     ??HAL_UART_Transmit_DMA_5: (+1)
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF884 0x0038      STRB     R0,[R4, #+56]
    952          
    953              huart->pTxBuffPtr = pData;
   \   00000034   0x9801             LDR      R0,[SP, #+4]
   \   00000036   0x6220             STR      R0,[R4, #+32]
    954              huart->TxXferSize = Size;
   \   00000038   0x84A2             STRH     R2,[R4, #+36]
    955              huart->TxXferCount = Size;
   \   0000003A   0x84E2             STRH     R2,[R4, #+38]
    956          
    957              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x63E0             STR      R0,[R4, #+60]
    958              /* Check if a receive process is ongoing or not */
    959              if(huart->State == HAL_UART_STATE_BUSY_RX)
   \   00000040   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000044   0x2822             CMP      R0,#+34
   \   00000046   0xD103             BNE.N    ??HAL_UART_Transmit_DMA_6
    960              {
    961                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   00000048   0x2032             MOVS     R0,#+50
   \   0000004A   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   0000004E   0xE002             B.N      ??HAL_UART_Transmit_DMA_7
    962              }
    963              else
    964              {
    965                huart->State = HAL_UART_STATE_BUSY_TX;
   \                     ??HAL_UART_Transmit_DMA_6: (+1)
   \   00000050   0x2012             MOVS     R0,#+18
   \   00000052   0xF884 0x0039      STRB     R0,[R4, #+57]
    966              }
    967          
    968              /* Set the UART DMA transfer complete callback */
    969              huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
   \                     ??HAL_UART_Transmit_DMA_7: (+1)
   \   00000056   0x.... 0x....      ADR.W    R0,UART_DMATransmitCplt
   \   0000005A   0x6B21             LDR      R1,[R4, #+48]
   \   0000005C   0x6288             STR      R0,[R1, #+40]
    970          
    971              /* Set the UART DMA Half transfer complete callback */
    972              huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
   \   0000005E   0x.... 0x....      ADR.W    R0,UART_DMATxHalfCplt
   \   00000062   0x6B21             LDR      R1,[R4, #+48]
   \   00000064   0x62C8             STR      R0,[R1, #+44]
    973          
    974              /* Set the DMA error callback */
    975              huart->hdmatx->XferErrorCallback = UART_DMAError;
   \   00000066   0x.... 0x....      ADR.W    R0,UART_DMAError
   \   0000006A   0x6B21             LDR      R1,[R4, #+48]
   \   0000006C   0x6308             STR      R0,[R1, #+48]
    976          
    977              /* Enable the UART transmit DMA channel */
    978              tmp = (uint32_t*)&pData;
   \   0000006E   0xA801             ADD      R0,SP,#+4
    979              HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t*)tmp, (uint32_t)&huart->Instance->DR, Size);
   \   00000070   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000072   0x0013             MOVS     R3,R2
   \   00000074   0x6821             LDR      R1,[R4, #+0]
   \   00000076   0x1D0A             ADDS     R2,R1,#+4
   \   00000078   0x6801             LDR      R1,[R0, #+0]
   \   0000007A   0x6B20             LDR      R0,[R4, #+48]
   \   0000007C   0x.... 0x....      BL       HAL_DMA_Start_IT
    980          
    981              /* Clear the TC flag in the SR register by writing 0 to it */
    982              __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
   \   00000080   0xF07F 0x0040      MVNS     R0,#+64
   \   00000084   0x6821             LDR      R1,[R4, #+0]
   \   00000086   0x6008             STR      R0,[R1, #+0]
    983          
    984              /* Enable the DMA transfer for transmit request by setting the DMAT bit
    985                 in the UART CR3 register */
    986              SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x6940             LDR      R0,[R0, #+20]
   \   0000008C   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000090   0x6821             LDR      R1,[R4, #+0]
   \   00000092   0x6148             STR      R0,[R1, #+20]
    987          
    988              /* Process Unlocked */
    989              __HAL_UNLOCK(huart);
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xF884 0x0038      STRB     R0,[R4, #+56]
    990          
    991              return HAL_OK;
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xE000             B.N      ??HAL_UART_Transmit_DMA_4
    992            }
    993            else
    994            {
    995              return HAL_BUSY;
   \                     ??HAL_UART_Transmit_DMA_1: (+1)
   \   0000009E   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Transmit_DMA_4: (+1)
   \   000000A0   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    996            }
    997          }
    998          
    999          /**
   1000            * @brief  Receives an amount of data in non blocking mode. 
   1001            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1002            *                the configuration information for the specified UART module.
   1003            * @param  pData: Pointer to data buffer
   1004            * @param  Size: Amount of data to be received
   1005            * @note   When the UART parity is enabled (PCE = 1), the received data contain 
   1006            *         the parity bit (MSB position)     
   1007            * @retval HAL status
   1008            */

   \                                 In section .text, align 2, keep-with-next
   1009          HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
   1010          {
   \                     HAL_UART_Receive_DMA: (+1)
   \   00000000   0xB513             PUSH     {R0,R1,R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1011            uint32_t *tmp;
   1012            uint32_t tmp_state = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   1013          
   1014            tmp_state = huart->State;
   \   00000006   0xF894 0x0039      LDRB     R0,[R4, #+57]
   1015            if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_TX))
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD001             BEQ.N    ??HAL_UART_Receive_DMA_0
   \   0000000E   0x2812             CMP      R0,#+18
   \   00000010   0xD140             BNE.N    ??HAL_UART_Receive_DMA_1
   1016            {
   1017              if((pData == NULL ) || (Size == 0))
   \                     ??HAL_UART_Receive_DMA_0: (+1)
   \   00000012   0x9801             LDR      R0,[SP, #+4]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD002             BEQ.N    ??HAL_UART_Receive_DMA_2
   \   00000018   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xD101             BNE.N    ??HAL_UART_Receive_DMA_3
   1018              {
   1019                return HAL_ERROR;
   \                     ??HAL_UART_Receive_DMA_2: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE039             B.N      ??HAL_UART_Receive_DMA_4
   1020              }
   1021          
   1022              /* Process Locked */
   1023              __HAL_LOCK(huart);
   \                     ??HAL_UART_Receive_DMA_3: (+1)
   \   00000022   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD101             BNE.N    ??HAL_UART_Receive_DMA_5
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0xE033             B.N      ??HAL_UART_Receive_DMA_4
   \                     ??HAL_UART_Receive_DMA_5: (+1)
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF884 0x0038      STRB     R0,[R4, #+56]
   1024          
   1025              huart->pRxBuffPtr = pData;
   \   00000034   0x9801             LDR      R0,[SP, #+4]
   \   00000036   0x62A0             STR      R0,[R4, #+40]
   1026              huart->RxXferSize = Size;
   \   00000038   0x85A2             STRH     R2,[R4, #+44]
   1027          
   1028              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x63E0             STR      R0,[R4, #+60]
   1029              /* Check if a transmit process is ongoing or not */
   1030              if(huart->State == HAL_UART_STATE_BUSY_TX)
   \   0000003E   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000042   0x2812             CMP      R0,#+18
   \   00000044   0xD103             BNE.N    ??HAL_UART_Receive_DMA_6
   1031              {
   1032                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   00000046   0x2032             MOVS     R0,#+50
   \   00000048   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   0000004C   0xE002             B.N      ??HAL_UART_Receive_DMA_7
   1033              }
   1034              else
   1035              {
   1036                huart->State = HAL_UART_STATE_BUSY_RX;
   \                     ??HAL_UART_Receive_DMA_6: (+1)
   \   0000004E   0x2022             MOVS     R0,#+34
   \   00000050   0xF884 0x0039      STRB     R0,[R4, #+57]
   1037              }
   1038          
   1039              /* Set the UART DMA transfer complete callback */
   1040              huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
   \                     ??HAL_UART_Receive_DMA_7: (+1)
   \   00000054   0x.... 0x....      ADR.W    R0,UART_DMAReceiveCplt
   \   00000058   0x6B61             LDR      R1,[R4, #+52]
   \   0000005A   0x6288             STR      R0,[R1, #+40]
   1041          
   1042              /* Set the UART DMA Half transfer complete callback */
   1043              huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
   \   0000005C   0x.... 0x....      ADR.W    R0,UART_DMARxHalfCplt
   \   00000060   0x6B61             LDR      R1,[R4, #+52]
   \   00000062   0x62C8             STR      R0,[R1, #+44]
   1044          
   1045              /* Set the DMA error callback */
   1046              huart->hdmarx->XferErrorCallback = UART_DMAError;
   \   00000064   0x.... 0x....      ADR.W    R0,UART_DMAError
   \   00000068   0x6B61             LDR      R1,[R4, #+52]
   \   0000006A   0x6308             STR      R0,[R1, #+48]
   1047          
   1048              /* Enable the DMA channel */
   1049              tmp = (uint32_t*)&pData;
   \   0000006C   0xA801             ADD      R0,SP,#+4
   1050              HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t*)tmp, Size);
   \   0000006E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000070   0x0013             MOVS     R3,R2
   \   00000072   0x6802             LDR      R2,[R0, #+0]
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x1D01             ADDS     R1,R0,#+4
   \   00000078   0x6B60             LDR      R0,[R4, #+52]
   \   0000007A   0x.... 0x....      BL       HAL_DMA_Start_IT
   1051          
   1052              /* Enable the DMA transfer for the receiver request by setting the DMAR bit 
   1053                 in the UART CR3 register */
   1054              SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0x6940             LDR      R0,[R0, #+20]
   \   00000082   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000086   0x6821             LDR      R1,[R4, #+0]
   \   00000088   0x6148             STR      R0,[R1, #+20]
   1055          
   1056              /* Process Unlocked */
   1057              __HAL_UNLOCK(huart);
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0xF884 0x0038      STRB     R0,[R4, #+56]
   1058          
   1059              return HAL_OK;
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0xE000             B.N      ??HAL_UART_Receive_DMA_4
   1060            }
   1061            else
   1062            {
   1063              return HAL_BUSY;
   \                     ??HAL_UART_Receive_DMA_1: (+1)
   \   00000094   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Receive_DMA_4: (+1)
   \   00000096   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1064            }
   1065          }
   1066              
   1067          /**
   1068            * @brief Pauses the DMA Transfer.
   1069            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1070            *                the configuration information for the specified UART module.
   1071            * @retval HAL status
   1072            */

   \                                 In section .text, align 2, keep-with-next
   1073          HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
   1074          {
   1075            /* Process Locked */
   1076            __HAL_LOCK(huart);
   \                     HAL_UART_DMAPause: (+1)
   \   00000000   0xF890 0x1038      LDRB     R1,[R0, #+56]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_UART_DMAPause_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0xE010             B.N      ??HAL_UART_DMAPause_1
   \                     ??HAL_UART_DMAPause_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x1038      STRB     R1,[R0, #+56]
   1077            
   1078            if(huart->State == HAL_UART_STATE_BUSY_TX)
   \   00000012   0xF890 0x1039      LDRB     R1,[R0, #+57]
   \   00000016   0x2912             CMP      R1,#+18
   \   00000018   0xD10A             BNE.N    ??HAL_UART_DMAPause_2
   1079            {
   1080              /* Disable the UART DMA Tx request */
   1081              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \   0000001A   0x6801             LDR      R1,[R0, #+0]
   \   0000001C   0x6949             LDR      R1,[R1, #+20]
   \   0000001E   0xF031 0x0180      BICS     R1,R1,#0x80
   \   00000022   0x6802             LDR      R2,[R0, #+0]
   \   00000024   0x6151             STR      R1,[R2, #+20]
   1082            }
   1083            else if(huart->State == HAL_UART_STATE_BUSY_RX)
   1084            {
   1085              /* Disable the UART DMA Rx request */
   1086              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   1087            }
   1088            else if (huart->State == HAL_UART_STATE_BUSY_TX_RX)
   1089            {
   1090              /* Disable the UART DMA Tx & Rx requests */
   1091              CLEAR_BIT(huart->Instance->CR3, (USART_CR3_DMAT | USART_CR3_DMAR));
   1092            }
   1093            else
   1094            {
   1095              /* Process Unlocked */
   1096              __HAL_UNLOCK(huart);
   1097            
   1098              return HAL_ERROR; 
   1099            }
   1100            
   1101            /* Process Unlocked */
   1102            __HAL_UNLOCK(huart);
   \                     ??HAL_UART_DMAPause_3: (+1)
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0xF880 0x1038      STRB     R1,[R0, #+56]
   1103          
   1104            return HAL_OK; 
   \   0000002C   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_DMAPause_1: (+1)
   \   0000002E   0x4770             BX       LR               ;; return
   \                     ??HAL_UART_DMAPause_2: (+1)
   \   00000030   0xF890 0x1039      LDRB     R1,[R0, #+57]
   \   00000034   0x2922             CMP      R1,#+34
   \   00000036   0xD106             BNE.N    ??HAL_UART_DMAPause_4
   \   00000038   0x6801             LDR      R1,[R0, #+0]
   \   0000003A   0x6949             LDR      R1,[R1, #+20]
   \   0000003C   0xF031 0x0140      BICS     R1,R1,#0x40
   \   00000040   0x6802             LDR      R2,[R0, #+0]
   \   00000042   0x6151             STR      R1,[R2, #+20]
   \   00000044   0xE7EF             B.N      ??HAL_UART_DMAPause_3
   \                     ??HAL_UART_DMAPause_4: (+1)
   \   00000046   0xF890 0x1039      LDRB     R1,[R0, #+57]
   \   0000004A   0x2932             CMP      R1,#+50
   \   0000004C   0xD106             BNE.N    ??HAL_UART_DMAPause_5
   \   0000004E   0x6801             LDR      R1,[R0, #+0]
   \   00000050   0x6949             LDR      R1,[R1, #+20]
   \   00000052   0xF031 0x01C0      BICS     R1,R1,#0xC0
   \   00000056   0x6802             LDR      R2,[R0, #+0]
   \   00000058   0x6151             STR      R1,[R2, #+20]
   \   0000005A   0xE7E4             B.N      ??HAL_UART_DMAPause_3
   \                     ??HAL_UART_DMAPause_5: (+1)
   \   0000005C   0x2100             MOVS     R1,#+0
   \   0000005E   0xF880 0x1038      STRB     R1,[R0, #+56]
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0xE7E3             B.N      ??HAL_UART_DMAPause_1
   1105          }
   1106          
   1107          /**
   1108            * @brief Resumes the DMA Transfer.
   1109            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1110            *                the configuration information for the specified UART module.
   1111            * @retval HAL status
   1112            */

   \                                 In section .text, align 2, keep-with-next
   1113          HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
   1114          {
   \                     HAL_UART_DMAResume: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
   1115            /* Process Locked */
   1116            __HAL_LOCK(huart);
   \   00000002   0xF890 0x1038      LDRB     R1,[R0, #+56]
   \   00000006   0x2901             CMP      R1,#+1
   \   00000008   0xD101             BNE.N    ??HAL_UART_DMAResume_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE010             B.N      ??HAL_UART_DMAResume_1
   \                     ??HAL_UART_DMAResume_0: (+1)
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0xF880 0x1038      STRB     R1,[R0, #+56]
   1117          
   1118            if(huart->State == HAL_UART_STATE_BUSY_TX)
   \   00000014   0xF890 0x1039      LDRB     R1,[R0, #+57]
   \   00000018   0x2912             CMP      R1,#+18
   \   0000001A   0xD10B             BNE.N    ??HAL_UART_DMAResume_2
   1119            {
   1120              /* Enable the UART DMA Tx request */
   1121              SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \   0000001C   0x6801             LDR      R1,[R0, #+0]
   \   0000001E   0x6949             LDR      R1,[R1, #+20]
   \   00000020   0xF051 0x0180      ORRS     R1,R1,#0x80
   \   00000024   0x6802             LDR      R2,[R0, #+0]
   \   00000026   0x6151             STR      R1,[R2, #+20]
   1122            }
   1123            else if(huart->State == HAL_UART_STATE_BUSY_RX)
   1124            {
   1125              /* Clear the Overrun flag before resumming the Rx transfer*/
   1126              __HAL_UART_CLEAR_OREFLAG(huart);
   1127              /* Enable the UART DMA Rx request */
   1128              SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   1129            }
   1130            else if(huart->State == HAL_UART_STATE_BUSY_TX_RX)
   1131            {
   1132              /* Clear the Overrun flag before resumming the Rx transfer*/
   1133              __HAL_UART_CLEAR_OREFLAG(huart);
   1134              /* Enable the UART DMA Tx & Rx request */
   1135              SET_BIT(huart->Instance->CR3, (USART_CR3_DMAT | USART_CR3_DMAR));
   1136            }
   1137            else
   1138            {
   1139              /* Process Unlocked */
   1140              __HAL_UNLOCK(huart);
   1141          
   1142              return HAL_ERROR; 
   1143            }
   1144          
   1145            /* Process Unlocked */
   1146            __HAL_UNLOCK(huart);
   \                     ??HAL_UART_DMAResume_3: (+1)
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0xF880 0x1038      STRB     R1,[R0, #+56]
   1147          
   1148            return HAL_OK;
   \   0000002E   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_DMAResume_1: (+1)
   \   00000030   0xB001             ADD      SP,SP,#+4
   \   00000032   0x4770             BX       LR               ;; return
   \                     ??HAL_UART_DMAResume_2: (+1)
   \   00000034   0xF890 0x1039      LDRB     R1,[R0, #+57]
   \   00000038   0x2922             CMP      R1,#+34
   \   0000003A   0xD10D             BNE.N    ??HAL_UART_DMAResume_4
   \   0000003C   0x6801             LDR      R1,[R0, #+0]
   \   0000003E   0x6809             LDR      R1,[R1, #+0]
   \   00000040   0x9100             STR      R1,[SP, #+0]
   \   00000042   0x6801             LDR      R1,[R0, #+0]
   \   00000044   0x6849             LDR      R1,[R1, #+4]
   \   00000046   0x9100             STR      R1,[SP, #+0]
   \   00000048   0x9900             LDR      R1,[SP, #+0]
   \   0000004A   0x6801             LDR      R1,[R0, #+0]
   \   0000004C   0x6949             LDR      R1,[R1, #+20]
   \   0000004E   0xF051 0x0140      ORRS     R1,R1,#0x40
   \   00000052   0x6802             LDR      R2,[R0, #+0]
   \   00000054   0x6151             STR      R1,[R2, #+20]
   \   00000056   0xE7E7             B.N      ??HAL_UART_DMAResume_3
   \                     ??HAL_UART_DMAResume_4: (+1)
   \   00000058   0xF890 0x1039      LDRB     R1,[R0, #+57]
   \   0000005C   0x2932             CMP      R1,#+50
   \   0000005E   0xD10D             BNE.N    ??HAL_UART_DMAResume_5
   \   00000060   0x6801             LDR      R1,[R0, #+0]
   \   00000062   0x6809             LDR      R1,[R1, #+0]
   \   00000064   0x9100             STR      R1,[SP, #+0]
   \   00000066   0x6801             LDR      R1,[R0, #+0]
   \   00000068   0x6849             LDR      R1,[R1, #+4]
   \   0000006A   0x9100             STR      R1,[SP, #+0]
   \   0000006C   0x9900             LDR      R1,[SP, #+0]
   \   0000006E   0x6801             LDR      R1,[R0, #+0]
   \   00000070   0x6949             LDR      R1,[R1, #+20]
   \   00000072   0xF051 0x01C0      ORRS     R1,R1,#0xC0
   \   00000076   0x6802             LDR      R2,[R0, #+0]
   \   00000078   0x6151             STR      R1,[R2, #+20]
   \   0000007A   0xE7D5             B.N      ??HAL_UART_DMAResume_3
   \                     ??HAL_UART_DMAResume_5: (+1)
   \   0000007C   0x2100             MOVS     R1,#+0
   \   0000007E   0xF880 0x1038      STRB     R1,[R0, #+56]
   \   00000082   0x2001             MOVS     R0,#+1
   \   00000084   0xE7D4             B.N      ??HAL_UART_DMAResume_1
   1149          }
   1150          
   1151          /**
   1152            * @brief Stops the DMA Transfer.
   1153            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1154            *                the configuration information for the specified UART module.
   1155            * @retval HAL status
   1156            */

   \                                 In section .text, align 2, keep-with-next
   1157          HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
   1158          {
   \                     HAL_UART_DMAStop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1159            /* The Lock is not implemented on this API to allow the user application
   1160               to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback():
   1161               when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
   1162               and the correspond call back is executed HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback()
   1163               */
   1164            
   1165            /* Disable the UART Tx/Rx DMA requests */
   1166            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_DMAT | USART_CR3_DMAR));
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6940             LDR      R0,[R0, #+20]
   \   00000008   0xF030 0x00C0      BICS     R0,R0,#0xC0
   \   0000000C   0x6821             LDR      R1,[R4, #+0]
   \   0000000E   0x6148             STR      R0,[R1, #+20]
   1167            
   1168            /* Abort the UART DMA tx channel */
   1169            if(huart->hdmatx != NULL)
   \   00000010   0x6B20             LDR      R0,[R4, #+48]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD002             BEQ.N    ??HAL_UART_DMAStop_0
   1170            {
   1171              HAL_DMA_Abort(huart->hdmatx);
   \   00000016   0x6B20             LDR      R0,[R4, #+48]
   \   00000018   0x.... 0x....      BL       HAL_DMA_Abort
   1172            }
   1173            /* Abort the UART DMA rx channel */
   1174            if(huart->hdmarx != NULL)
   \                     ??HAL_UART_DMAStop_0: (+1)
   \   0000001C   0x6B60             LDR      R0,[R4, #+52]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD002             BEQ.N    ??HAL_UART_DMAStop_1
   1175            {
   1176              HAL_DMA_Abort(huart->hdmarx);
   \   00000022   0x6B60             LDR      R0,[R4, #+52]
   \   00000024   0x.... 0x....      BL       HAL_DMA_Abort
   1177            }
   1178            
   1179            huart->State = HAL_UART_STATE_READY;
   \                     ??HAL_UART_DMAStop_1: (+1)
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xF884 0x0039      STRB     R0,[R4, #+57]
   1180            
   1181            return HAL_OK;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
   1182          }
   1183          
   1184          /**
   1185            * @brief  This function handles UART interrupt request.
   1186            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1187            *                the configuration information for the specified UART module.
   1188            * @retval None
   1189            */

   \                                 In section .text, align 2, keep-with-next
   1190          void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
   1191          {
   \                     HAL_UART_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   1192            uint32_t tmp_flag = 0, tmp_it_source = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x2100             MOVS     R1,#+0
   1193          
   1194            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_PE);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF010 0x0001      ANDS     R0,R0,#0x1
   1195            tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_PE);  
   \   00000012   0x6821             LDR      R1,[R4, #+0]
   \   00000014   0x68C9             LDR      R1,[R1, #+12]
   \   00000016   0xF411 0x7180      ANDS     R1,R1,#0x100
   1196            /* UART parity error interrupt occurred ------------------------------------*/
   1197            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD005             BEQ.N    ??HAL_UART_IRQHandler_0
   \   0000001E   0x2900             CMP      R1,#+0
   \   00000020   0xD003             BEQ.N    ??HAL_UART_IRQHandler_0
   1198            { 
   1199              huart->ErrorCode |= HAL_UART_ERROR_PE;
   \   00000022   0x6BE0             LDR      R0,[R4, #+60]
   \   00000024   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000028   0x63E0             STR      R0,[R4, #+60]
   1200            }
   1201            
   1202            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_FE);
   \                     ??HAL_UART_IRQHandler_0: (+1)
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x0840             LSRS     R0,R0,#+1
   \   00000030   0xF010 0x0001      ANDS     R0,R0,#0x1
   1203            tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_ERR);
   \   00000034   0x6821             LDR      R1,[R4, #+0]
   \   00000036   0x6949             LDR      R1,[R1, #+20]
   \   00000038   0xF011 0x0101      ANDS     R1,R1,#0x1
   1204            /* UART frame error interrupt occurred -------------------------------------*/
   1205            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD005             BEQ.N    ??HAL_UART_IRQHandler_1
   \   00000040   0x2900             CMP      R1,#+0
   \   00000042   0xD003             BEQ.N    ??HAL_UART_IRQHandler_1
   1206            {
   1207              huart->ErrorCode |= HAL_UART_ERROR_FE;
   \   00000044   0x6BE0             LDR      R0,[R4, #+60]
   \   00000046   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000004A   0x63E0             STR      R0,[R4, #+60]
   1208            }
   1209            
   1210            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_NE);
   \                     ??HAL_UART_IRQHandler_1: (+1)
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0x0880             LSRS     R0,R0,#+2
   \   00000052   0xF010 0x0001      ANDS     R0,R0,#0x1
   1211            /* UART noise error interrupt occurred -------------------------------------*/
   1212            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD005             BEQ.N    ??HAL_UART_IRQHandler_2
   \   0000005A   0x2900             CMP      R1,#+0
   \   0000005C   0xD003             BEQ.N    ??HAL_UART_IRQHandler_2
   1213            {
   1214              huart->ErrorCode |= HAL_UART_ERROR_NE;
   \   0000005E   0x6BE0             LDR      R0,[R4, #+60]
   \   00000060   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000064   0x63E0             STR      R0,[R4, #+60]
   1215            }
   1216            
   1217            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_ORE);
   \                     ??HAL_UART_IRQHandler_2: (+1)
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x08C0             LSRS     R0,R0,#+3
   \   0000006C   0xF010 0x0001      ANDS     R0,R0,#0x1
   1218            /* UART Over-Run interrupt occurred ----------------------------------------*/
   1219            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD005             BEQ.N    ??HAL_UART_IRQHandler_3
   \   00000074   0x2900             CMP      R1,#+0
   \   00000076   0xD003             BEQ.N    ??HAL_UART_IRQHandler_3
   1220            {
   1221              huart->ErrorCode |= HAL_UART_ERROR_ORE;
   \   00000078   0x6BE0             LDR      R0,[R4, #+60]
   \   0000007A   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000007E   0x63E0             STR      R0,[R4, #+60]
   1222            }
   1223            
   1224            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_RXNE);
   \                     ??HAL_UART_IRQHandler_3: (+1)
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0x0940             LSRS     R0,R0,#+5
   \   00000086   0xF010 0x0001      ANDS     R0,R0,#0x1
   1225            tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_RXNE);
   \   0000008A   0x6821             LDR      R1,[R4, #+0]
   \   0000008C   0x68C9             LDR      R1,[R1, #+12]
   \   0000008E   0xF011 0x0120      ANDS     R1,R1,#0x20
   1226            /* UART in mode Receiver ---------------------------------------------------*/
   1227            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD004             BEQ.N    ??HAL_UART_IRQHandler_4
   \   00000096   0x2900             CMP      R1,#+0
   \   00000098   0xD002             BEQ.N    ??HAL_UART_IRQHandler_4
   1228            { 
   1229              UART_Receive_IT(huart);
   \   0000009A   0x0020             MOVS     R0,R4
   \   0000009C   0x.... 0x....      BL       UART_Receive_IT
   1230            }
   1231            
   1232            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_TXE);
   \                     ??HAL_UART_IRQHandler_4: (+1)
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x6800             LDR      R0,[R0, #+0]
   \   000000A4   0x09C0             LSRS     R0,R0,#+7
   \   000000A6   0xF010 0x0001      ANDS     R0,R0,#0x1
   1233            tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_TXE);
   \   000000AA   0x6821             LDR      R1,[R4, #+0]
   \   000000AC   0x68C9             LDR      R1,[R1, #+12]
   \   000000AE   0xF011 0x0180      ANDS     R1,R1,#0x80
   1234            /* UART in mode Transmitter ------------------------------------------------*/
   1235            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD004             BEQ.N    ??HAL_UART_IRQHandler_5
   \   000000B6   0x2900             CMP      R1,#+0
   \   000000B8   0xD002             BEQ.N    ??HAL_UART_IRQHandler_5
   1236            {
   1237              UART_Transmit_IT(huart);
   \   000000BA   0x0020             MOVS     R0,R4
   \   000000BC   0x.... 0x....      BL       UART_Transmit_IT
   1238            }
   1239          
   1240            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_TC);
   \                     ??HAL_UART_IRQHandler_5: (+1)
   \   000000C0   0x6820             LDR      R0,[R4, #+0]
   \   000000C2   0x6800             LDR      R0,[R0, #+0]
   \   000000C4   0x0980             LSRS     R0,R0,#+6
   \   000000C6   0xF010 0x0001      ANDS     R0,R0,#0x1
   1241            tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_TC);
   \   000000CA   0x6821             LDR      R1,[R4, #+0]
   \   000000CC   0x68C9             LDR      R1,[R1, #+12]
   \   000000CE   0xF011 0x0140      ANDS     R1,R1,#0x40
   1242            /* UART in mode Transmitter end --------------------------------------------*/
   1243            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xD004             BEQ.N    ??HAL_UART_IRQHandler_6
   \   000000D6   0x2900             CMP      R1,#+0
   \   000000D8   0xD002             BEQ.N    ??HAL_UART_IRQHandler_6
   1244            {
   1245              UART_EndTransmit_IT(huart);
   \   000000DA   0x0020             MOVS     R0,R4
   \   000000DC   0x.... 0x....      BL       UART_EndTransmit_IT
   1246            }  
   1247          
   1248            if(huart->ErrorCode != HAL_UART_ERROR_NONE)
   \                     ??HAL_UART_IRQHandler_6: (+1)
   \   000000E0   0x6BE0             LDR      R0,[R4, #+60]
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xD00C             BEQ.N    ??HAL_UART_IRQHandler_7
   1249            {
   1250              /* Clear all the error flag at once */
   1251              __HAL_UART_CLEAR_PEFLAG(huart);
   \   000000E6   0x6820             LDR      R0,[R4, #+0]
   \   000000E8   0x6800             LDR      R0,[R0, #+0]
   \   000000EA   0x9000             STR      R0,[SP, #+0]
   \   000000EC   0x6820             LDR      R0,[R4, #+0]
   \   000000EE   0x6840             LDR      R0,[R0, #+4]
   \   000000F0   0x9000             STR      R0,[SP, #+0]
   \   000000F2   0x9800             LDR      R0,[SP, #+0]
   1252              
   1253              /* Set the UART state ready to be able to start again the process */
   1254              huart->State = HAL_UART_STATE_READY;
   \   000000F4   0x2001             MOVS     R0,#+1
   \   000000F6   0xF884 0x0039      STRB     R0,[R4, #+57]
   1255              
   1256              HAL_UART_ErrorCallback(huart);
   \   000000FA   0x0020             MOVS     R0,R4
   \   000000FC   0x.... 0x....      BL       HAL_UART_ErrorCallback
   1257            }  
   1258          }
   \                     ??HAL_UART_IRQHandler_7: (+1)
   \   00000100   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   1259          
   1260          /**
   1261            * @brief  Tx Transfer completed callbacks.
   1262            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1263            *                the configuration information for the specified UART module.
   1264            * @retval None
   1265            */

   \                                 In section .text, align 2, keep-with-next
   1266           __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
   1267          {
   1268            /* Prevent unused argument(s) compilation warning */
   1269            UNUSED(huart);
   1270          
   1271            /* NOTE: This function should not be modified, when the callback is needed,
   1272                     the HAL_UART_TxCpltCallback can be implemented in the user file
   1273             */ 
   1274          }
   \                     HAL_UART_TxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1275          
   1276          /**
   1277            * @brief  Tx Half Transfer completed callbacks.
   1278            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1279            *                the configuration information for the specified UART module.
   1280            * @retval None
   1281            */

   \                                 In section .text, align 2, keep-with-next
   1282           __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
   1283          {
   1284            /* Prevent unused argument(s) compilation warning */
   1285            UNUSED(huart);
   1286          
   1287            /* NOTE: This function should not be modified, when the callback is needed,
   1288                     the HAL_UART_TxHalfCpltCallback can be implemented in the user file
   1289             */ 
   1290          }
   \                     HAL_UART_TxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1291          
   1292          /**
   1293            * @brief  Rx Transfer completed callbacks.
   1294            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1295            *                the configuration information for the specified UART module.
   1296            * @retval None
   1297            */

   \                                 In section .text, align 2, keep-with-next
   1298          __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
   1299          {
   1300            /* Prevent unused argument(s) compilation warning */
   1301            UNUSED(huart);
   1302          
   1303            /* NOTE: This function should not be modified, when the callback is needed,
   1304                     the HAL_UART_RxCpltCallback can be implemented in the user file
   1305             */
   1306          }
   \                     HAL_UART_RxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1307          
   1308          /**
   1309            * @brief  Rx Half Transfer completed callbacks.
   1310            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1311            *                the configuration information for the specified UART module.
   1312            * @retval None
   1313            */

   \                                 In section .text, align 2, keep-with-next
   1314          __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
   1315          {
   1316            /* Prevent unused argument(s) compilation warning */
   1317            UNUSED(huart);
   1318          
   1319            /* NOTE: This function should not be modified, when the callback is needed,
   1320                     the HAL_UART_RxHalfCpltCallback can be implemented in the user file
   1321             */
   1322          }
   \                     HAL_UART_RxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1323          
   1324          /**
   1325            * @brief  UART error callbacks.
   1326            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1327            *                the configuration information for the specified UART module.
   1328            * @retval None
   1329            */

   \                                 In section .text, align 2, keep-with-next
   1330           __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
   1331          {
   1332            /* Prevent unused argument(s) compilation warning */
   1333            UNUSED(huart);
   1334          
   1335            /* NOTE: This function should not be modified, when the callback is needed,
   1336                     the HAL_UART_ErrorCallback can be implemented in the user file
   1337             */ 
   1338          }
   \                     HAL_UART_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1339          
   1340          /**
   1341            * @}
   1342            */
   1343          
   1344          /** @defgroup UART_Exported_Functions_Group3 Peripheral Control functions 
   1345            *  @brief   UART control functions 
   1346            *
   1347          @verbatim   
   1348            ==============================================================================
   1349                                ##### Peripheral Control functions #####
   1350            ==============================================================================  
   1351            [..]
   1352              This subsection provides a set of functions allowing to control the UART:
   1353              (+) HAL_LIN_SendBreak() API can be helpful to transmit the break character.
   1354              (+) HAL_MultiProcessor_EnterMuteMode() API can be helpful to enter the UART in mute mode. 
   1355              (+) HAL_MultiProcessor_ExitMuteMode() API can be helpful to exit the UART mute mode by software.
   1356              (+) HAL_HalfDuplex_EnableTransmitter() API to enable the UART transmitter and disables the UART receiver in Half Duplex mode
   1357              (+) HAL_HalfDuplex_EnableReceiver() API to enable the UART receiver and disables the UART transmitter in Half Duplex mode
   1358              
   1359          @endverbatim
   1360            * @{
   1361            */
   1362          
   1363          /**
   1364            * @brief  Transmits break characters.
   1365            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1366            *                the configuration information for the specified UART module.
   1367            * @retval HAL status
   1368            */

   \                                 In section .text, align 2, keep-with-next
   1369          HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
   1370          {
   1371            /* Check the parameters */
   1372            assert_param(IS_UART_LIN_INSTANCE(huart->Instance));
   1373            
   1374            /* Process Locked */
   1375            __HAL_LOCK(huart);
   \                     HAL_LIN_SendBreak: (+1)
   \   00000000   0xF890 0x1038      LDRB     R1,[R0, #+56]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_LIN_SendBreak_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0xE012             B.N      ??HAL_LIN_SendBreak_1
   \                     ??HAL_LIN_SendBreak_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x1038      STRB     R1,[R0, #+56]
   1376            
   1377            huart->State = HAL_UART_STATE_BUSY;
   \   00000012   0x2102             MOVS     R1,#+2
   \   00000014   0xF880 0x1039      STRB     R1,[R0, #+57]
   1378            
   1379            /* Send break characters */
   1380            SET_BIT(huart->Instance->CR1, USART_CR1_SBK);
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x68C9             LDR      R1,[R1, #+12]
   \   0000001C   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   00000020   0x6802             LDR      R2,[R0, #+0]
   \   00000022   0x60D1             STR      R1,[R2, #+12]
   1381           
   1382            huart->State = HAL_UART_STATE_READY;
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0xF880 0x1039      STRB     R1,[R0, #+57]
   1383            
   1384            /* Process Unlocked */
   1385            __HAL_UNLOCK(huart);
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0xF880 0x1038      STRB     R1,[R0, #+56]
   1386            
   1387            return HAL_OK; 
   \   00000030   0x2000             MOVS     R0,#+0
   \                     ??HAL_LIN_SendBreak_1: (+1)
   \   00000032   0x4770             BX       LR               ;; return
   1388          }
   1389          
   1390          /**
   1391            * @brief  Enters the UART in mute mode. 
   1392            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1393            *                the configuration information for the specified UART module.
   1394            * @retval HAL status
   1395            */

   \                                 In section .text, align 2, keep-with-next
   1396          HAL_StatusTypeDef HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
   1397          {
   1398            /* Check the parameters */
   1399            assert_param(IS_UART_INSTANCE(huart->Instance));
   1400            
   1401            /* Process Locked */
   1402            __HAL_LOCK(huart);
   \                     HAL_MultiProcessor_EnterMuteMode: (+1)
   \   00000000   0xF890 0x1038      LDRB     R1,[R0, #+56]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_MultiProcessor_EnterMuteMode_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0xE012             B.N      ??HAL_MultiProcessor_EnterMuteMode_1
   \                     ??HAL_MultiProcessor_EnterMuteMode_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x1038      STRB     R1,[R0, #+56]
   1403            
   1404            huart->State = HAL_UART_STATE_BUSY;
   \   00000012   0x2102             MOVS     R1,#+2
   \   00000014   0xF880 0x1039      STRB     R1,[R0, #+57]
   1405            
   1406            /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
   1407            SET_BIT(huart->Instance->CR1, USART_CR1_RWU);
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x68C9             LDR      R1,[R1, #+12]
   \   0000001C   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   00000020   0x6802             LDR      R2,[R0, #+0]
   \   00000022   0x60D1             STR      R1,[R2, #+12]
   1408            
   1409            huart->State = HAL_UART_STATE_READY;
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0xF880 0x1039      STRB     R1,[R0, #+57]
   1410            
   1411            /* Process Unlocked */
   1412            __HAL_UNLOCK(huart);
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0xF880 0x1038      STRB     R1,[R0, #+56]
   1413            
   1414            return HAL_OK; 
   \   00000030   0x2000             MOVS     R0,#+0
   \                     ??HAL_MultiProcessor_EnterMuteMode_1: (+1)
   \   00000032   0x4770             BX       LR               ;; return
   1415          }
   1416          
   1417          /**
   1418            * @brief  Exits the UART mute mode: wake up software. 
   1419            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1420            *                the configuration information for the specified UART module.
   1421            * @retval HAL status
   1422            */

   \                                 In section .text, align 2, keep-with-next
   1423          HAL_StatusTypeDef HAL_MultiProcessor_ExitMuteMode(UART_HandleTypeDef *huart)
   1424          {
   1425            /* Check the parameters */
   1426            assert_param(IS_UART_INSTANCE(huart->Instance));
   1427            
   1428            /* Process Locked */
   1429            __HAL_LOCK(huart);
   \                     HAL_MultiProcessor_ExitMuteMode: (+1)
   \   00000000   0xF890 0x1038      LDRB     R1,[R0, #+56]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_MultiProcessor_ExitMuteMode_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0xE012             B.N      ??HAL_MultiProcessor_ExitMuteMode_1
   \                     ??HAL_MultiProcessor_ExitMuteMode_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x1038      STRB     R1,[R0, #+56]
   1430            
   1431            huart->State = HAL_UART_STATE_BUSY;
   \   00000012   0x2102             MOVS     R1,#+2
   \   00000014   0xF880 0x1039      STRB     R1,[R0, #+57]
   1432            
   1433            /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
   1434            CLEAR_BIT(huart->Instance->CR1, USART_CR1_RWU);
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x68C9             LDR      R1,[R1, #+12]
   \   0000001C   0xF031 0x0102      BICS     R1,R1,#0x2
   \   00000020   0x6802             LDR      R2,[R0, #+0]
   \   00000022   0x60D1             STR      R1,[R2, #+12]
   1435            
   1436            huart->State = HAL_UART_STATE_READY;
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0xF880 0x1039      STRB     R1,[R0, #+57]
   1437            
   1438            /* Process Unlocked */
   1439            __HAL_UNLOCK(huart);
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0xF880 0x1038      STRB     R1,[R0, #+56]
   1440            
   1441            return HAL_OK; 
   \   00000030   0x2000             MOVS     R0,#+0
   \                     ??HAL_MultiProcessor_ExitMuteMode_1: (+1)
   \   00000032   0x4770             BX       LR               ;; return
   1442          }
   1443          
   1444          /**
   1445            * @brief  Enables the UART transmitter and disables the UART receiver.
   1446            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1447            *                the configuration information for the specified UART module.
   1448            * @retval HAL status
   1449            */

   \                                 In section .text, align 2, keep-with-next
   1450          HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
   1451          {
   1452            /* Process Locked */
   1453            __HAL_LOCK(huart);
   \                     HAL_HalfDuplex_EnableTransmitter: (+1)
   \   00000000   0xF890 0x1038      LDRB     R1,[R0, #+56]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_HalfDuplex_EnableTransmitter_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0xE014             B.N      ??HAL_HalfDuplex_EnableTransmitter_1
   \                     ??HAL_HalfDuplex_EnableTransmitter_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x1038      STRB     R1,[R0, #+56]
   1454            
   1455            huart->State = HAL_UART_STATE_BUSY;
   \   00000012   0x2102             MOVS     R1,#+2
   \   00000014   0xF880 0x1039      STRB     R1,[R0, #+57]
   1456          
   1457            /*-------------------------- USART CR1 Configuration -----------------------*/
   1458            /* Clear TE and RE bits */
   1459            /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
   1460            MODIFY_REG(huart->Instance->CR1, (uint32_t)(USART_CR1_TE | USART_CR1_RE), USART_CR1_TE);
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x68C9             LDR      R1,[R1, #+12]
   \   0000001C   0xF031 0x010C      BICS     R1,R1,#0xC
   \   00000020   0xF051 0x0108      ORRS     R1,R1,#0x8
   \   00000024   0x6802             LDR      R2,[R0, #+0]
   \   00000026   0x60D1             STR      R1,[R2, #+12]
   1461           
   1462            huart->State = HAL_UART_STATE_READY;
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0xF880 0x1039      STRB     R1,[R0, #+57]
   1463            
   1464            /* Process Unlocked */
   1465            __HAL_UNLOCK(huart);
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0xF880 0x1038      STRB     R1,[R0, #+56]
   1466            
   1467            return HAL_OK; 
   \   00000034   0x2000             MOVS     R0,#+0
   \                     ??HAL_HalfDuplex_EnableTransmitter_1: (+1)
   \   00000036   0x4770             BX       LR               ;; return
   1468          }
   1469          
   1470          /**
   1471            * @brief  Enables the UART receiver and disables the UART transmitter.
   1472            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1473            *                the configuration information for the specified UART module.
   1474            * @retval HAL status
   1475            */

   \                                 In section .text, align 2, keep-with-next
   1476          HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
   1477          {
   1478            /* Process Locked */
   1479            __HAL_LOCK(huart);
   \                     HAL_HalfDuplex_EnableReceiver: (+1)
   \   00000000   0xF890 0x1038      LDRB     R1,[R0, #+56]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_HalfDuplex_EnableReceiver_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0xE014             B.N      ??HAL_HalfDuplex_EnableReceiver_1
   \                     ??HAL_HalfDuplex_EnableReceiver_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x1038      STRB     R1,[R0, #+56]
   1480            
   1481            huart->State = HAL_UART_STATE_BUSY;
   \   00000012   0x2102             MOVS     R1,#+2
   \   00000014   0xF880 0x1039      STRB     R1,[R0, #+57]
   1482          
   1483            /*-------------------------- USART CR1 Configuration -----------------------*/
   1484            /* Clear TE and RE bits */
   1485            /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
   1486            MODIFY_REG(huart->Instance->CR1, (uint32_t)(USART_CR1_TE | USART_CR1_RE), USART_CR1_RE);
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x68C9             LDR      R1,[R1, #+12]
   \   0000001C   0xF031 0x010C      BICS     R1,R1,#0xC
   \   00000020   0xF051 0x0104      ORRS     R1,R1,#0x4
   \   00000024   0x6802             LDR      R2,[R0, #+0]
   \   00000026   0x60D1             STR      R1,[R2, #+12]
   1487            
   1488            huart->State = HAL_UART_STATE_READY;
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0xF880 0x1039      STRB     R1,[R0, #+57]
   1489            
   1490            /* Process Unlocked */
   1491            __HAL_UNLOCK(huart);
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0xF880 0x1038      STRB     R1,[R0, #+56]
   1492            
   1493            return HAL_OK; 
   \   00000034   0x2000             MOVS     R0,#+0
   \                     ??HAL_HalfDuplex_EnableReceiver_1: (+1)
   \   00000036   0x4770             BX       LR               ;; return
   1494          }
   1495          
   1496          /**
   1497            * @}
   1498            */
   1499          
   1500          /** @defgroup UART_Exported_Functions_Group4 Peripheral State and Errors functions 
   1501            *  @brief   UART State and Errors functions 
   1502            *
   1503          @verbatim   
   1504            ==============================================================================
   1505                           ##### Peripheral State and Errors functions #####
   1506            ==============================================================================  
   1507           [..]
   1508             This subsection provides a set of functions allowing to return the State of 
   1509             UART communication process, return Peripheral Errors occurred during communication 
   1510             process
   1511             (+) HAL_UART_GetState() API can be helpful to check in run-time the state of the UART peripheral.
   1512             (+) HAL_UART_GetError() check in run-time errors that could be occurred during communication. 
   1513          
   1514          @endverbatim
   1515            * @{
   1516            */
   1517            
   1518          /**
   1519            * @brief  Returns the UART state.
   1520            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1521            *                the configuration information for the specified UART module.
   1522            * @retval HAL state
   1523            */

   \                                 In section .text, align 2, keep-with-next
   1524          HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
   1525          {
   1526            return huart->State;
   \                     HAL_UART_GetState: (+1)
   \   00000000   0xF890 0x0039      LDRB     R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   1527          }
   1528          
   1529          /**
   1530          * @brief  Return the UART error code
   1531          * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1532            *              the configuration information for the specified UART.
   1533          * @retval UART Error Code
   1534          */

   \                                 In section .text, align 2, keep-with-next
   1535          uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
   1536          {
   1537            return huart->ErrorCode;
   \                     HAL_UART_GetError: (+1)
   \   00000000   0x6BC0             LDR      R0,[R0, #+60]
   \   00000002   0x4770             BX       LR               ;; return
   1538          }
   1539          
   1540          /**
   1541            * @}
   1542            */
   1543          
   1544          /**
   1545            * @}
   1546            */
   1547          
   1548          /** @defgroup UART_Private_Functions   UART Private Functions
   1549            *  @brief   UART Private functions 
   1550            * @{
   1551            */
   1552          /**
   1553            * @brief  DMA UART transmit process complete callback. 
   1554            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
   1555            *               the configuration information for the specified DMA module.
   1556            * @retval None
   1557            */

   \                                 In section .text, align 4, keep-with-next
   1558          static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)     
   1559          {
   \                     UART_DMATransmitCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1560            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6A41             LDR      R1,[R0, #+36]
   1561            /* DMA Normal mode*/
   1562            if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x0680             LSLS     R0,R0,#+26
   \   0000000A   0xD40E             BMI.N    ??UART_DMATransmitCplt_0
   1563            {
   1564              huart->TxXferCount = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x84C8             STRH     R0,[R1, #+38]
   1565          
   1566              /* Disable the DMA transfer for transmit request by setting the DMAT bit
   1567                 in the UART CR3 register */
   1568              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \   00000010   0x6808             LDR      R0,[R1, #+0]
   \   00000012   0x6940             LDR      R0,[R0, #+20]
   \   00000014   0xF030 0x0080      BICS     R0,R0,#0x80
   \   00000018   0x680A             LDR      R2,[R1, #+0]
   \   0000001A   0x6150             STR      R0,[R2, #+20]
   1569          
   1570              /* Enable the UART Transmit Complete Interrupt */    
   1571              __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
   \   0000001C   0x6808             LDR      R0,[R1, #+0]
   \   0000001E   0x68C0             LDR      R0,[R0, #+12]
   \   00000020   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000024   0x6809             LDR      R1,[R1, #+0]
   \   00000026   0x60C8             STR      R0,[R1, #+12]
   \   00000028   0xE002             B.N      ??UART_DMATransmitCplt_1
   1572            }
   1573            /* DMA Circular mode */
   1574            else
   1575            {
   1576              HAL_UART_TxCpltCallback(huart);
   \                     ??UART_DMATransmitCplt_0: (+1)
   \   0000002A   0x0008             MOVS     R0,R1
   \   0000002C   0x.... 0x....      BL       HAL_UART_TxCpltCallback
   1577            }
   1578          }
   \                     ??UART_DMATransmitCplt_1: (+1)
   \   00000030   0xBD01             POP      {R0,PC}          ;; return
   1579          
   1580          /**
   1581            * @brief DMA UART transmit process half complete callback 
   1582            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
   1583            *               the configuration information for the specified DMA module.
   1584            * @retval None
   1585            */

   \                                 In section .text, align 4, keep-with-next
   1586          static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
   1587          {
   \                     UART_DMATxHalfCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1588            UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000002   0x6A40             LDR      R0,[R0, #+36]
   1589          
   1590            HAL_UART_TxHalfCpltCallback(huart);
   \   00000004   0x.... 0x....      BL       HAL_UART_TxHalfCpltCallback
   1591          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
   1592          
   1593          /**
   1594            * @brief  DMA UART receive process complete callback. 
   1595            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
   1596            *               the configuration information for the specified DMA module.
   1597            * @retval None
   1598            */

   \                                 In section .text, align 4, keep-with-next
   1599          static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)  
   1600          {
   \                     UART_DMAReceiveCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1601            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6A41             LDR      R1,[R0, #+36]
   1602            /* DMA Normal mode*/
   1603            if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x0680             LSLS     R0,R0,#+26
   \   0000000A   0xD412             BMI.N    ??UART_DMAReceiveCplt_0
   1604            {
   1605              huart->RxXferCount = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x85C8             STRH     R0,[R1, #+46]
   1606            
   1607              /* Disable the DMA transfer for the receiver request by setting the DMAR bit 
   1608                 in the UART CR3 register */
   1609              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \   00000010   0x6808             LDR      R0,[R1, #+0]
   \   00000012   0x6940             LDR      R0,[R0, #+20]
   \   00000014   0xF030 0x0040      BICS     R0,R0,#0x40
   \   00000018   0x680A             LDR      R2,[R1, #+0]
   \   0000001A   0x6150             STR      R0,[R2, #+20]
   1610          
   1611              /* Check if a transmit process is ongoing or not */
   1612              if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   \   0000001C   0xF891 0x0039      LDRB     R0,[R1, #+57]
   \   00000020   0x2832             CMP      R0,#+50
   \   00000022   0xD103             BNE.N    ??UART_DMAReceiveCplt_1
   1613              {
   1614                huart->State = HAL_UART_STATE_BUSY_TX;
   \   00000024   0x2012             MOVS     R0,#+18
   \   00000026   0xF881 0x0039      STRB     R0,[R1, #+57]
   \   0000002A   0xE002             B.N      ??UART_DMAReceiveCplt_0
   1615              }
   1616              else
   1617              {
   1618                huart->State = HAL_UART_STATE_READY;
   \                     ??UART_DMAReceiveCplt_1: (+1)
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xF881 0x0039      STRB     R0,[R1, #+57]
   1619              }
   1620            }
   1621            HAL_UART_RxCpltCallback(huart);
   \                     ??UART_DMAReceiveCplt_0: (+1)
   \   00000032   0x0008             MOVS     R0,R1
   \   00000034   0x.... 0x....      BL       HAL_UART_RxCpltCallback
   1622          }
   \   00000038   0xBD01             POP      {R0,PC}          ;; return
   1623          
   1624          /**
   1625            * @brief DMA UART receive process half complete callback 
   1626            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
   1627            *               the configuration information for the specified DMA module.
   1628            * @retval None
   1629            */

   \                                 In section .text, align 4, keep-with-next
   1630          static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
   1631          {
   \                     UART_DMARxHalfCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1632            UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000002   0x6A40             LDR      R0,[R0, #+36]
   1633          
   1634            HAL_UART_RxHalfCpltCallback(huart); 
   \   00000004   0x.... 0x....      BL       HAL_UART_RxHalfCpltCallback
   1635          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
   1636          
   1637          /**
   1638            * @brief  DMA UART communication error callback.
   1639            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
   1640            *               the configuration information for the specified DMA module.
   1641            * @retval None
   1642            */

   \                                 In section .text, align 4, keep-with-next
   1643          static void UART_DMAError(DMA_HandleTypeDef *hdma)   
   1644          {
   \                     UART_DMAError: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1645            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6A40             LDR      R0,[R0, #+36]
   1646            huart->RxXferCount = 0;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x85C1             STRH     R1,[R0, #+46]
   1647            huart->TxXferCount = 0;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x84C1             STRH     R1,[R0, #+38]
   1648            huart->State= HAL_UART_STATE_READY;
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x1039      STRB     R1,[R0, #+57]
   1649            huart->ErrorCode |= HAL_UART_ERROR_DMA;
   \   00000012   0x6BC1             LDR      R1,[R0, #+60]
   \   00000014   0xF051 0x0110      ORRS     R1,R1,#0x10
   \   00000018   0x63C1             STR      R1,[R0, #+60]
   1650            HAL_UART_ErrorCallback(huart);
   \   0000001A   0x.... 0x....      BL       HAL_UART_ErrorCallback
   1651          }
   \   0000001E   0xBD01             POP      {R0,PC}          ;; return
   1652          
   1653          /**
   1654            * @brief  This function handles UART Communication Timeout.
   1655            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1656            *                the configuration information for the specified UART module.
   1657            * @param  Flag: specifies the UART flag to check.
   1658            * @param  Status: The new Flag status (SET or RESET).
   1659            * @param  Timeout: Timeout duration
   1660            * @retval HAL status
   1661            */

   \                                 In section .text, align 2, keep-with-next
   1662          static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Timeout)
   1663          {
   \                     UART_WaitOnFlagUntilTimeout: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x001E             MOVS     R6,R3
   1664            uint32_t tickstart = 0;
   \   0000000C   0x2700             MOVS     R7,#+0
   1665          
   1666            /* Get tick */ 
   1667            tickstart = HAL_GetTick();
   \   0000000E   0x.... 0x....      BL       HAL_GetTick
   \   00000012   0x0007             MOVS     R7,R0
   1668          
   1669            /* Wait until flag is set */
   1670            if(Status == RESET)
   \   00000014   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000018   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000001C   0xD12E             BNE.N    ??UART_WaitOnFlagUntilTimeout_0
   1671            {
   1672              while(__HAL_UART_GET_FLAG(huart, Flag) == RESET)
   \                     ??UART_WaitOnFlagUntilTimeout_1: (+1)
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x4028             ANDS     R0,R5,R0
   \   00000024   0x42A8             CMP      R0,R5
   \   00000026   0xD058             BEQ.N    ??UART_WaitOnFlagUntilTimeout_2
   1673              {
   1674                /* Check for the Timeout */
   1675                if(Timeout != HAL_MAX_DELAY)
   \   00000028   0xF116 0x0F01      CMN      R6,#+1
   \   0000002C   0xD0F7             BEQ.N    ??UART_WaitOnFlagUntilTimeout_1
   1676                {
   1677                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   0000002E   0x2E00             CMP      R6,#+0
   \   00000030   0xD004             BEQ.N    ??UART_WaitOnFlagUntilTimeout_3
   \   00000032   0x.... 0x....      BL       HAL_GetTick
   \   00000036   0x1BC0             SUBS     R0,R0,R7
   \   00000038   0x4286             CMP      R6,R0
   \   0000003A   0xD2F0             BCS.N    ??UART_WaitOnFlagUntilTimeout_1
   1678                  {
   1679                    /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
   1680                    __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
   \                     ??UART_WaitOnFlagUntilTimeout_3: (+1)
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x68C0             LDR      R0,[R0, #+12]
   \   00000040   0xF030 0x0080      BICS     R0,R0,#0x80
   \   00000044   0x6821             LDR      R1,[R4, #+0]
   \   00000046   0x60C8             STR      R0,[R1, #+12]
   1681                    __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x68C0             LDR      R0,[R0, #+12]
   \   0000004C   0xF030 0x0020      BICS     R0,R0,#0x20
   \   00000050   0x6821             LDR      R1,[R4, #+0]
   \   00000052   0x60C8             STR      R0,[R1, #+12]
   1682                    __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x68C0             LDR      R0,[R0, #+12]
   \   00000058   0xF430 0x7080      BICS     R0,R0,#0x100
   \   0000005C   0x6821             LDR      R1,[R4, #+0]
   \   0000005E   0x60C8             STR      R0,[R1, #+12]
   1683                    __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x6940             LDR      R0,[R0, #+20]
   \   00000064   0x0840             LSRS     R0,R0,#+1
   \   00000066   0x0040             LSLS     R0,R0,#+1
   \   00000068   0x6821             LDR      R1,[R4, #+0]
   \   0000006A   0x6148             STR      R0,[R1, #+20]
   1684          
   1685                    huart->State= HAL_UART_STATE_READY;
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0xF884 0x0039      STRB     R0,[R4, #+57]
   1686          
   1687                    /* Process Unlocked */
   1688                    __HAL_UNLOCK(huart);
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xF884 0x0038      STRB     R0,[R4, #+56]
   1689          
   1690                    return HAL_TIMEOUT;
   \   00000078   0x2003             MOVS     R0,#+3
   \   0000007A   0xE02F             B.N      ??UART_WaitOnFlagUntilTimeout_4
   1691                  }
   1692                }
   1693              }
   1694            }
   1695            else
   1696            {
   1697              while(__HAL_UART_GET_FLAG(huart, Flag) != RESET)
   \                     ??UART_WaitOnFlagUntilTimeout_0: (+1)
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0x4028             ANDS     R0,R5,R0
   \   00000082   0x42A8             CMP      R0,R5
   \   00000084   0xD129             BNE.N    ??UART_WaitOnFlagUntilTimeout_2
   1698              {
   1699                /* Check for the Timeout */
   1700                if(Timeout != HAL_MAX_DELAY)
   \   00000086   0xF116 0x0F01      CMN      R6,#+1
   \   0000008A   0xD0F7             BEQ.N    ??UART_WaitOnFlagUntilTimeout_0
   1701                {
   1702                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   0000008C   0x2E00             CMP      R6,#+0
   \   0000008E   0xD004             BEQ.N    ??UART_WaitOnFlagUntilTimeout_5
   \   00000090   0x.... 0x....      BL       HAL_GetTick
   \   00000094   0x1BC0             SUBS     R0,R0,R7
   \   00000096   0x4286             CMP      R6,R0
   \   00000098   0xD2F0             BCS.N    ??UART_WaitOnFlagUntilTimeout_0
   1703                  {
   1704                    /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
   1705                    __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
   \                     ??UART_WaitOnFlagUntilTimeout_5: (+1)
   \   0000009A   0x6820             LDR      R0,[R4, #+0]
   \   0000009C   0x68C0             LDR      R0,[R0, #+12]
   \   0000009E   0xF030 0x0080      BICS     R0,R0,#0x80
   \   000000A2   0x6821             LDR      R1,[R4, #+0]
   \   000000A4   0x60C8             STR      R0,[R1, #+12]
   1706                    __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
   \   000000A6   0x6820             LDR      R0,[R4, #+0]
   \   000000A8   0x68C0             LDR      R0,[R0, #+12]
   \   000000AA   0xF030 0x0020      BICS     R0,R0,#0x20
   \   000000AE   0x6821             LDR      R1,[R4, #+0]
   \   000000B0   0x60C8             STR      R0,[R1, #+12]
   1707                    __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
   \   000000B2   0x6820             LDR      R0,[R4, #+0]
   \   000000B4   0x68C0             LDR      R0,[R0, #+12]
   \   000000B6   0xF430 0x7080      BICS     R0,R0,#0x100
   \   000000BA   0x6821             LDR      R1,[R4, #+0]
   \   000000BC   0x60C8             STR      R0,[R1, #+12]
   1708                    __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
   \   000000BE   0x6820             LDR      R0,[R4, #+0]
   \   000000C0   0x6940             LDR      R0,[R0, #+20]
   \   000000C2   0x0840             LSRS     R0,R0,#+1
   \   000000C4   0x0040             LSLS     R0,R0,#+1
   \   000000C6   0x6821             LDR      R1,[R4, #+0]
   \   000000C8   0x6148             STR      R0,[R1, #+20]
   1709          
   1710                    huart->State= HAL_UART_STATE_READY;
   \   000000CA   0x2001             MOVS     R0,#+1
   \   000000CC   0xF884 0x0039      STRB     R0,[R4, #+57]
   1711          
   1712                    /* Process Unlocked */
   1713                    __HAL_UNLOCK(huart);
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0xF884 0x0038      STRB     R0,[R4, #+56]
   1714          
   1715                    return HAL_TIMEOUT;
   \   000000D6   0x2003             MOVS     R0,#+3
   \   000000D8   0xE000             B.N      ??UART_WaitOnFlagUntilTimeout_4
   1716                  }
   1717                }
   1718              }
   1719            }
   1720            return HAL_OK;
   \                     ??UART_WaitOnFlagUntilTimeout_2: (+1)
   \   000000DA   0x2000             MOVS     R0,#+0
   \                     ??UART_WaitOnFlagUntilTimeout_4: (+1)
   \   000000DC   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1721          }
   1722          
   1723          /**
   1724            * @brief  Sends an amount of data in non blocking mode.
   1725            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1726            *                the configuration information for the specified UART module.
   1727            * @retval HAL status
   1728            */

   \                                 In section .text, align 2, keep-with-next
   1729          static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
   1730          {
   1731            uint16_t* tmp;
   1732            uint32_t tmp_state = 0;
   \                     UART_Transmit_IT: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   1733            
   1734            tmp_state = huart->State;
   \   00000002   0xF890 0x1039      LDRB     R1,[R0, #+57]
   1735            if((tmp_state == HAL_UART_STATE_BUSY_TX) || (tmp_state == HAL_UART_STATE_BUSY_TX_RX))
   \   00000006   0x2912             CMP      R1,#+18
   \   00000008   0xD001             BEQ.N    ??UART_Transmit_IT_0
   \   0000000A   0x2932             CMP      R1,#+50
   \   0000000C   0xD12E             BNE.N    ??UART_Transmit_IT_1
   1736            {
   1737              if(huart->Init.WordLength == UART_WORDLENGTH_9B)
   \                     ??UART_Transmit_IT_0: (+1)
   \   0000000E   0x6881             LDR      R1,[R0, #+8]
   \   00000010   0xF5B1 0x5F80      CMP      R1,#+4096
   \   00000014   0xD110             BNE.N    ??UART_Transmit_IT_2
   1738              {
   1739                tmp = (uint16_t*) huart->pTxBuffPtr;
   \   00000016   0x6A01             LDR      R1,[R0, #+32]
   1740                huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
   \   00000018   0x8809             LDRH     R1,[R1, #+0]
   \   0000001A   0x05C9             LSLS     R1,R1,#+23       ;; ZeroExtS R1,R1,#+23,#+23
   \   0000001C   0x0DC9             LSRS     R1,R1,#+23
   \   0000001E   0x6802             LDR      R2,[R0, #+0]
   \   00000020   0x6051             STR      R1,[R2, #+4]
   1741                if(huart->Init.Parity == UART_PARITY_NONE)
   \   00000022   0x6901             LDR      R1,[R0, #+16]
   \   00000024   0x2900             CMP      R1,#+0
   \   00000026   0xD103             BNE.N    ??UART_Transmit_IT_3
   1742                {
   1743                  huart->pTxBuffPtr += 2;
   \   00000028   0x6A01             LDR      R1,[R0, #+32]
   \   0000002A   0x1C89             ADDS     R1,R1,#+2
   \   0000002C   0x6201             STR      R1,[R0, #+32]
   \   0000002E   0xE009             B.N      ??UART_Transmit_IT_4
   1744                }
   1745                else
   1746                {
   1747                  huart->pTxBuffPtr += 1;
   \                     ??UART_Transmit_IT_3: (+1)
   \   00000030   0x6A01             LDR      R1,[R0, #+32]
   \   00000032   0x1C49             ADDS     R1,R1,#+1
   \   00000034   0x6201             STR      R1,[R0, #+32]
   \   00000036   0xE005             B.N      ??UART_Transmit_IT_4
   1748                }
   1749              } 
   1750              else
   1751              {
   1752                huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
   \                     ??UART_Transmit_IT_2: (+1)
   \   00000038   0x6A01             LDR      R1,[R0, #+32]
   \   0000003A   0x1C4A             ADDS     R2,R1,#+1
   \   0000003C   0x6202             STR      R2,[R0, #+32]
   \   0000003E   0x7809             LDRB     R1,[R1, #+0]
   \   00000040   0x6802             LDR      R2,[R0, #+0]
   \   00000042   0x6051             STR      R1,[R2, #+4]
   1753              }
   1754          
   1755              if(--huart->TxXferCount == 0)
   \                     ??UART_Transmit_IT_4: (+1)
   \   00000044   0x8CC1             LDRH     R1,[R0, #+38]
   \   00000046   0x1E49             SUBS     R1,R1,#+1
   \   00000048   0x84C1             STRH     R1,[R0, #+38]
   \   0000004A   0x8CC1             LDRH     R1,[R0, #+38]
   \   0000004C   0x2900             CMP      R1,#+0
   \   0000004E   0xD10B             BNE.N    ??UART_Transmit_IT_5
   1756              {
   1757                /* Disable the UART Transmit Complete Interrupt */
   1758                __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
   \   00000050   0x6801             LDR      R1,[R0, #+0]
   \   00000052   0x68C9             LDR      R1,[R1, #+12]
   \   00000054   0xF031 0x0180      BICS     R1,R1,#0x80
   \   00000058   0x6802             LDR      R2,[R0, #+0]
   \   0000005A   0x60D1             STR      R1,[R2, #+12]
   1759          
   1760                /* Enable the UART Transmit Complete Interrupt */    
   1761                __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
   \   0000005C   0x6801             LDR      R1,[R0, #+0]
   \   0000005E   0x68C9             LDR      R1,[R1, #+12]
   \   00000060   0xF051 0x0140      ORRS     R1,R1,#0x40
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0x60C1             STR      R1,[R0, #+12]
   1762              }
   1763              return HAL_OK;
   \                     ??UART_Transmit_IT_5: (+1)
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xE000             B.N      ??UART_Transmit_IT_6
   1764            }
   1765            else
   1766            {
   1767              return HAL_BUSY;
   \                     ??UART_Transmit_IT_1: (+1)
   \   0000006C   0x2002             MOVS     R0,#+2
   \                     ??UART_Transmit_IT_6: (+1)
   \   0000006E   0x4770             BX       LR               ;; return
   1768            }
   1769          }
   1770          
   1771          
   1772          /**
   1773            * @brief  Wraps up transmission in non blocking mode.
   1774            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
   1775            *                the configuration information for the specified UART module.
   1776            * @retval HAL status
   1777            */

   \                                 In section .text, align 2, keep-with-next
   1778          static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
   1779          {
   \                     UART_EndTransmit_IT: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1780            /* Disable the UART Transmit Complete Interrupt */    
   1781            __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x68C9             LDR      R1,[R1, #+12]
   \   00000006   0xF031 0x0140      BICS     R1,R1,#0x40
   \   0000000A   0x6802             LDR      R2,[R0, #+0]
   \   0000000C   0x60D1             STR      R1,[R2, #+12]
   1782            
   1783            /* Check if a receive process is ongoing or not */
   1784            if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   \   0000000E   0xF890 0x1039      LDRB     R1,[R0, #+57]
   \   00000012   0x2932             CMP      R1,#+50
   \   00000014   0xD103             BNE.N    ??UART_EndTransmit_IT_0
   1785            {
   1786              huart->State = HAL_UART_STATE_BUSY_RX;
   \   00000016   0x2122             MOVS     R1,#+34
   \   00000018   0xF880 0x1039      STRB     R1,[R0, #+57]
   \   0000001C   0xE002             B.N      ??UART_EndTransmit_IT_1
   1787            }
   1788            else
   1789            {
   1790              huart->State = HAL_UART_STATE_READY;
   \                     ??UART_EndTransmit_IT_0: (+1)
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0xF880 0x1039      STRB     R1,[R0, #+57]
   1791            }
   1792            
   1793            HAL_UART_TxCpltCallback(huart);
   \                     ??UART_EndTransmit_IT_1: (+1)
   \   00000024   0x.... 0x....      BL       HAL_UART_TxCpltCallback
   1794            
   1795            return HAL_OK;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xBD02             POP      {R1,PC}          ;; return
   1796          }
   1797          
   1798          /**
   1799            * @brief  Receives an amount of data in non blocking mode 
   1800            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1801            *                the configuration information for the specified UART module.
   1802            * @retval HAL status
   1803            */

   \                                 In section .text, align 2, keep-with-next
   1804          static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
   1805          {
   \                     UART_Receive_IT: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1806            uint16_t* tmp;
   1807            uint32_t tmp_state = 0;
   \   00000002   0x2100             MOVS     R1,#+0
   1808            
   1809            tmp_state = huart->State; 
   \   00000004   0xF890 0x1039      LDRB     R1,[R0, #+57]
   1810            if((tmp_state == HAL_UART_STATE_BUSY_RX) || (tmp_state == HAL_UART_STATE_BUSY_TX_RX))
   \   00000008   0x2922             CMP      R1,#+34
   \   0000000A   0xD001             BEQ.N    ??UART_Receive_IT_0
   \   0000000C   0x2932             CMP      R1,#+50
   \   0000000E   0xD153             BNE.N    ??UART_Receive_IT_1
   1811            {
   1812              if(huart->Init.WordLength == UART_WORDLENGTH_9B)
   \                     ??UART_Receive_IT_0: (+1)
   \   00000010   0x6881             LDR      R1,[R0, #+8]
   \   00000012   0xF5B1 0x5F80      CMP      R1,#+4096
   \   00000016   0xD114             BNE.N    ??UART_Receive_IT_2
   1813              {
   1814                tmp = (uint16_t*) huart->pRxBuffPtr;
   \   00000018   0x6A81             LDR      R1,[R0, #+40]
   1815                if(huart->Init.Parity == UART_PARITY_NONE)
   \   0000001A   0x6902             LDR      R2,[R0, #+16]
   \   0000001C   0x2A00             CMP      R2,#+0
   \   0000001E   0xD108             BNE.N    ??UART_Receive_IT_3
   1816                {
   1817                  *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
   \   00000020   0x6802             LDR      R2,[R0, #+0]
   \   00000022   0x6852             LDR      R2,[R2, #+4]
   \   00000024   0x05D2             LSLS     R2,R2,#+23       ;; ZeroExtS R2,R2,#+23,#+23
   \   00000026   0x0DD2             LSRS     R2,R2,#+23
   \   00000028   0x800A             STRH     R2,[R1, #+0]
   1818                  huart->pRxBuffPtr += 2;
   \   0000002A   0x6A81             LDR      R1,[R0, #+40]
   \   0000002C   0x1C89             ADDS     R1,R1,#+2
   \   0000002E   0x6281             STR      R1,[R0, #+40]
   \   00000030   0xE019             B.N      ??UART_Receive_IT_4
   1819                }
   1820                else
   1821                {
   1822                  *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
   \                     ??UART_Receive_IT_3: (+1)
   \   00000032   0x6802             LDR      R2,[R0, #+0]
   \   00000034   0x6852             LDR      R2,[R2, #+4]
   \   00000036   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000038   0x800A             STRH     R2,[R1, #+0]
   1823                  huart->pRxBuffPtr += 1;
   \   0000003A   0x6A81             LDR      R1,[R0, #+40]
   \   0000003C   0x1C49             ADDS     R1,R1,#+1
   \   0000003E   0x6281             STR      R1,[R0, #+40]
   \   00000040   0xE011             B.N      ??UART_Receive_IT_4
   1824                }
   1825              }
   1826              else
   1827              {
   1828                if(huart->Init.Parity == UART_PARITY_NONE)
   \                     ??UART_Receive_IT_2: (+1)
   \   00000042   0x6901             LDR      R1,[R0, #+16]
   \   00000044   0x2900             CMP      R1,#+0
   \   00000046   0xD106             BNE.N    ??UART_Receive_IT_5
   1829                {
   1830                  *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
   \   00000048   0x6A81             LDR      R1,[R0, #+40]
   \   0000004A   0x1C4A             ADDS     R2,R1,#+1
   \   0000004C   0x6282             STR      R2,[R0, #+40]
   \   0000004E   0x6802             LDR      R2,[R0, #+0]
   \   00000050   0x6852             LDR      R2,[R2, #+4]
   \   00000052   0x700A             STRB     R2,[R1, #+0]
   \   00000054   0xE007             B.N      ??UART_Receive_IT_4
   1831                }
   1832                else
   1833                {
   1834                  *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
   \                     ??UART_Receive_IT_5: (+1)
   \   00000056   0x6A81             LDR      R1,[R0, #+40]
   \   00000058   0x1C4A             ADDS     R2,R1,#+1
   \   0000005A   0x6282             STR      R2,[R0, #+40]
   \   0000005C   0x6802             LDR      R2,[R0, #+0]
   \   0000005E   0x6852             LDR      R2,[R2, #+4]
   \   00000060   0xF012 0x027F      ANDS     R2,R2,#0x7F
   \   00000064   0x700A             STRB     R2,[R1, #+0]
   1835                }
   1836              }
   1837          
   1838              if(--huart->RxXferCount == 0)
   \                     ??UART_Receive_IT_4: (+1)
   \   00000066   0x8DC1             LDRH     R1,[R0, #+46]
   \   00000068   0x1E49             SUBS     R1,R1,#+1
   \   0000006A   0x85C1             STRH     R1,[R0, #+46]
   \   0000006C   0x8DC1             LDRH     R1,[R0, #+46]
   \   0000006E   0x2900             CMP      R1,#+0
   \   00000070   0xD120             BNE.N    ??UART_Receive_IT_6
   1839              {
   1840                __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
   \   00000072   0x6801             LDR      R1,[R0, #+0]
   \   00000074   0x68C9             LDR      R1,[R1, #+12]
   \   00000076   0xF031 0x0120      BICS     R1,R1,#0x20
   \   0000007A   0x6802             LDR      R2,[R0, #+0]
   \   0000007C   0x60D1             STR      R1,[R2, #+12]
   1841          
   1842                /* Check if a transmit process is ongoing or not */
   1843                if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   \   0000007E   0xF890 0x1039      LDRB     R1,[R0, #+57]
   \   00000082   0x2932             CMP      R1,#+50
   \   00000084   0xD103             BNE.N    ??UART_Receive_IT_7
   1844                {
   1845                  huart->State = HAL_UART_STATE_BUSY_TX;
   \   00000086   0x2112             MOVS     R1,#+18
   \   00000088   0xF880 0x1039      STRB     R1,[R0, #+57]
   \   0000008C   0xE00E             B.N      ??UART_Receive_IT_8
   1846                }
   1847                else
   1848                {
   1849                  /* Disable the UART Parity Error Interrupt */
   1850                  __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
   \                     ??UART_Receive_IT_7: (+1)
   \   0000008E   0x6801             LDR      R1,[R0, #+0]
   \   00000090   0x68C9             LDR      R1,[R1, #+12]
   \   00000092   0xF431 0x7180      BICS     R1,R1,#0x100
   \   00000096   0x6802             LDR      R2,[R0, #+0]
   \   00000098   0x60D1             STR      R1,[R2, #+12]
   1851          
   1852                  /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
   1853                  __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
   \   0000009A   0x6801             LDR      R1,[R0, #+0]
   \   0000009C   0x6949             LDR      R1,[R1, #+20]
   \   0000009E   0x0849             LSRS     R1,R1,#+1
   \   000000A0   0x0049             LSLS     R1,R1,#+1
   \   000000A2   0x6802             LDR      R2,[R0, #+0]
   \   000000A4   0x6151             STR      R1,[R2, #+20]
   1854          
   1855                  huart->State = HAL_UART_STATE_READY;
   \   000000A6   0x2101             MOVS     R1,#+1
   \   000000A8   0xF880 0x1039      STRB     R1,[R0, #+57]
   1856                }
   1857                HAL_UART_RxCpltCallback(huart);
   \                     ??UART_Receive_IT_8: (+1)
   \   000000AC   0x.... 0x....      BL       HAL_UART_RxCpltCallback
   1858          
   1859                return HAL_OK;
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0xE002             B.N      ??UART_Receive_IT_9
   1860              }
   1861              return HAL_OK;
   \                     ??UART_Receive_IT_6: (+1)
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0xE000             B.N      ??UART_Receive_IT_9
   1862            }
   1863            else
   1864            {
   1865              return HAL_BUSY; 
   \                     ??UART_Receive_IT_1: (+1)
   \   000000B8   0x2002             MOVS     R0,#+2
   \                     ??UART_Receive_IT_9: (+1)
   \   000000BA   0xBD02             POP      {R1,PC}          ;; return
   1866            }
   1867          }
   1868          
   1869          /**
   1870            * @brief  Configures the UART peripheral. 
   1871            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1872            *                the configuration information for the specified UART module.
   1873            * @retval None
   1874            */

   \                                 In section .text, align 2, keep-with-next
   1875          static void UART_SetConfig(UART_HandleTypeDef *huart)
   1876          {
   \                     UART_SetConfig: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   1877            uint32_t tmpreg = 0x00;
   \   00000006   0x2000             MOVS     R0,#+0
   1878            
   1879            /* Check the parameters */
   1880            assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));  
   1881            assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
   1882            assert_param(IS_UART_PARITY(huart->Init.Parity));
   1883            assert_param(IS_UART_MODE(huart->Init.Mode));
   1884          
   1885            /*------- UART-associated USART registers setting : CR2 Configuration ------*/
   1886            /* Configure the UART Stop Bits: Set STOP[13:12] bits according 
   1887             * to huart->Init.StopBits value */
   1888            MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x6900             LDR      R0,[R0, #+16]
   \   0000000C   0xF430 0x5040      BICS     R0,R0,#0x3000
   \   00000010   0x68E1             LDR      R1,[R4, #+12]
   \   00000012   0x4308             ORRS     R0,R1,R0
   \   00000014   0x6821             LDR      R1,[R4, #+0]
   \   00000016   0x6108             STR      R0,[R1, #+16]
   1889          
   1890            /*------- UART-associated USART registers setting : CR1 Configuration ------*/
   1891            /* Configure the UART Word Length, Parity and mode: 
   1892               Set the M bits according to huart->Init.WordLength value 
   1893               Set PCE and PS bits according to huart->Init.Parity value
   1894               Set TE and RE bits according to huart->Init.Mode value
   1895               Set OVER8 bit according to huart->Init.OverSampling value */
   1896            tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
   \   00000018   0x68A0             LDR      R0,[R4, #+8]
   \   0000001A   0x6921             LDR      R1,[R4, #+16]
   \   0000001C   0x4308             ORRS     R0,R1,R0
   \   0000001E   0x6961             LDR      R1,[R4, #+20]
   \   00000020   0x4308             ORRS     R0,R1,R0
   \   00000022   0x69E1             LDR      R1,[R4, #+28]
   \   00000024   0x4308             ORRS     R0,R1,R0
   1897            MODIFY_REG(huart->Instance->CR1, 
   1898                       (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8), 
   1899                       tmpreg);
   \   00000026   0x6821             LDR      R1,[R4, #+0]
   \   00000028   0x68C9             LDR      R1,[R1, #+12]
   \   0000002A   0x....             LDR.N    R2,??DataTable0  ;; 0xffff69f3
   \   0000002C   0x4011             ANDS     R1,R2,R1
   \   0000002E   0x4308             ORRS     R0,R0,R1
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x60C8             STR      R0,[R1, #+12]
   1900            
   1901            /*------- UART-associated USART registers setting : CR3 Configuration ------*/
   1902            /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
   1903            MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x6940             LDR      R0,[R0, #+20]
   \   00000038   0xF430 0x7040      BICS     R0,R0,#0x300
   \   0000003C   0x69A1             LDR      R1,[R4, #+24]
   \   0000003E   0x4308             ORRS     R0,R1,R0
   \   00000040   0x6821             LDR      R1,[R4, #+0]
   \   00000042   0x6148             STR      R0,[R1, #+20]
   1904            
   1905            /* Check the Over Sampling */
   1906            if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
   \   00000044   0x69E0             LDR      R0,[R4, #+28]
   \   00000046   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000004A   0xF040 0x80AC      BNE.W    ??UART_SetConfig_0
   1907            {
   1908              /*------- UART-associated USART registers setting : BRR Configuration ------*/
   1909              if((huart->Instance == USART1))
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x....             LDR.N    R1,??DataTable0_1  ;; 0x40013800
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xD153             BNE.N    ??UART_SetConfig_1
   1910              {
   1911                huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
   \   00000056   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   0000005A   0x4680             MOV      R8,R0
   \   0000005C   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   00000060   0x0006             MOVS     R6,R0
   \   00000062   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   00000066   0x0007             MOVS     R7,R0
   \   00000068   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   0000006C   0x0005             MOVS     R5,R0
   \   0000006E   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   00000072   0x2119             MOVS     R1,#+25
   \   00000074   0xFB01 0xF108      MUL      R1,R1,R8
   \   00000078   0x6862             LDR      R2,[R4, #+4]
   \   0000007A   0x0052             LSLS     R2,R2,#+1
   \   0000007C   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000080   0x2264             MOVS     R2,#+100
   \   00000082   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000086   0x2219             MOVS     R2,#+25
   \   00000088   0xFB02 0xF206      MUL      R2,R2,R6
   \   0000008C   0x6863             LDR      R3,[R4, #+4]
   \   0000008E   0x005B             LSLS     R3,R3,#+1
   \   00000090   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   00000094   0x2319             MOVS     R3,#+25
   \   00000096   0xFB03 0xF307      MUL      R3,R3,R7
   \   0000009A   0x6866             LDR      R6,[R4, #+4]
   \   0000009C   0x0076             LSLS     R6,R6,#+1
   \   0000009E   0xFBB3 0xF3F6      UDIV     R3,R3,R6
   \   000000A2   0x2664             MOVS     R6,#+100
   \   000000A4   0xFBB3 0xF3F6      UDIV     R3,R3,R6
   \   000000A8   0x2664             MOVS     R6,#+100
   \   000000AA   0xFB06 0x2213      MLS      R2,R6,R3,R2
   \   000000AE   0x00D2             LSLS     R2,R2,#+3
   \   000000B0   0x3232             ADDS     R2,R2,#+50
   \   000000B2   0x2364             MOVS     R3,#+100
   \   000000B4   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   000000B8   0xF012 0x02F8      ANDS     R2,R2,#0xF8
   \   000000BC   0x0052             LSLS     R2,R2,#+1
   \   000000BE   0xEB12 0x1101      ADDS     R1,R2,R1, LSL #+4
   \   000000C2   0x2219             MOVS     R2,#+25
   \   000000C4   0xFB02 0xF205      MUL      R2,R2,R5
   \   000000C8   0x6863             LDR      R3,[R4, #+4]
   \   000000CA   0x005B             LSLS     R3,R3,#+1
   \   000000CC   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   000000D0   0x2319             MOVS     R3,#+25
   \   000000D2   0x4358             MULS     R0,R3,R0
   \   000000D4   0x6863             LDR      R3,[R4, #+4]
   \   000000D6   0x005B             LSLS     R3,R3,#+1
   \   000000D8   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   000000DC   0x2364             MOVS     R3,#+100
   \   000000DE   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   000000E2   0x2364             MOVS     R3,#+100
   \   000000E4   0xFB03 0x2010      MLS      R0,R3,R0,R2
   \   000000E8   0x00C0             LSLS     R0,R0,#+3
   \   000000EA   0x3032             ADDS     R0,R0,#+50
   \   000000EC   0x2264             MOVS     R2,#+100
   \   000000EE   0xFBB0 0xF0F2      UDIV     R0,R0,R2
   \   000000F2   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   000000F6   0x1840             ADDS     R0,R0,R1
   \   000000F8   0x6821             LDR      R1,[R4, #+0]
   \   000000FA   0x6088             STR      R0,[R1, #+8]
   \   000000FC   0xE0FC             B.N      ??UART_SetConfig_2
   1912              }
   1913              else
   1914              {
   1915                huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
   \                     ??UART_SetConfig_1: (+1)
   \   000000FE   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   00000102   0x4680             MOV      R8,R0
   \   00000104   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   00000108   0x0006             MOVS     R6,R0
   \   0000010A   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   0000010E   0x0007             MOVS     R7,R0
   \   00000110   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   00000114   0x0005             MOVS     R5,R0
   \   00000116   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   0000011A   0x2119             MOVS     R1,#+25
   \   0000011C   0xFB01 0xF108      MUL      R1,R1,R8
   \   00000120   0x6862             LDR      R2,[R4, #+4]
   \   00000122   0x0052             LSLS     R2,R2,#+1
   \   00000124   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000128   0x2264             MOVS     R2,#+100
   \   0000012A   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   0000012E   0x2219             MOVS     R2,#+25
   \   00000130   0xFB02 0xF206      MUL      R2,R2,R6
   \   00000134   0x6863             LDR      R3,[R4, #+4]
   \   00000136   0x005B             LSLS     R3,R3,#+1
   \   00000138   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   0000013C   0x2319             MOVS     R3,#+25
   \   0000013E   0xFB03 0xF307      MUL      R3,R3,R7
   \   00000142   0x6866             LDR      R6,[R4, #+4]
   \   00000144   0x0076             LSLS     R6,R6,#+1
   \   00000146   0xFBB3 0xF3F6      UDIV     R3,R3,R6
   \   0000014A   0x2664             MOVS     R6,#+100
   \   0000014C   0xFBB3 0xF3F6      UDIV     R3,R3,R6
   \   00000150   0x2664             MOVS     R6,#+100
   \   00000152   0xFB06 0x2213      MLS      R2,R6,R3,R2
   \   00000156   0x00D2             LSLS     R2,R2,#+3
   \   00000158   0x3232             ADDS     R2,R2,#+50
   \   0000015A   0x2364             MOVS     R3,#+100
   \   0000015C   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   00000160   0xF012 0x02F8      ANDS     R2,R2,#0xF8
   \   00000164   0x0052             LSLS     R2,R2,#+1
   \   00000166   0xEB12 0x1101      ADDS     R1,R2,R1, LSL #+4
   \   0000016A   0x2219             MOVS     R2,#+25
   \   0000016C   0xFB02 0xF205      MUL      R2,R2,R5
   \   00000170   0x6863             LDR      R3,[R4, #+4]
   \   00000172   0x005B             LSLS     R3,R3,#+1
   \   00000174   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   00000178   0x2319             MOVS     R3,#+25
   \   0000017A   0x4358             MULS     R0,R3,R0
   \   0000017C   0x6863             LDR      R3,[R4, #+4]
   \   0000017E   0x005B             LSLS     R3,R3,#+1
   \   00000180   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   00000184   0x2364             MOVS     R3,#+100
   \   00000186   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   0000018A   0x2364             MOVS     R3,#+100
   \   0000018C   0xFB03 0x2010      MLS      R0,R3,R0,R2
   \   00000190   0x00C0             LSLS     R0,R0,#+3
   \   00000192   0x3032             ADDS     R0,R0,#+50
   \   00000194   0x2264             MOVS     R2,#+100
   \   00000196   0xFBB0 0xF0F2      UDIV     R0,R0,R2
   \   0000019A   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   0000019E   0x1840             ADDS     R0,R0,R1
   \   000001A0   0x6821             LDR      R1,[R4, #+0]
   \   000001A2   0x6088             STR      R0,[R1, #+8]
   \   000001A4   0xE0A8             B.N      ??UART_SetConfig_2
   1916              }
   1917            }
   1918            else
   1919            {
   1920              /*------- UART-associated USART registers setting : BRR Configuration ------*/
   1921              if((huart->Instance == USART1))
   \                     ??UART_SetConfig_0: (+1)
   \   000001A6   0x6820             LDR      R0,[R4, #+0]
   \   000001A8   0x....             LDR.N    R1,??DataTable0_1  ;; 0x40013800
   \   000001AA   0x4288             CMP      R0,R1
   \   000001AC   0xD152             BNE.N    ??UART_SetConfig_3
   1922              {
   1923                huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
   \   000001AE   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   000001B2   0x4680             MOV      R8,R0
   \   000001B4   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   000001B8   0x0006             MOVS     R6,R0
   \   000001BA   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   000001BE   0x0007             MOVS     R7,R0
   \   000001C0   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   000001C4   0x0005             MOVS     R5,R0
   \   000001C6   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   000001CA   0x2119             MOVS     R1,#+25
   \   000001CC   0xFB01 0xF108      MUL      R1,R1,R8
   \   000001D0   0x6862             LDR      R2,[R4, #+4]
   \   000001D2   0x0092             LSLS     R2,R2,#+2
   \   000001D4   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   000001D8   0x2264             MOVS     R2,#+100
   \   000001DA   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   000001DE   0x2219             MOVS     R2,#+25
   \   000001E0   0xFB02 0xF206      MUL      R2,R2,R6
   \   000001E4   0x6863             LDR      R3,[R4, #+4]
   \   000001E6   0x009B             LSLS     R3,R3,#+2
   \   000001E8   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   000001EC   0x2319             MOVS     R3,#+25
   \   000001EE   0xFB03 0xF307      MUL      R3,R3,R7
   \   000001F2   0x6866             LDR      R6,[R4, #+4]
   \   000001F4   0x00B6             LSLS     R6,R6,#+2
   \   000001F6   0xFBB3 0xF3F6      UDIV     R3,R3,R6
   \   000001FA   0x2664             MOVS     R6,#+100
   \   000001FC   0xFBB3 0xF3F6      UDIV     R3,R3,R6
   \   00000200   0x2664             MOVS     R6,#+100
   \   00000202   0xFB06 0x2213      MLS      R2,R6,R3,R2
   \   00000206   0x0112             LSLS     R2,R2,#+4
   \   00000208   0x3232             ADDS     R2,R2,#+50
   \   0000020A   0x2364             MOVS     R3,#+100
   \   0000020C   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   00000210   0xF012 0x02F0      ANDS     R2,R2,#0xF0
   \   00000214   0xEB12 0x1101      ADDS     R1,R2,R1, LSL #+4
   \   00000218   0x2219             MOVS     R2,#+25
   \   0000021A   0xFB02 0xF205      MUL      R2,R2,R5
   \   0000021E   0x6863             LDR      R3,[R4, #+4]
   \   00000220   0x009B             LSLS     R3,R3,#+2
   \   00000222   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   00000226   0x2319             MOVS     R3,#+25
   \   00000228   0x4358             MULS     R0,R3,R0
   \   0000022A   0x6863             LDR      R3,[R4, #+4]
   \   0000022C   0x009B             LSLS     R3,R3,#+2
   \   0000022E   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   00000232   0x2364             MOVS     R3,#+100
   \   00000234   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   00000238   0x2364             MOVS     R3,#+100
   \   0000023A   0xFB03 0x2010      MLS      R0,R3,R0,R2
   \   0000023E   0x0100             LSLS     R0,R0,#+4
   \   00000240   0x3032             ADDS     R0,R0,#+50
   \   00000242   0x2264             MOVS     R2,#+100
   \   00000244   0xFBB0 0xF0F2      UDIV     R0,R0,R2
   \   00000248   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   0000024C   0x1840             ADDS     R0,R0,R1
   \   0000024E   0x6821             LDR      R1,[R4, #+0]
   \   00000250   0x6088             STR      R0,[R1, #+8]
   \   00000252   0xE051             B.N      ??UART_SetConfig_2
   1924              }
   1925              else
   1926              {
   1927                huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
   \                     ??UART_SetConfig_3: (+1)
   \   00000254   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   00000258   0x4680             MOV      R8,R0
   \   0000025A   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   0000025E   0x0006             MOVS     R6,R0
   \   00000260   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   00000264   0x0007             MOVS     R7,R0
   \   00000266   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   0000026A   0x0005             MOVS     R5,R0
   \   0000026C   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   00000270   0x2119             MOVS     R1,#+25
   \   00000272   0xFB01 0xF108      MUL      R1,R1,R8
   \   00000276   0x6862             LDR      R2,[R4, #+4]
   \   00000278   0x0092             LSLS     R2,R2,#+2
   \   0000027A   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   0000027E   0x2264             MOVS     R2,#+100
   \   00000280   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000284   0x2219             MOVS     R2,#+25
   \   00000286   0xFB02 0xF206      MUL      R2,R2,R6
   \   0000028A   0x6863             LDR      R3,[R4, #+4]
   \   0000028C   0x009B             LSLS     R3,R3,#+2
   \   0000028E   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   00000292   0x2319             MOVS     R3,#+25
   \   00000294   0xFB03 0xF307      MUL      R3,R3,R7
   \   00000298   0x6866             LDR      R6,[R4, #+4]
   \   0000029A   0x00B6             LSLS     R6,R6,#+2
   \   0000029C   0xFBB3 0xF3F6      UDIV     R3,R3,R6
   \   000002A0   0x2664             MOVS     R6,#+100
   \   000002A2   0xFBB3 0xF3F6      UDIV     R3,R3,R6
   \   000002A6   0x2664             MOVS     R6,#+100
   \   000002A8   0xFB06 0x2213      MLS      R2,R6,R3,R2
   \   000002AC   0x0112             LSLS     R2,R2,#+4
   \   000002AE   0x3232             ADDS     R2,R2,#+50
   \   000002B0   0x2364             MOVS     R3,#+100
   \   000002B2   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   000002B6   0xF012 0x02F0      ANDS     R2,R2,#0xF0
   \   000002BA   0xEB12 0x1101      ADDS     R1,R2,R1, LSL #+4
   \   000002BE   0x2219             MOVS     R2,#+25
   \   000002C0   0xFB02 0xF205      MUL      R2,R2,R5
   \   000002C4   0x6863             LDR      R3,[R4, #+4]
   \   000002C6   0x009B             LSLS     R3,R3,#+2
   \   000002C8   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   000002CC   0x2319             MOVS     R3,#+25
   \   000002CE   0x4358             MULS     R0,R3,R0
   \   000002D0   0x6863             LDR      R3,[R4, #+4]
   \   000002D2   0x009B             LSLS     R3,R3,#+2
   \   000002D4   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   000002D8   0x2364             MOVS     R3,#+100
   \   000002DA   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   000002DE   0x2364             MOVS     R3,#+100
   \   000002E0   0xFB03 0x2010      MLS      R0,R3,R0,R2
   \   000002E4   0x0100             LSLS     R0,R0,#+4
   \   000002E6   0x3032             ADDS     R0,R0,#+50
   \   000002E8   0x2264             MOVS     R2,#+100
   \   000002EA   0xFBB0 0xF0F2      UDIV     R0,R0,R2
   \   000002EE   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   000002F2   0x1840             ADDS     R0,R0,R1
   \   000002F4   0x6821             LDR      R1,[R4, #+0]
   \   000002F6   0x6088             STR      R0,[R1, #+8]
   1928              }
   1929            }
   1930          }
   \                     ??UART_SetConfig_2: (+1)
   \   000002F8   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0xFFFF69F3         DC32     0xffff69f3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0x40013800         DC32     0x40013800
   1931          /**
   1932            * @}
   1933            */
   1934          
   1935          #endif /* HAL_UART_MODULE_ENABLED */
   1936          /**
   1937            * @}
   1938            */
   1939          
   1940          /**
   1941            * @}
   1942            */
   1943          
   1944          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_HalfDuplex_EnableReceiver
       0   HAL_HalfDuplex_EnableTransmitter
       8   HAL_HalfDuplex_Init
         8   -> HAL_UART_MspInit
         8   -> UART_SetConfig
      16   HAL_LIN_Init
        16   -> HAL_UART_MspInit
        16   -> UART_SetConfig
       0   HAL_LIN_SendBreak
       0   HAL_MultiProcessor_EnterMuteMode
       0   HAL_MultiProcessor_ExitMuteMode
      16   HAL_MultiProcessor_Init
        16   -> HAL_UART_MspInit
        16   -> UART_SetConfig
       0   HAL_UART_DMAPause
       4   HAL_UART_DMAResume
       8   HAL_UART_DMAStop
         8   -> HAL_DMA_Abort
       8   HAL_UART_DeInit
         8   -> HAL_UART_MspDeInit
       0   HAL_UART_ErrorCallback
       0   HAL_UART_GetError
       0   HAL_UART_GetState
      16   HAL_UART_IRQHandler
        16   -> HAL_UART_ErrorCallback
        16   -> UART_EndTransmit_IT
        16   -> UART_Receive_IT
        16   -> UART_Transmit_IT
       8   HAL_UART_Init
         8   -> HAL_UART_MspInit
         8   -> UART_SetConfig
       0   HAL_UART_MspDeInit
       0   HAL_UART_MspInit
      16   HAL_UART_Receive
        16   -> UART_WaitOnFlagUntilTimeout
      16   HAL_UART_Receive_DMA
        16   -> HAL_DMA_Start_IT
       0   HAL_UART_Receive_IT
       0   HAL_UART_RxCpltCallback
       0   HAL_UART_RxHalfCpltCallback
      16   HAL_UART_Transmit
        16   -> UART_WaitOnFlagUntilTimeout
      16   HAL_UART_Transmit_DMA
        16   -> HAL_DMA_Start_IT
       0   HAL_UART_Transmit_IT
       0   HAL_UART_TxCpltCallback
       0   HAL_UART_TxHalfCpltCallback
       8   UART_DMAError
         8   -> HAL_UART_ErrorCallback
       8   UART_DMAReceiveCplt
         8   -> HAL_UART_RxCpltCallback
       8   UART_DMARxHalfCplt
         8   -> HAL_UART_RxHalfCpltCallback
       8   UART_DMATransmitCplt
         8   -> HAL_UART_TxCpltCallback
       8   UART_DMATxHalfCplt
         8   -> HAL_UART_TxHalfCpltCallback
       8   UART_EndTransmit_IT
         8   -> HAL_UART_TxCpltCallback
       8   UART_Receive_IT
         8   -> HAL_UART_RxCpltCallback
      24   UART_SetConfig
        24   -> HAL_RCC_GetPCLK1Freq
        24   -> HAL_RCC_GetPCLK2Freq
       0   UART_Transmit_IT
      24   UART_WaitOnFlagUntilTimeout
        24   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
      56  HAL_HalfDuplex_EnableReceiver
      56  HAL_HalfDuplex_EnableTransmitter
     118  HAL_HalfDuplex_Init
     134  HAL_LIN_Init
      52  HAL_LIN_SendBreak
      52  HAL_MultiProcessor_EnterMuteMode
      52  HAL_MultiProcessor_ExitMuteMode
     140  HAL_MultiProcessor_Init
     102  HAL_UART_DMAPause
     134  HAL_UART_DMAResume
      50  HAL_UART_DMAStop
      74  HAL_UART_DeInit
       2  HAL_UART_ErrorCallback
       4  HAL_UART_GetError
       6  HAL_UART_GetState
     258  HAL_UART_IRQHandler
     112  HAL_UART_Init
       2  HAL_UART_MspDeInit
       2  HAL_UART_MspInit
     244  HAL_UART_Receive
     152  HAL_UART_Receive_DMA
     128  HAL_UART_Receive_IT
       2  HAL_UART_RxCpltCallback
       2  HAL_UART_RxHalfCpltCallback
     234  HAL_UART_Transmit
     162  HAL_UART_Transmit_DMA
     104  HAL_UART_Transmit_IT
       2  HAL_UART_TxCpltCallback
       2  HAL_UART_TxHalfCpltCallback
      32  UART_DMAError
      58  UART_DMAReceiveCplt
      10  UART_DMARxHalfCplt
      50  UART_DMATransmitCplt
      10  UART_DMATxHalfCplt
      44  UART_EndTransmit_IT
     188  UART_Receive_IT
     764  UART_SetConfig
     112  UART_Transmit_IT
     224  UART_WaitOnFlagUntilTimeout

 
 3 938 bytes in section .text
 
 3 938 bytes of CODE memory

Errors: none
Warnings: none
