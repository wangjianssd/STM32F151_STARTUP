###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       21/Sep/2016  16:57:23
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  D:\01work\proj\ｵﾘｴﾅ\Code\Bsp\Src\qmc5883l.c
#    Command line =  
#        D:\01work\proj\ｵﾘｴﾅ\Code\Bsp\Src\qmc5883l.c -D USE_HAL_DRIVER -D
#        STM32L151xD -lC
#        D:\01work\proj\ｵﾘｴﾅ\Code\Project\Qmc5883Test-IAR7.5\Debug\List -lA
#        D:\01work\proj\ｵﾘｴﾅ\Code\Project\Qmc5883Test-IAR7.5\Debug\List -o
#        D:\01work\proj\ｵﾘｴﾅ\Code\Project\Qmc5883Test-IAR7.5\Debug\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\01work\proj\ｵﾘｴﾅ\Code\Project\Qmc5883Test-IAR7.5/../../Apps/Config\
#        -I
#        D:\01work\proj\ｵﾘｴﾅ\Code\Project\Qmc5883Test-IAR7.5/../../Drivers\Inc\
#        -I
#        D:\01work\proj\ｵﾘｴﾅ\Code\Project\Qmc5883Test-IAR7.5/../../Drivers\Core\CMSIS\RTOS\Template\
#        -I
#        D:\01work\proj\ｵﾘｴﾅ\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/CMSIS/Device/ST/STM32L1xx/Include\
#        -I
#        D:\01work\proj\ｵﾘｴﾅ\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/STM32L1xx_HAL_Driver/Config\
#        -I
#        D:\01work\proj\ｵﾘｴﾅ\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/STM32L1xx_HAL_Driver/Inc\
#        -I
#        D:\01work\proj\ｵﾘｴﾅ\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/STM32L1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\01work\proj\ｵﾘｴﾅ\Code\Project\Qmc5883Test-IAR7.5/../../Middlewares/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\01work\proj\ｵﾘｴﾅ\Code\Project\Qmc5883Test-IAR7.5/../../Middlewares/FreeRTOS/Source/include\
#        -I
#        D:\01work\proj\ｵﾘｴﾅ\Code\Project\Qmc5883Test-IAR7.5/../../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\01work\proj\ｵﾘｴﾅ\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/CMSIS/Include\
#        -I
#        D:\01work\proj\ｵﾘｴﾅ\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/RTT\
#        -I D:\01work\proj\ｵﾘｴﾅ\Code\Project\Qmc5883Test-IAR7.5/../../Drivers\
#        -I D:\01work\proj\ｵﾘｴﾅ\Code\Project\Qmc5883Test-IAR7.5/../../BSP/Inc/\
#        -I
#        D:\01work\proj\ｵﾘｴﾅ\Code\Project\Qmc5883Test-IAR7.5/../../Drivers/Core/CMSIS/Device/ST/STM32L1xx/Include\
#        -Ol
#    List file    =  
#        D:\01work\proj\ｵﾘｴﾅ\Code\Project\Qmc5883Test-IAR7.5\Debug\List\qmc5883l.lst
#    Object file  =  
#        D:\01work\proj\ｵﾘｴﾅ\Code\Project\Qmc5883Test-IAR7.5\Debug\Obj\qmc5883l.o
#
###############################################################################

D:\01work\proj\ｵﾘｴﾅ\Code\Bsp\Src\qmc5883l.c
      1          /**
      2           * @brief       : 
      3           *
      4           * @file        : qmc5883.c
      5           * @author      : WangJian
      6           * @version     : v0.0.1
      7           * @date        : 2016/09/21 
      8           *
      9           * Change Logs  :
     10           *
     11           * Date        Version      Author      Notes
     12           * 2016/09/21    v0.0.1     WangJian    first version
     13           */
     14          
     15          /* Includes ------------------------------------------------------------------*/
     16          #include "bsp.h"
     17          
     18          /* Define --------------------------------------------------------------------*/
     19          #define ABS(n)                  (((n) < 0) ? -(n) : (n))
     20              
     21          /* Private function prototypes -----------------------------------------------*/ 
     22          static bool Qmc5883lPowerOn(void);
     23          static bool Qmc5883lPowerOff(void);
     24          static bool  Qmc5883lI2cByteRead(uint8_t reg, uint8_t* data);
     25          static bool  Qmc5883lI2cBytesRead(uint8_t reg, uint8_t* data, uint16_t size);
     26          static bool  Qmc5883lI2cByteWrite (uint8_t reg, uint8_t  data);
     27          
     28          
     29          /* Private variables ---------------------------------------------------------*/

   \                                 In section .bss, align 4
     30          static I2cHanderTypeDef I2cHander;
   \                     I2cHander:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
     31          static int16_t FilterArrary[__QMC5883L_AVG_FILTER_NUM__][3] = {0};
   \                     FilterArrary:
   \   00000000                      DS8 48

   \                                 In section .bss, align 1
     32          static uint8_t FilterCount = 0;
   \                     FilterCount:
   \   00000000                      DS8 1
     33          

   \                                 In section .text, align 2, keep-with-next
     34          bool Qmc5883lPowerOn(void)
     35          {
   \                     Qmc5883lPowerOn: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     36            //HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_SET);
     37            Delay(2);
   \   00000002   0x2002             MOVS     R0,#+2
   \   00000004   0x.... 0x....      BL       Delay
     38          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function
          "Qmc5883lPowerOn"
   \   00000008   0xBD02             POP      {R1,PC}          ;; return
     39          

   \                                 In section .text, align 2, keep-with-next
     40          bool Qmc5883lPowerOff(void)
     41          {
   \                     Qmc5883lPowerOff: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     42            //HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);
     43            Delay(2);
   \   00000002   0x2002             MOVS     R0,#+2
   \   00000004   0x.... 0x....      BL       Delay
     44          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function
          "Qmc5883lPowerOff"
   \   00000008   0xBD02             POP      {R1,PC}          ;; return
     45          

   \                                 In section .text, align 2, keep-with-next
     46          bool Qmc5883lInit(void)
     47          {
   \                     Qmc5883lInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     48            I2cHander.i2c = __QMC5883L_I2C_HANDLER__;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable4
   \   00000008   0x7008             STRB     R0,[R1, #+0]
     49            I2cHander.clock = __QMC5883L_I2C_CLOCK__;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable4_1  ;; 0x186a0
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable4
   \   00000012   0x6048             STR      R0,[R1, #+4]
     50            I2cHander.addr_mode = I2C_ADDRESS_MODE_7BIT;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable4
   \   0000001A   0x7208             STRB     R0,[R1, #+8]
     51          
     52            if (I2cInit(I2cHander) != true)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable4
   \   00000020   0xC807             LDM      R0,{R0-R2}
   \   00000022   0x.... 0x....      BL       I2cInit
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD101             BNE.N    ??Qmc5883lInit_0
     53            {
     54              return false;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE00E             B.N      ??Qmc5883lInit_1
     55            }
     56          
     57            memset(FilterArrary, 0, sizeof(FilterArrary));
                   ^
Warning[Pe223]: function "memset" declared implicitly
   \                     ??Qmc5883lInit_0: (+1)
   \   0000002E   0x2230             MOVS     R2,#+48
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable4_2
   \   00000036   0x.... 0x....      BL       memset
     58            
     59            FilterCount = 0;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable4_3
   \   00000040   0x7008             STRB     R0,[R1, #+0]
     60            
     61            Qmc5883lPowerOff();
   \   00000042   0x.... 0x....      BL       Qmc5883lPowerOff
     62              
     63            Qmc5883lPowerOn();  
   \   00000046   0x.... 0x....      BL       Qmc5883lPowerOn
     64            
     65            return true;
   \   0000004A   0x2001             MOVS     R0,#+1
   \                     ??Qmc5883lInit_1: (+1)
   \   0000004C   0xBD02             POP      {R1,PC}          ;; return
     66          }
     67          

   \                                 In section .text, align 2, keep-with-next
     68          bool Qmc5883lConfig(void)
     69          {
   \                     Qmc5883lConfig: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
     70               bool ret;
     71               
     72               uint8_t  temp[16];
     73               
     74               float magnet[3];
     75               
     76               memset(temp, 0 , sizeof(temp));
                      ^
Warning[Pe223]: function "memset" declared implicitly

       bool ret;
            ^
"D:\01work\proj\蝨ｰ逎―Code\Bsp\Src\qmc5883l.c",70  Warning[Pe550]: variable
          "ret" was set but never used

       float magnet[3];
             ^
"D:\01work\proj\蝨ｰ逎―Code\Bsp\Src\qmc5883l.c",74  Warning[Pe177]: variable
          "magnet" was declared but never referenced
   \   00000004   0x2210             MOVS     R2,#+16
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x.... 0x....      BL       memset
     77              
     78              ret = Qmc5883lI2cBytesRead(0, temp, 0x0B);
   \   0000000E   0x220B             MOVS     R2,#+11
   \   00000010   0x4669             MOV      R1,SP
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      BL       Qmc5883lI2cBytesRead
     79              
     80              Qmc5883lI2cByteWrite(0x0B, 0x01);
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x200B             MOVS     R0,#+11
   \   0000001C   0x.... 0x....      BL       Qmc5883lI2cByteWrite
     81                  
     82              Qmc5883lI2cByteWrite(0x20, 0x40);
   \   00000020   0x2140             MOVS     R1,#+64
   \   00000022   0x2020             MOVS     R0,#+32
   \   00000024   0x.... 0x....      BL       Qmc5883lI2cByteWrite
     83          
     84              Qmc5883lI2cByteWrite(0x21, 0x01);
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0x2021             MOVS     R0,#+33
   \   0000002C   0x.... 0x....      BL       Qmc5883lI2cByteWrite
     85          
     86              Qmc5883lI2cByteWrite(0x09, __QMC5883L_REG_09_VALUE__);    //10hz
   \   00000030   0x2141             MOVS     R1,#+65
   \   00000032   0x2009             MOVS     R0,#+9
   \   00000034   0x.... 0x....      BL       Qmc5883lI2cByteWrite
     87          
     88             // osDelay(10);
     89              
     90              ret = Qmc5883lI2cBytesRead(0, temp, 0x0B);
   \   00000038   0x220B             MOVS     R2,#+11
   \   0000003A   0x4669             MOV      R1,SP
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x.... 0x....      BL       Qmc5883lI2cBytesRead
     91          
     92              if (temp[0x09] == __QMC5883L_REG_09_VALUE__)
   \   00000042   0xF89D 0x0009      LDRB     R0,[SP, #+9]
   \   00000046   0x2841             CMP      R0,#+65
   \   00000048   0xD101             BNE.N    ??Qmc5883lConfig_0
     93              {
     94                  return true;
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0xE000             B.N      ??Qmc5883lConfig_1
     95              }
     96          
     97              return false;
   \                     ??Qmc5883lConfig_0: (+1)
   \   0000004E   0x2000             MOVS     R0,#+0
   \                     ??Qmc5883lConfig_1: (+1)
   \   00000050   0xB005             ADD      SP,SP,#+20
   \   00000052   0xBD00             POP      {PC}             ;; return
     98          }
     99          

   \                                 In section .text, align 2, keep-with-next
    100          bool Qmc5883lConfigEx(uint8_t reg_9)
    101          {
   \                     Qmc5883lConfigEx: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    102               bool ret;
    103               
    104               uint8_t  temp[16];
    105               
    106               float magnet[3];
    107               
    108               memset(temp, 0 , sizeof(temp));
                      ^
Warning[Pe223]: function "memset" declared implicitly

       bool ret;
            ^
"D:\01work\proj\蝨ｰ逎―Code\Bsp\Src\qmc5883l.c",102  Warning[Pe550]: variable
          "ret" was set but never used

       float magnet[3];
             ^
"D:\01work\proj\蝨ｰ逎―Code\Bsp\Src\qmc5883l.c",106  Warning[Pe177]: variable
          "magnet" was declared but never referenced
   \   00000004   0x2210             MOVS     R2,#+16
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x.... 0x....      BL       memset
    109              
    110              ret = Qmc5883lI2cBytesRead(0, temp, 0x0B);
   \   0000000E   0x220B             MOVS     R2,#+11
   \   00000010   0x4669             MOV      R1,SP
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      BL       Qmc5883lI2cBytesRead
    111          
    112              Qmc5883lI2cByteWrite(0x0B, 0x01);
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x200B             MOVS     R0,#+11
   \   0000001C   0x.... 0x....      BL       Qmc5883lI2cByteWrite
    113                  
    114              Qmc5883lI2cByteWrite(0x20, 0x40);
   \   00000020   0x2140             MOVS     R1,#+64
   \   00000022   0x2020             MOVS     R0,#+32
   \   00000024   0x.... 0x....      BL       Qmc5883lI2cByteWrite
    115          
    116              Qmc5883lI2cByteWrite(0x21, 0x01);
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0x2021             MOVS     R0,#+33
   \   0000002C   0x.... 0x....      BL       Qmc5883lI2cByteWrite
    117          
    118              Qmc5883lI2cByteWrite(0x09, reg_9);    //10hz
   \   00000030   0x0021             MOVS     R1,R4
   \   00000032   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000034   0x2009             MOVS     R0,#+9
   \   00000036   0x.... 0x....      BL       Qmc5883lI2cByteWrite
    119          
    120             // osDelay(10);
    121              
    122              ret = Qmc5883lI2cBytesRead(0, temp, 0x0B);
   \   0000003A   0x220B             MOVS     R2,#+11
   \   0000003C   0x4669             MOV      R1,SP
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x.... 0x....      BL       Qmc5883lI2cBytesRead
    123          
    124              if (temp[0x09] == reg_9)
   \   00000044   0xF89D 0x0009      LDRB     R0,[SP, #+9]
   \   00000048   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004A   0x42A0             CMP      R0,R4
   \   0000004C   0xD101             BNE.N    ??Qmc5883lConfigEx_0
    125              {
    126                  return true;
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0xE000             B.N      ??Qmc5883lConfigEx_1
    127              }
    128          
    129              return false;
   \                     ??Qmc5883lConfigEx_0: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \                     ??Qmc5883lConfigEx_1: (+1)
   \   00000054   0xB004             ADD      SP,SP,#+16
   \   00000056   0xBD10             POP      {R4,PC}          ;; return
    130          }
    131          
    132          

   \                                 In section .text, align 2, keep-with-next
    133          bool Qmc5883lSelfTest (void)
    134          {
   \                     Qmc5883lSelfTest: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    135              uint8_t count = 0;
   \   00000004   0x2400             MOVS     R4,#+0
    136              uint8_t temp = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF88D 0x0010      STRB     R0,[SP, #+16]
    137              int16_t magnet_row_a[3] = {0};
   \   0000000C   0xA802             ADD      R0,SP,#+8
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0xC006             STM      R0!,{R1,R2}
   \   00000014   0x3808             SUBS     R0,R0,#+8
    138              int16_t magnet_row_b[3] = {0};
   \   00000016   0x4668             MOV      R0,SP
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x2200             MOVS     R2,#+0
   \   0000001C   0xC006             STM      R0!,{R1,R2}
   \   0000001E   0x3808             SUBS     R0,R0,#+8
    139              
    140              //  1.  0x20 = 40,  0x21=1,  0x0B=1,   0x09=1D
    141              Qmc5883lI2cByteWrite(0x20, 0x40);
   \   00000020   0x2140             MOVS     R1,#+64
   \   00000022   0x2020             MOVS     R0,#+32
   \   00000024   0x.... 0x....      BL       Qmc5883lI2cByteWrite
    142              Qmc5883lI2cByteWrite(0x21, 0x01);
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0x2021             MOVS     R0,#+33
   \   0000002C   0x.... 0x....      BL       Qmc5883lI2cByteWrite
    143              Qmc5883lI2cByteWrite(0x0B, 0x01);
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0x200B             MOVS     R0,#+11
   \   00000034   0x.... 0x....      BL       Qmc5883lI2cByteWrite
    144              Qmc5883lI2cByteWrite(0x09, 0x1D);
   \   00000038   0x211D             MOVS     R1,#+29
   \   0000003A   0x2009             MOVS     R0,#+9
   \   0000003C   0x.... 0x....      BL       Qmc5883lI2cByteWrite
    145          
    146              //  2.  Wait 10ms
    147              Delay(10);
   \   00000040   0x200A             MOVS     R0,#+10
   \   00000042   0x.... 0x....      BL       Delay
    148              //osDelay(10);
    149          
    150              //  3.  0x09=1C    ( enter standby mode)
    151              Qmc5883lI2cByteWrite(0x09, 0x1C);
   \   00000046   0x211C             MOVS     R1,#+28
   \   00000048   0x2009             MOVS     R0,#+9
   \   0000004A   0x.... 0x....      BL       Qmc5883lI2cByteWrite
    152          
    153              //  4.  0x0B=0      (turn off set/reset)
    154              Qmc5883lI2cByteWrite(0x0B, 0x00);
   \   0000004E   0x2100             MOVS     R1,#+0
   \   00000050   0x200B             MOVS     R0,#+11
   \   00000052   0x.... 0x....      BL       Qmc5883lI2cByteWrite
    155          
    156              //  5.  0x09=12    (self-test mode,  do set)
    157              Qmc5883lI2cByteWrite(0x09, 0x12);
   \   00000056   0x2112             MOVS     R1,#+18
   \   00000058   0x2009             MOVS     R0,#+9
   \   0000005A   0x.... 0x....      BL       Qmc5883lI2cByteWrite
    158          
    159              //  6.  Wait 10ms and check whether 0x09=10 (wait until selftest done)
    160             // osDelay(10);
    161              count = 0;
   \   0000005E   0x2400             MOVS     R4,#+0
    162          
    163              do
    164              {
    165                  if ( Qmc5883lI2cBytesRead(0x09, &temp, 1) == false)
   \                     ??Qmc5883lSelfTest_0: (+1)
   \   00000060   0x2201             MOVS     R2,#+1
   \   00000062   0xA904             ADD      R1,SP,#+16
   \   00000064   0x2009             MOVS     R0,#+9
   \   00000066   0x.... 0x....      BL       Qmc5883lI2cBytesRead
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD101             BNE.N    ??Qmc5883lSelfTest_1
    166                  {
    167                     return false;    
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xE077             B.N      ??Qmc5883lSelfTest_2
    168                  }
    169          //        if ( Qmc5883lI2cByteRead(0x09, &temp) == false)
    170          //        {
    171          //           return false;    
    172          //        }
    173                  Delay(1);
   \                     ??Qmc5883lSelfTest_1: (+1)
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0x.... 0x....      BL       Delay
    174                 // osDelay(1);
    175                 count++;
   \   00000078   0x1C64             ADDS     R4,R4,#+1
    176          
    177                  if (count >100)
   \   0000007A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007C   0x2C65             CMP      R4,#+101
   \   0000007E   0xDB01             BLT.N    ??Qmc5883lSelfTest_3
    178                  {
    179                      return false;    
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xE06E             B.N      ??Qmc5883lSelfTest_2
    180                  }
    181              } while (temp != 0x10);
   \                     ??Qmc5883lSelfTest_3: (+1)
   \   00000084   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \   00000088   0x2810             CMP      R0,#+16
   \   0000008A   0xD1E9             BNE.N    ??Qmc5883lSelfTest_0
    182          
    183              //  7.  0x09=1D
    184              Qmc5883lI2cByteWrite(0x09, 0x1D);
   \   0000008C   0x211D             MOVS     R1,#+29
   \   0000008E   0x2009             MOVS     R0,#+9
   \   00000090   0x.... 0x....      BL       Qmc5883lI2cByteWrite
    185          
    186              //  8.  Read x/y/z data  ( data A )
    187              Qmc5883lGetData(magnet_row_a);
   \   00000094   0xA802             ADD      R0,SP,#+8
   \   00000096   0x.... 0x....      BL       Qmc5883lGetData
    188          
    189              //  9.  0x09=13     (self-test mode,  do reset)
    190               Qmc5883lI2cByteWrite(0x09, 0x13);
   \   0000009A   0x2113             MOVS     R1,#+19
   \   0000009C   0x2009             MOVS     R0,#+9
   \   0000009E   0x.... 0x....      BL       Qmc5883lI2cByteWrite
    191          
    192              //  10. Wait 10ms  and check whether 0x09=10 (wait until selftest done)
    193          
    194              //osDelay(10);
    195              count = 0;
   \   000000A2   0x2400             MOVS     R4,#+0
    196              
    197              do
    198              {
    199                 // Qmc5883lI2cBytesRead(0x09, &temp, 1);
    200                  if ( Qmc5883lI2cBytesRead(0x09, &temp, 1) == false)
   \                     ??Qmc5883lSelfTest_4: (+1)
   \   000000A4   0x2201             MOVS     R2,#+1
   \   000000A6   0xA904             ADD      R1,SP,#+16
   \   000000A8   0x2009             MOVS     R0,#+9
   \   000000AA   0x.... 0x....      BL       Qmc5883lI2cBytesRead
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD101             BNE.N    ??Qmc5883lSelfTest_5
    201                  {
    202                     return false;    
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0xE055             B.N      ??Qmc5883lSelfTest_2
    203                  }
    204                 // osDelay(1);
    205                  Delay(1);
   \                     ??Qmc5883lSelfTest_5: (+1)
   \   000000B6   0x2001             MOVS     R0,#+1
   \   000000B8   0x.... 0x....      BL       Delay
    206                  count++;
   \   000000BC   0x1C64             ADDS     R4,R4,#+1
    207          
    208                  if (count >100)
   \   000000BE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C0   0x2C65             CMP      R4,#+101
   \   000000C2   0xDB01             BLT.N    ??Qmc5883lSelfTest_6
    209                  {
    210                      return false;    
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0xE04C             B.N      ??Qmc5883lSelfTest_2
    211                  }
    212                  
    213              } while (temp != 0x10);
   \                     ??Qmc5883lSelfTest_6: (+1)
   \   000000C8   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \   000000CC   0x2810             CMP      R0,#+16
   \   000000CE   0xD1E9             BNE.N    ??Qmc5883lSelfTest_4
    214          
    215              //  11. 0x09=1D
    216              Qmc5883lI2cByteWrite(0x09, 0x1D);
   \   000000D0   0x211D             MOVS     R1,#+29
   \   000000D2   0x2009             MOVS     R0,#+9
   \   000000D4   0x.... 0x....      BL       Qmc5883lI2cByteWrite
    217          
    218              //  12. Read x/y/z data  ( data B )
    219              Qmc5883lGetData(magnet_row_b);
   \   000000D8   0x4668             MOV      R0,SP
   \   000000DA   0x.... 0x....      BL       Qmc5883lGetData
    220          
    221              //  check data
    222              if ((ABS(magnet_row_a[0] + magnet_row_b[0]) < 120)
    223                &&(ABS(magnet_row_a[1] + magnet_row_b[1]) < 120)
    224                &&(ABS(magnet_row_a[2] + magnet_row_b[2]) < 120))
   \   000000DE   0xF9BD 0x0008      LDRSH    R0,[SP, #+8]
   \   000000E2   0xF9BD 0x1000      LDRSH    R1,[SP, #+0]
   \   000000E6   0x1808             ADDS     R0,R1,R0
   \   000000E8   0x2800             CMP      R0,#+0
   \   000000EA   0xD506             BPL.N    ??Qmc5883lSelfTest_7
   \   000000EC   0xF9BD 0x0008      LDRSH    R0,[SP, #+8]
   \   000000F0   0xF9BD 0x1000      LDRSH    R1,[SP, #+0]
   \   000000F4   0x1808             ADDS     R0,R1,R0
   \   000000F6   0x4240             RSBS     R0,R0,#+0
   \   000000F8   0xE004             B.N      ??Qmc5883lSelfTest_8
   \                     ??Qmc5883lSelfTest_7: (+1)
   \   000000FA   0xF9BD 0x0008      LDRSH    R0,[SP, #+8]
   \   000000FE   0xF9BD 0x1000      LDRSH    R1,[SP, #+0]
   \   00000102   0x1808             ADDS     R0,R1,R0
   \                     ??Qmc5883lSelfTest_8: (+1)
   \   00000104   0x2878             CMP      R0,#+120
   \   00000106   0xDA2B             BGE.N    ??Qmc5883lSelfTest_9
   \   00000108   0xF9BD 0x000A      LDRSH    R0,[SP, #+10]
   \   0000010C   0xF9BD 0x1002      LDRSH    R1,[SP, #+2]
   \   00000110   0x1808             ADDS     R0,R1,R0
   \   00000112   0x2800             CMP      R0,#+0
   \   00000114   0xD506             BPL.N    ??Qmc5883lSelfTest_10
   \   00000116   0xF9BD 0x000A      LDRSH    R0,[SP, #+10]
   \   0000011A   0xF9BD 0x1002      LDRSH    R1,[SP, #+2]
   \   0000011E   0x1808             ADDS     R0,R1,R0
   \   00000120   0x4240             RSBS     R0,R0,#+0
   \   00000122   0xE004             B.N      ??Qmc5883lSelfTest_11
   \                     ??Qmc5883lSelfTest_10: (+1)
   \   00000124   0xF9BD 0x000A      LDRSH    R0,[SP, #+10]
   \   00000128   0xF9BD 0x1002      LDRSH    R1,[SP, #+2]
   \   0000012C   0x1808             ADDS     R0,R1,R0
   \                     ??Qmc5883lSelfTest_11: (+1)
   \   0000012E   0x2878             CMP      R0,#+120
   \   00000130   0xDA16             BGE.N    ??Qmc5883lSelfTest_9
   \   00000132   0xF9BD 0x000C      LDRSH    R0,[SP, #+12]
   \   00000136   0xF9BD 0x1004      LDRSH    R1,[SP, #+4]
   \   0000013A   0x1808             ADDS     R0,R1,R0
   \   0000013C   0x2800             CMP      R0,#+0
   \   0000013E   0xD506             BPL.N    ??Qmc5883lSelfTest_12
   \   00000140   0xF9BD 0x000C      LDRSH    R0,[SP, #+12]
   \   00000144   0xF9BD 0x1004      LDRSH    R1,[SP, #+4]
   \   00000148   0x1808             ADDS     R0,R1,R0
   \   0000014A   0x4240             RSBS     R0,R0,#+0
   \   0000014C   0xE004             B.N      ??Qmc5883lSelfTest_13
   \                     ??Qmc5883lSelfTest_12: (+1)
   \   0000014E   0xF9BD 0x000C      LDRSH    R0,[SP, #+12]
   \   00000152   0xF9BD 0x1004      LDRSH    R1,[SP, #+4]
   \   00000156   0x1808             ADDS     R0,R1,R0
   \                     ??Qmc5883lSelfTest_13: (+1)
   \   00000158   0x2878             CMP      R0,#+120
   \   0000015A   0xDA01             BGE.N    ??Qmc5883lSelfTest_9
    225              {
    226                
    227               // *((uint32_t *)0xE000ED0C) = 0x05fa0004;  
    228                return true;
   \   0000015C   0x2001             MOVS     R0,#+1
   \   0000015E   0xE000             B.N      ??Qmc5883lSelfTest_2
    229              }
    230              
    231              return false;
   \                     ??Qmc5883lSelfTest_9: (+1)
   \   00000160   0x2000             MOVS     R0,#+0
   \                     ??Qmc5883lSelfTest_2: (+1)
   \   00000162   0xB006             ADD      SP,SP,#+24
   \   00000164   0xBD10             POP      {R4,PC}          ;; return
    232          
    233          }
    234          

   \                                 In section .text, align 2, keep-with-next
    235          bool Qmc5883lGetData (int16_t *magnet_raw)
    236          {
   \                     Qmc5883lGetData: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x0004             MOVS     R4,R0
    237              uint8_t buff[6];
    238              uint8_t i;
                             ^
Warning[Pe177]: variable "i" was declared but never referenced
    239              uint8_t temp;
    240              int16_t magnetRaw[3];
                             ^
Warning[Pe177]: variable "magnetRaw" was declared but never referenced
    241              uint8_t buff_temp[6];
                             ^
Warning[Pe177]: variable "buff_temp" was declared but never referenced
    242              float magnet[3];
                           ^
Warning[Pe550]: variable "magnet" was set but never used
    243              
    244              Qmc5883lI2cBytesRead(0x06, &temp, 1);
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0x4669             MOV      R1,SP
   \   0000000A   0x2006             MOVS     R0,#+6
   \   0000000C   0x.... 0x....      BL       Qmc5883lI2cBytesRead
    245              
    246              if (temp & 0x02)
   \   00000010   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000014   0x0780             LSLS     R0,R0,#+30
   \   00000016   0xD501             BPL.N    ??Qmc5883lGetData_0
    247              {
    248              	//LOG("output data OVL or ERROR!")
    249              	return false;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE038             B.N      ??Qmc5883lGetData_1
    250              }
    251              
    252              if ((temp & 0x01) == 0)
   \                     ??Qmc5883lGetData_0: (+1)
   \   0000001C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000020   0x07C0             LSLS     R0,R0,#+31
   \   00000022   0xD401             BMI.N    ??Qmc5883lGetData_2
    253              {
    254              	//LOG("output data not ready!")
    255              	return false;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xE032             B.N      ??Qmc5883lGetData_1
    256              }
    257          
    258              Qmc5883lI2cBytesRead(0, buff, 6);
   \                     ??Qmc5883lGetData_2: (+1)
   \   00000028   0x2206             MOVS     R2,#+6
   \   0000002A   0xA901             ADD      R1,SP,#+4
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x.... 0x....      BL       Qmc5883lI2cBytesRead
    259              
    260              magnet_raw[0] = ((int16_t)buff[1] << 8) | buff[0];
   \   00000032   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   00000036   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   0000003A   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   0000003E   0x8020             STRH     R0,[R4, #+0]
    261              magnet_raw[1] = ((int16_t)buff[3] << 8) | buff[2];
   \   00000040   0xF89D 0x0007      LDRB     R0,[SP, #+7]
   \   00000044   0xF89D 0x1006      LDRB     R1,[SP, #+6]
   \   00000048   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   0000004C   0x8060             STRH     R0,[R4, #+2]
    262              magnet_raw[2] = ((int16_t)buff[5] << 8) | buff[4];
   \   0000004E   0xF89D 0x0009      LDRB     R0,[SP, #+9]
   \   00000052   0xF89D 0x1008      LDRB     R1,[SP, #+8]
   \   00000056   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   0000005A   0x80A0             STRH     R0,[R4, #+4]
    263              
    264              magnet[0] = (float)magnet_raw[0] / 120.f;//uT
   \   0000005C   0xF9B4 0x0000      LDRSH    R0,[R4, #+0]
   \   00000060   0x.... 0x....      BL       __aeabi_i2f
   \   00000064   0x....             LDR.N    R1,??DataTable4_4  ;; 0x42f00000
   \   00000066   0x.... 0x....      BL       __aeabi_fdiv
   \   0000006A   0x9003             STR      R0,[SP, #+12]
    265              magnet[1] = (float)magnet_raw[1] / 120.f;//uT
   \   0000006C   0xF9B4 0x0002      LDRSH    R0,[R4, #+2]
   \   00000070   0x.... 0x....      BL       __aeabi_i2f
   \   00000074   0x....             LDR.N    R1,??DataTable4_4  ;; 0x42f00000
   \   00000076   0x.... 0x....      BL       __aeabi_fdiv
   \   0000007A   0x9004             STR      R0,[SP, #+16]
    266              magnet[2] = (float)magnet_raw[2] / 120.f;//uT
   \   0000007C   0xF9B4 0x0004      LDRSH    R0,[R4, #+4]
   \   00000080   0x.... 0x....      BL       __aeabi_i2f
   \   00000084   0x....             LDR.N    R1,??DataTable4_4  ;; 0x42f00000
   \   00000086   0x.... 0x....      BL       __aeabi_fdiv
   \   0000008A   0x9005             STR      R0,[SP, #+20]
    267          
    268              return true;
   \   0000008C   0x2001             MOVS     R0,#+1
   \                     ??Qmc5883lGetData_1: (+1)
   \   0000008E   0xB006             ADD      SP,SP,#+24
   \   00000090   0xBD10             POP      {R4,PC}          ;; return
    269          }
    270          

   \                                 In section .text, align 2, keep-with-next
    271          bool Qmc5883lFilterGetData (const int16_t *magnet_raw, float *magnet, int16_t *filter_magnet)
    272          {
   \                     Qmc5883lFilterGetData: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x000C             MOVS     R4,R1
   \   00000004   0x0015             MOVS     R5,R2
    273              uint8_t i = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    274              int32_t sum_x = 0;
   \   00000008   0x2100             MOVS     R1,#+0
    275              int32_t sum_y = 0;
   \   0000000A   0x2200             MOVS     R2,#+0
    276              int32_t sum_z = 0;
   \   0000000C   0x2300             MOVS     R3,#+0
    277              
    278              sum_x = magnet_raw[0];
   \   0000000E   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
    279              sum_y = magnet_raw[1];
   \   00000012   0xF9B0 0x2002      LDRSH    R2,[R0, #+2]
    280              sum_z = magnet_raw[2];
   \   00000016   0xF9B0 0x3004      LDRSH    R3,[R0, #+4]
    281              
    282              FilterCount++;
   \   0000001A   0x....             LDR.N    R6,??DataTable4_3
   \   0000001C   0x7836             LDRB     R6,[R6, #+0]
   \   0000001E   0x1C76             ADDS     R6,R6,#+1
   \   00000020   0x....             LDR.N    R7,??DataTable4_3
   \   00000022   0x703E             STRB     R6,[R7, #+0]
    283          
    284              if (FilterCount > __QMC5883L_AVG_FILTER_NUM__)
   \   00000024   0x....             LDR.N    R6,??DataTable4_3
   \   00000026   0x7836             LDRB     R6,[R6, #+0]
   \   00000028   0x2E09             CMP      R6,#+9
   \   0000002A   0xDB5A             BLT.N    ??Qmc5883lFilterGetData_0
    285              {
    286                  FilterCount = __QMC5883L_AVG_FILTER_NUM__;
   \   0000002C   0x2608             MOVS     R6,#+8
   \   0000002E   0x....             LDR.N    R7,??DataTable4_3
   \   00000030   0x703E             STRB     R6,[R7, #+0]
    287                  
    288                  for (i = 0; i < FilterCount - 1; i++)
   \   00000032   0x2600             MOVS     R6,#+0
   \                     ??Qmc5883lFilterGetData_1: (+1)
   \   00000034   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000036   0x....             LDR.N    R7,??DataTable4_3
   \   00000038   0x783F             LDRB     R7,[R7, #+0]
   \   0000003A   0x1E7F             SUBS     R7,R7,#+1
   \   0000003C   0x42BE             CMP      R6,R7
   \   0000003E   0xDA74             BGE.N    ??Qmc5883lFilterGetData_2
    289                  {
    290                      if (FilterCount == __QMC5883L_AVG_FILTER_NUM__)
   \   00000040   0x....             LDR.N    R7,??DataTable4_3
   \   00000042   0x783F             LDRB     R7,[R7, #+0]
   \   00000044   0x2F08             CMP      R7,#+8
   \   00000046   0xD12F             BNE.N    ??Qmc5883lFilterGetData_3
    291                      {
    292                        FilterArrary[i][0] = FilterArrary[i + 1][0];
   \   00000048   0x....             LDR.N    R7,??DataTable4_2
   \   0000004A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004C   0xF05F 0x0C06      MOVS     R12,#+6
   \   00000050   0xFB0C 0x7706      MLA      R7,R12,R6,R7
   \   00000054   0x88FF             LDRH     R7,[R7, #+6]
   \   00000056   0x.... 0x....      LDR.W    R12,??DataTable4_2
   \   0000005A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000005C   0xF05F 0x0E06      MOVS     LR,#+6
   \   00000060   0xFB0E 0xCC06      MLA      R12,LR,R6,R12
   \   00000064   0xF8AC 0x7000      STRH     R7,[R12, #+0]
    293                        FilterArrary[i][1] = FilterArrary[i + 1][1];
   \   00000068   0x....             LDR.N    R7,??DataTable4_2
   \   0000006A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000006C   0xF05F 0x0C06      MOVS     R12,#+6
   \   00000070   0xFB0C 0x7706      MLA      R7,R12,R6,R7
   \   00000074   0x893F             LDRH     R7,[R7, #+8]
   \   00000076   0x.... 0x....      LDR.W    R12,??DataTable4_2
   \   0000007A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000007C   0xF05F 0x0E06      MOVS     LR,#+6
   \   00000080   0xFB0E 0xCC06      MLA      R12,LR,R6,R12
   \   00000084   0xF8AC 0x7002      STRH     R7,[R12, #+2]
    294                        FilterArrary[i][2] = FilterArrary[i + 1][2];
   \   00000088   0x....             LDR.N    R7,??DataTable4_2
   \   0000008A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000008C   0xF05F 0x0C06      MOVS     R12,#+6
   \   00000090   0xFB0C 0x7706      MLA      R7,R12,R6,R7
   \   00000094   0x897F             LDRH     R7,[R7, #+10]
   \   00000096   0x.... 0x....      LDR.W    R12,??DataTable4_2
   \   0000009A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000009C   0xF05F 0x0E06      MOVS     LR,#+6
   \   000000A0   0xFB0E 0xCC06      MLA      R12,LR,R6,R12
   \   000000A4   0xF8AC 0x7004      STRH     R7,[R12, #+4]
    295                      }
    296          
    297                      sum_x += FilterArrary[i][0];
   \                     ??Qmc5883lFilterGetData_3: (+1)
   \   000000A8   0x....             LDR.N    R7,??DataTable4_2
   \   000000AA   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000AC   0xF05F 0x0C06      MOVS     R12,#+6
   \   000000B0   0xFB0C 0x7706      MLA      R7,R12,R6,R7
   \   000000B4   0xF9B7 0x7000      LDRSH    R7,[R7, #+0]
   \   000000B8   0x1879             ADDS     R1,R7,R1
    298                      sum_y += FilterArrary[i][1];
   \   000000BA   0x....             LDR.N    R7,??DataTable4_2
   \   000000BC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000BE   0xF05F 0x0C06      MOVS     R12,#+6
   \   000000C2   0xFB0C 0x7706      MLA      R7,R12,R6,R7
   \   000000C6   0xF9B7 0x7002      LDRSH    R7,[R7, #+2]
   \   000000CA   0x18BA             ADDS     R2,R7,R2
    299                      sum_z += FilterArrary[i][2];
   \   000000CC   0x....             LDR.N    R7,??DataTable4_2
   \   000000CE   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000D0   0xF05F 0x0C06      MOVS     R12,#+6
   \   000000D4   0xFB0C 0x7706      MLA      R7,R12,R6,R7
   \   000000D8   0xF9B7 0x7004      LDRSH    R7,[R7, #+4]
   \   000000DC   0x18FB             ADDS     R3,R7,R3
    300                  }
   \   000000DE   0x1C76             ADDS     R6,R6,#+1
   \   000000E0   0xE7A8             B.N      ??Qmc5883lFilterGetData_1
    301              }
    302              else
    303              {
    304                  for (i = 0; i < FilterCount - 1; i++)
   \                     ??Qmc5883lFilterGetData_0: (+1)
   \   000000E2   0x2600             MOVS     R6,#+0
   \   000000E4   0xE01B             B.N      ??Qmc5883lFilterGetData_4
    305                  {
    306                      sum_x += FilterArrary[i][0];
   \                     ??Qmc5883lFilterGetData_5: (+1)
   \   000000E6   0x....             LDR.N    R7,??DataTable4_2
   \   000000E8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000EA   0xF05F 0x0C06      MOVS     R12,#+6
   \   000000EE   0xFB0C 0x7706      MLA      R7,R12,R6,R7
   \   000000F2   0xF9B7 0x7000      LDRSH    R7,[R7, #+0]
   \   000000F6   0x1879             ADDS     R1,R7,R1
    307                      sum_y += FilterArrary[i][1];
   \   000000F8   0x....             LDR.N    R7,??DataTable4_2
   \   000000FA   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000FC   0xF05F 0x0C06      MOVS     R12,#+6
   \   00000100   0xFB0C 0x7706      MLA      R7,R12,R6,R7
   \   00000104   0xF9B7 0x7002      LDRSH    R7,[R7, #+2]
   \   00000108   0x18BA             ADDS     R2,R7,R2
    308                      sum_z += FilterArrary[i][2];
   \   0000010A   0x....             LDR.N    R7,??DataTable4_2
   \   0000010C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000010E   0xF05F 0x0C06      MOVS     R12,#+6
   \   00000112   0xFB0C 0x7706      MLA      R7,R12,R6,R7
   \   00000116   0xF9B7 0x7004      LDRSH    R7,[R7, #+4]
   \   0000011A   0x18FB             ADDS     R3,R7,R3
    309                  }
   \   0000011C   0x1C76             ADDS     R6,R6,#+1
   \                     ??Qmc5883lFilterGetData_4: (+1)
   \   0000011E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000120   0x....             LDR.N    R7,??DataTable4_3
   \   00000122   0x783F             LDRB     R7,[R7, #+0]
   \   00000124   0x1E7F             SUBS     R7,R7,#+1
   \   00000126   0x42BE             CMP      R6,R7
   \   00000128   0xDBDD             BLT.N    ??Qmc5883lFilterGetData_5
    310              }
    311                
    312              FilterArrary[FilterCount - 1][0] = magnet_raw[0];
   \                     ??Qmc5883lFilterGetData_2: (+1)
   \   0000012A   0x8806             LDRH     R6,[R0, #+0]
   \   0000012C   0x....             LDR.N    R7,??DataTable4_2
   \   0000012E   0x.... 0x....      LDR.W    R12,??DataTable4_3
   \   00000132   0xF89C 0xC000      LDRB     R12,[R12, #+0]
   \   00000136   0xF05F 0x0E06      MOVS     LR,#+6
   \   0000013A   0xFB0E 0x770C      MLA      R7,LR,R12,R7
   \   0000013E   0xF827 0x6C06      STRH     R6,[R7, #-6]
    313              FilterArrary[FilterCount - 1][1] = magnet_raw[1];
   \   00000142   0x8846             LDRH     R6,[R0, #+2]
   \   00000144   0x....             LDR.N    R7,??DataTable4_2
   \   00000146   0x.... 0x....      LDR.W    R12,??DataTable4_3
   \   0000014A   0xF89C 0xC000      LDRB     R12,[R12, #+0]
   \   0000014E   0xF05F 0x0E06      MOVS     LR,#+6
   \   00000152   0xFB0E 0x770C      MLA      R7,LR,R12,R7
   \   00000156   0xF827 0x6C04      STRH     R6,[R7, #-4]
    314              FilterArrary[FilterCount - 1][2] = magnet_raw[2];
   \   0000015A   0x8880             LDRH     R0,[R0, #+4]
   \   0000015C   0x....             LDR.N    R6,??DataTable4_2
   \   0000015E   0x....             LDR.N    R7,??DataTable4_3
   \   00000160   0x783F             LDRB     R7,[R7, #+0]
   \   00000162   0xF05F 0x0C06      MOVS     R12,#+6
   \   00000166   0xFB0C 0x6607      MLA      R6,R12,R7,R6
   \   0000016A   0xF826 0x0C02      STRH     R0,[R6, #-2]
    315                  
    316              filter_magnet[0] = sum_x / FilterCount;
   \   0000016E   0x....             LDR.N    R0,??DataTable4_3
   \   00000170   0x7800             LDRB     R0,[R0, #+0]
   \   00000172   0xFB91 0xF0F0      SDIV     R0,R1,R0
   \   00000176   0x8028             STRH     R0,[R5, #+0]
    317              filter_magnet[1] = sum_y / FilterCount;
   \   00000178   0x....             LDR.N    R0,??DataTable4_3
   \   0000017A   0x7800             LDRB     R0,[R0, #+0]
   \   0000017C   0xFB92 0xF0F0      SDIV     R0,R2,R0
   \   00000180   0x8068             STRH     R0,[R5, #+2]
    318              filter_magnet[2] = sum_z / FilterCount;
   \   00000182   0x....             LDR.N    R0,??DataTable4_3
   \   00000184   0x7800             LDRB     R0,[R0, #+0]
   \   00000186   0xFB93 0xF0F0      SDIV     R0,R3,R0
   \   0000018A   0x80A8             STRH     R0,[R5, #+4]
    319              
    320              magnet[0] = (float)filter_magnet[0] / 120.f;//uT
   \   0000018C   0xF9B5 0x0000      LDRSH    R0,[R5, #+0]
   \   00000190   0x.... 0x....      BL       __aeabi_i2f
   \   00000194   0x....             LDR.N    R1,??DataTable4_4  ;; 0x42f00000
   \   00000196   0x.... 0x....      BL       __aeabi_fdiv
   \   0000019A   0x6020             STR      R0,[R4, #+0]
    321              magnet[1] = (float)filter_magnet[1] / 120.f;//uT
   \   0000019C   0xF9B5 0x0002      LDRSH    R0,[R5, #+2]
   \   000001A0   0x.... 0x....      BL       __aeabi_i2f
   \   000001A4   0x....             LDR.N    R1,??DataTable4_4  ;; 0x42f00000
   \   000001A6   0x.... 0x....      BL       __aeabi_fdiv
   \   000001AA   0x6060             STR      R0,[R4, #+4]
    322              magnet[2] = (float)filter_magnet[2] / 120.f;//uT
   \   000001AC   0xF9B5 0x0004      LDRSH    R0,[R5, #+4]
   \   000001B0   0x.... 0x....      BL       __aeabi_i2f
   \   000001B4   0x....             LDR.N    R1,??DataTable4_4  ;; 0x42f00000
   \   000001B6   0x.... 0x....      BL       __aeabi_fdiv
   \   000001BA   0x60A0             STR      R0,[R4, #+8]
    323          
    324              return true;
   \   000001BC   0x2001             MOVS     R0,#+1
   \   000001BE   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    325          }
    326          

   \                                 In section .text, align 2, keep-with-next
    327          bool Qmc5883lI2cByteWrite(uint8_t reg,uint8_t  data)
    328          {
   \                     Qmc5883lI2cByteWrite: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    329              if (I2cByteWrite(I2cHander, __QMC5883L_I2C_ADDRESS__, reg, data)  != HAL_OK)
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x9101             STR      R1,[SP, #+4]
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   \   0000000C   0x231A             MOVS     R3,#+26
   \   0000000E   0x....             LDR.N    R0,??DataTable4
   \   00000010   0xC807             LDM      R0,{R0-R2}
   \   00000012   0x.... 0x....      BL       I2cByteWrite
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD001             BEQ.N    ??Qmc5883lI2cByteWrite_0
    330               {
    331                  return false;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE000             B.N      ??Qmc5883lI2cByteWrite_1
    332              }
    333              
    334              return true;
   \                     ??Qmc5883lI2cByteWrite_0: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \                     ??Qmc5883lI2cByteWrite_1: (+1)
   \   00000020   0xBD0E             POP      {R1-R3,PC}       ;; return
    335          }
    336          

   \                                 In section .text, align 2, keep-with-next
    337          bool  Qmc5883lI2cBytesRead(uint8_t reg, uint8_t* data, uint16_t size)
    338          {
   \                     Qmc5883lI2cBytesRead: (+1)
   \   00000000   0xB5E0             PUSH     {R5-R7,LR}
    339             if (I2cBytesRead(I2cHander, __QMC5883L_I2C_ADDRESS__, reg, data, size)  != true)
   \   00000002   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000004   0x9202             STR      R2,[SP, #+8]
   \   00000006   0x9101             STR      R1,[SP, #+4]
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   \   0000000C   0x231A             MOVS     R3,#+26
   \   0000000E   0x....             LDR.N    R0,??DataTable4
   \   00000010   0xC807             LDM      R0,{R0-R2}
   \   00000012   0x.... 0x....      BL       I2cBytesRead
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD101             BNE.N    ??Qmc5883lI2cBytesRead_0
    340              {
    341                 return false;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE000             B.N      ??Qmc5883lI2cBytesRead_1
    342             }
    343          
    344             return true;
   \                     ??Qmc5883lI2cBytesRead_0: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \                     ??Qmc5883lI2cBytesRead_1: (+1)
   \   00000020   0xBD0E             POP      {R1-R3,PC}       ;; return
    345          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     I2cHander

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x000186A0         DC32     0x186a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     FilterArrary

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     FilterCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x42F00000         DC32     0x42f00000

   \                                 In section .rodata, align 4
   \   00000000   0x0000 0x0000      DC16 0, 0, 0
   \              0x0000       
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \   00000000   0x0000 0x0000      DC16 0, 0, 0
   \              0x0000       
   \   00000006   0x00 0x00          DC8 0, 0
    346          
    347          bool  Qmc5883lI2cByteRead(uint8_t reg, uint8_t* data)
                       ^
Warning[Pe177]: function "Qmc5883lI2cByteRead" was declared but never
          referenced
    348          {
    349             if (I2cByteRead(I2cHander, __QMC5883L_I2C_ADDRESS__, reg, data)  != true)
    350              {
    351                 return false;
    352             }
    353          
    354             return true;
    355          }
    356          //bool Qmc5883lGetDataEx (float *magnet, int16_t *magnetRaw, Qmc5983lAccData *acc_data)
    357          //{
    358          //    uint8_t Buff[6];
    359          //    uint8_t i;
    360          //    uint8_t temp;
    361          //    //uint8_t print_buffer[64];
    362          //    uint16_t convert;
    363          //    Qmc5883lI2cByteRead(0x06, &temp);
    364          //    
    365          //    //temp = QMC5883_ReadReg(0x06);
    366          //    
    367          //    if (temp & 0x02)
    368          //    {
    369          //    	//LOG("output data OVL or ERROR!")
    370          //    	return false;
    371          //    }
    372          //    
    373          //    if ((temp & 0x01) == 0)
    374          //    {
    375          //    	//LOG("output data not ready!")
    376          //    	return false;
    377          //    }
    378          //
    379          //    for (i = 0; i < 6; i++)
    380          //    {
    381          //        Qmc5883lI2cByteRead(i, &Buff[i]);
    382          //    }
    383          //    
    384          //    //I2C_ReadByte(Buff,6,0x00,QMC5883_ADDR);
    385          //    magnetRaw[0] = ((int16_t)Buff[1] << 8) | Buff[0];
    386          //    magnetRaw[1] = ((int16_t)Buff[3] << 8) | Buff[2];
    387          //    magnetRaw[2] = ((int16_t)Buff[5] << 8) | Buff[4];
    388          //
    389          //    acc_data->x = ((int16_t)Buff[1] << 8) | Buff[0];
    390          //    acc_data->y = ((int16_t)Buff[3] << 8) | Buff[2];
    391          //    acc_data->z = ((int16_t)Buff[5] << 8) | Buff[4];
    392          //    
    393          //    for(i=0;i<3;i++)
    394          //    {
    395          //        convert = magnetRaw[i];
    396          //        magnet[i] = (float)convert / 120.f;//uT
    397          //    }		
    398          //    
    399          //       convert = magnetRaw[0];
    400          //        
    401          //      convert = (acc_data->x);
    402          //      magnet[0] = (float)convert / 120.f;//uT
    403          //      convert = acc_data->y;
    404          //      magnet[1] = convert / 120.f;//uT
    405          //      convert = acc_data->z;
    406          //      magnet[2] = convert / 120.f;//uT
    407          //
    408          //    
    409          //    
    410          //   // i = sprintf(print_buffer, "reg0~5 :%02x,%02x,%02x,%02x,%02x,%02x\r\n", Buff[0], Buff[1], Buff[2], Buff[3], Buff[4], Buff[5]);
    411          //   // HAL_UART_Transmit(&huart3, print_buffer,  i, 500);
    412          //
    413          //   // i = sprintf(print_buffer, "MagnetRaw :%0x,%0x,%0x\r\n", MagnetRaw[0], MagnetRaw[1], MagnetRaw[2]);
    414          //  //  HAL_UART_Transmit(&huart3, print_buffer,  i, 500);
    415          //
    416          //  //  i = sprintf(print_buffer, "Magnet :%f,%f,%f\r\n", magnet[0], magnet[1], magnet[2]);
    417          //  //  HAL_UART_Transmit(&huart3, print_buffer,  i, 500);
    418          //    return true;
    419          //}
    420          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   Qmc5883lConfig
        24   -> Qmc5883lI2cByteWrite
        24   -> Qmc5883lI2cBytesRead
        24   -> memset
      24   Qmc5883lConfigEx
        24   -> Qmc5883lI2cByteWrite
        24   -> Qmc5883lI2cBytesRead
        24   -> memset
      24   Qmc5883lFilterGetData
        24   -> __aeabi_fdiv
        24   -> __aeabi_i2f
      32   Qmc5883lGetData
        32   -> Qmc5883lI2cBytesRead
        32   -> __aeabi_fdiv
        32   -> __aeabi_i2f
      16   Qmc5883lI2cByteWrite
        16   -> I2cByteWrite
      16   Qmc5883lI2cBytesRead
        16   -> I2cBytesRead
       8   Qmc5883lInit
         8   -> I2cInit
         8   -> Qmc5883lPowerOff
         8   -> Qmc5883lPowerOn
         8   -> memset
       8   Qmc5883lPowerOff
         8   -> Delay
       8   Qmc5883lPowerOn
         8   -> Delay
      32   Qmc5883lSelfTest
        32   -> Delay
        32   -> Qmc5883lGetData
        32   -> Qmc5883lI2cByteWrite
        32   -> Qmc5883lI2cBytesRead


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       8  ?_0
       8  ?_1
      48  FilterArrary
       1  FilterCount
      12  I2cHander
      84  Qmc5883lConfig
      88  Qmc5883lConfigEx
     448  Qmc5883lFilterGetData
     146  Qmc5883lGetData
      34  Qmc5883lI2cByteWrite
      34  Qmc5883lI2cBytesRead
      78  Qmc5883lInit
      10  Qmc5883lPowerOff
      10  Qmc5883lPowerOn
     358  Qmc5883lSelfTest

 
    61 bytes in section .bss
    16 bytes in section .rodata
 1 310 bytes in section .text
 
 1 310 bytes of CODE  memory
    16 bytes of CONST memory
    61 bytes of DATA  memory

Errors: none
Warnings: 14
